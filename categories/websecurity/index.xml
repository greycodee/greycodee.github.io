<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WebSecurity on Greycode's Blog</title><link>https://blog.greycode.top/categories/websecurity/</link><description>Recent content in WebSecurity on Greycode's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 19 May 2020 20:25:06 +0000</lastBuildDate><atom:link href="https://blog.greycode.top/categories/websecurity/index.xml" rel="self" type="application/rss+xml"/><item><title>基于SpringCloud搭建Spring-security-oauth认证服务器</title><link>https://blog.greycode.top/posts/spring-security-oauth-server-demo/</link><pubDate>Tue, 19 May 2020 20:25:06 +0000</pubDate><guid>https://blog.greycode.top/posts/spring-security-oauth-server-demo/</guid><description>准备阶段 这里搭建一个用OAuth2.0密码模式认证的服务器，token存入redis，client存入Mysql；
所以事先要准备好：
Redis Mysql 并且Mysql执行Spring-security-oauth初始化Sql这个SQL，初始化Spring-security-oauth所需要的表。然后执行
-- 插入client_id和client_secret都为sunline的客户端 insert into oauth_client_details (client_id, client_secret, authorized_grant_types , autoapprove) values (&amp;#34;sunline&amp;#34;,&amp;#34; {bcrypt}$2a$10$G1CFd535SiyOtvi6ckbZWexQy.hW5x/I/fLBPiW/E4UmctCfKYbgG&amp;#34;,&amp;#34;password&amp;#34;,&amp;#34;true&amp;#34;); client_secret为new BCryptPasswordEncoder().encode(&amp;quot;sunline&amp;quot;)方法加密后，然后在加上{bcrypt}
开始搭建 导入pom依赖 &amp;lt;!--security-oauth--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-oauth2&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--redis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--mysql--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.17&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 配置application.properties #datasource spring.datasource.url=jdbc:mysql://localhost:3307/grey_code?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;autoReconnect=true&amp;amp;serverTimezone=Asia/Shanghai spring.datasource.username=zmh spring.datasource.password=zmh #redis spring.redis.host=127.0.0.1 spring.redis.port=6379 server.port=9991 server.servlet.context-path=/oauthServer 创建用户详情服务类 创建权限控制类 创建认证授权类 获取令牌 访问:/oauth/token就可以获取到令牌
{ &amp;#34;accessToken&amp;#34;: &amp;#34;e28f9a99-e60d-4693-b6c3-73e06a1d14f5ZMH10086&amp;#34;, &amp;#34;expiration&amp;#34;: &amp;#34;2020-05-19T21:11:39.883+0000&amp;#34;, &amp;#34;scope&amp;#34;: [ &amp;#34;all&amp;#34; ], &amp;#34;tokenType&amp;#34;: &amp;#34;bearer&amp;#34; } 访问资源 带上获取到的令牌</description></item><item><title>SSO单点登录和CAS框架</title><link>https://blog.greycode.top/posts/sso-and-cas/</link><pubDate>Thu, 14 May 2020 19:27:14 +0000</pubDate><guid>https://blog.greycode.top/posts/sso-and-cas/</guid><description>SSO单点登录 单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。这项功能通常是以轻型目录访问协议（LDAP）来实现，在服务器上会将用户信息存储到LDAP数据库中。相同的，单一退出（single sign-off）就是指，只需要单一的退出动作，就可以结束对于多个系统的访问权限。
优点 使用单点登录的好处包括：
降低访问第三方网站的风险（不存储用户密码，或在外部管理）。 减少因不同的用户名和密码组合而带来的密码疲劳。 减少为相同的身份重新输入密码所花费的时间。 因减少与密码相关的调用IT服务台的次数而降低IT成本。[1] SSO为所有其它应用程序和系统，以集中的验证服务器提供身份验证，并结合技术以确保用户不必频繁输入密码。
CAS框架 CAS 协议基于在客户端Web浏览器、Web应用和CAS服务器之间的票据验证。当客户端访问访问应用程序，请求身份验证时，应用程序重定向到CAS。CAS验证客户端是否被授权，通常通过在数据库对用户名和密码进行检查。如果身份验证成功，CAS一次性在客户端以Cookie形式发放TGT票据，在其有效期CAS将一直信任用户，同时将客户端自动返回到应用程序，并向应用传递身份验证票（Service ticket）。然后，应用程序通过安全连接连接CAS，并提供自己的服务标识和验证票。之后CAS给出了关于特定用户是否已成功通过身份验证的应用程序授信信息。
历史 CAS是由耶鲁大学[1]的Shawn Bayern创始的，后来由耶鲁大学的Drew Mazurek维护。CAS1.0实现了单点登录。 CAS2.0引入了多级代理认证（Multi-tier proxy authentication）。CAS其他几个版本已经有了新的功能。
2004年12月，CAS成为Jasig[2]的一个项目，2008年该组织负责CAS的维护和发展。CAS原名“耶鲁大学CAS”，此后被称为“Jasig CAS”。
2005年5月，CAS协议版本2发布，引入代理和服务验证。
2006年12月，安德鲁·W·梅隆基金会授予耶鲁大学第一届梅隆技术协作奖，颁发50000美元的奖金对耶鲁大学开发CAS进行奖励。[3]颁奖之时，CAS在“数以百计的大学校园”中使用。
2012年12月，JASIG与Sakai基金合并，CAS改名为Apereo CAS。
2016年11月，基于Spring Boot的CAS软件版本5发布。</description></item><item><title>OAuth2.0与JWT</title><link>https://blog.greycode.top/posts/oauth-and-jwt/</link><pubDate>Tue, 12 May 2020 14:59:43 +0000</pubDate><guid>https://blog.greycode.top/posts/oauth-and-jwt/</guid><description>OAuth2.0 OAuth2.0是一个授权协议，它允许软件应用代表资源拥有者去访问资源拥有者的资源。应用向资源拥有者请求令牌，并用这个令牌来访问资源拥有者的资源。
角色 客户端：相当于访问受保护资源的软件 授权服务器：授予客户端令牌的服务 资源拥有者：受保护的资源拥有者，有权决定将不将令牌授权给客户端 受保护的资源：除资源拥有者外，要访问此资源必须要有授权服务器颁发的有效的令牌 授权类型 授权码许可类型 隐式许可类型 客户端凭证许可类型 资源拥有者凭证许可类型(账号密码模式) 断言许可类型 JWT JWT全称：JSON Web Token，是一种令牌格式。其格式类似为xxxxx.yyyyy.zzzzz,分为三部分，每个部分都用Base64进行编码，之间用.分隔。
第一部分：为Header部分，标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。
{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } 第二部分：令牌的第二部分是有效负载，其中包含声明。 声明是有关实体（通常是用户）和其他数据的声明。 共有三种类型的声明：注册的，公共的和私有的三种声明。当然里面可以存放任何有效的字段信息（私有声明）。但是为了避免不同实现之间不兼容，可以准守JWT官方提供的声明字段。
注册声明：JWT官方提供的声明，参考资料:https://tools.ietf.org/html/rfc7519#section-4.1 公共声明：用户发邮件给JWT官方进行注册的声明字段，参考资料：https://tools.ietf.org/html/rfc7519#section-4.2 私有声明：完全用户自定义，参考资料https://tools.ietf.org/html/rfc7519#section-4.3 第三部分：为令牌签名部分，使用这个字段后，资源服务器只会接受签名正确的令牌。</description></item></channel></rss>