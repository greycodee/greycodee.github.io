<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>协议 on Greycode'Blog</title><link>https://greycode.top/categories/%E5%8D%8F%E8%AE%AE/</link><description>Recent content in 协议 on Greycode'Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 29 Mar 2022 13:41:40 +0000</lastBuildDate><atom:link href="https://greycode.top/categories/%E5%8D%8F%E8%AE%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis是怎样通讯的？</title><link>https://greycode.top/posts/8b135153fd9d41de928df42f84ad1eca/</link><pubDate>Tue, 29 Mar 2022 13:41:40 +0000</pubDate><guid>https://greycode.top/posts/8b135153fd9d41de928df42f84ad1eca/</guid><description>模型 Redis 协议模型就是简单的请求-响应模型，和平常的 Http 协议有点类似。客户端发送 Redis 命令，然后服务端处理命令并返回结果给客户端。Redis 官方说这可能是最简单的网络协议模型了。
有两种情况下不 不适用这个模型，一个是批量流水线命令，一个是发布/订阅功能。
协议描述 Redis 协议一般简单的分为 5 类数据结构，简单字符串、错误信息、数值、大字符串、数组。每种数据类型在第一个字节用不同的符号来区分：
简单字符串(Simple Strings)：开头第一个符号为 +，对应 HEX 值为：0x2b 错误信息(Errors)：第一个字节符号为 -，对应 HEX 值为：0x2d 数值(Integers)：第一个字节符号为 :，对应 HEX 值为：0x3a 大字符串(Bulk Strings)：第一个字节符号为 $，对应 HEX 值为：0x24 数组(Arrays)：第一个字节符号为 *，对应 HEX 值为：0x2a 这 5 种数据类型可以组合起来使用，每种数据类型通过 CRLF 结尾，就是平常的 \r\n，对应的 HEX 值为：0x0d,0x0a。一般我们判断一种数据类型是否结束时，只要判断是否有 \r 出现就可以了。Redis 客户端和服务端之间就是通过这些规则来进行通信的。
简单字符串 一般简单字符串用于返回 Redis 服务端的系统响应，如果要响应用户存储的数据时，一般会用大字符串(Bulk Strings)的数据类型来返回。
比如说客户端发送 set 命令新增一个 Key 来存储字符串，此时客户端就会返回 +OK。这种方式返回的数据不能有空格和换行，因为空格和换行表示该类型的数据结尾。
redis:0&amp;gt;set name 灰灰 &amp;#34;OK&amp;#34; # Redis 服务端响应数据 0000 2b 4f 4b 0d 0a +OK·· 错误信息 当我们执行的命令发生错误时，Redis 服务端就会返回错误信息</description></item><item><title>MySQL是怎样通讯的？</title><link>https://greycode.top/posts/2852f14d7d13471798ce28c544741e89/</link><pubDate>Sun, 27 Mar 2022 23:51:51 +0000</pubDate><guid>https://greycode.top/posts/2852f14d7d13471798ce28c544741e89/</guid><description>前言 我们平常使用数据库的场景一般是程序里面代码直接连接使用，然后进行 CRUD 操作。或者使用有 GUI 界面的数据库软件来手动操作数据库， 这类软件有 DataGrip、Navicat等等&amp;hellip;。平常很少关心它们的底层数据交互是怎么样的，相信你看了这篇文章一定能有大概的了解。本篇文章的代码使用 Go 语言来实现 MySQL 的协议。
协议简介 MySQL 协议一般分为两个阶段，一个是连接阶段，一个是命令阶段。 连接阶段主要是客户端和服务端进行相互认证的阶段，就像我们平常登陆某个网站的一个操作。 命令阶段主要是客户端向服务端进行的一些指令的发送，然后服务端处理指令并返回结果的一个过程。 在客户端和服务端发送的数据包中，前 3 个字节表示这个数据包的大小，所以这里就有一个问题，就是它有一个大小的限制，数据包大小不能超过16777215 ($2^{24}-1$) bytes，也就是 16M 大小（16进制表示：ff ff ff，刚刚 3 个字节）。这就会有三种情况出现，一种是数据包小于 16M，一种是等于，一种是大于。所以在 MySQL 协议中是这样处理的：
小于 16M：发送一个数据包就可以了 等于 16M：发送两个数据包，第二个包为空包 大于 16M：发送多个数据包，每个数据包大小最大为 16M，当最后一个数据包等于 16M 时，再多发送一个空数据包 每个数据包中的第 4 个字节表示这个数据包的序号ID，这个 ID 在不同阶段会递增，比如在连接阶段，这个 ID 会随着包的数量而递增，当连接阶段完成后进入命令阶段，这个 ID 又会从 0 开始递增，直到这个命令的生命周期结束。
初始握手包 当客户端进行尝试使用 TCP 连接 MySQL 服务端时，服务端就会响应一个初始的握手包，这个握手包有 V9、V10 两个版本。不过现在一般用的都是 V10 版本，如果 MySQL 的版本在 3.21.0 之前，那么服务端响应的是 V9 版本的初始握手包。本篇文章就讲讲现在常用的 V10 版本的初始握手包。</description></item></channel></rss>