<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring on Greycode'Blog</title><link>https://greycode.top/categories/spring/</link><description>Recent content in Spring on Greycode'Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 08 May 2021 22:47:54 +0000</lastBuildDate><atom:link href="https://greycode.top/categories/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>使用Nacos实现网关动态路由</title><link>https://greycode.top/posts/eef92888390b4e7c866fe7ada6a0b42b/</link><pubDate>Sat, 08 May 2021 22:47:54 +0000</pubDate><guid>https://greycode.top/posts/eef92888390b4e7c866fe7ada6a0b42b/</guid><description>背景 网关作为一个主要的外部流量入口，其重启的次数当然是越少越好，所以不能有时候为了修改一个路由就重启整个网关服务，这样的话网关就不是一个高可用的网关。当然，有时候要新增或修改代码层面的自定义的过滤器时还是要重启网关的，所以我们能做的就是尽可能减少不必要的重启。这里就可以引入阿里巴巴开源的 Nacos 了。
什么是 Nacos？ Naocs 是阿里巴巴开源的一款微服务组件，它提供注册中心和配置中心来供我们使用。并且 Nacos 同时支持 AP 模式和 CP 模式来供我们选择使用。具体可以查看官方文档来进一步了解。
安装 Nacos 本地的话我这边建议直接用 Docker 来安装Nacos，省心省力。按照官方提供的方法，我们可以直接下载官方提供的 docker-compose 文件来启动 Nacos。
# 克隆项目 git clone https://github.com/nacos-group/nacos-docker.git ## 进入项目目录 然后启动 cd nacos-docker docker-compose -f example/standalone-mysql-5.7.yaml up 我这边是启动了一个使用 MySQL 5.7 的单机 Nacos，如果你想使用其他的数据库或者启动集群的话可以参照一下官方文档
待启动完成后，就可以用浏览器打开 http://localhost:8848/nacos 进入 Nacos的管理台了。默认的登陆账号密码都是 nacos
网关使用 Nacos 我这边 Spring Cloud 使用的版本号是 2020.0.2
Nacos 创建配置 在开始配置网关项目前，我们先在 Nacos 里创建一个配置，等下网关启动的时候就用这个配置。
server: port: 8989 spring: cloud: gateway: routes: - id: route-demo uri: https://baidu.</description></item><item><title>快速搭建一个SpringGateway网关</title><link>https://greycode.top/posts/9944cc0febd34a3ebd04eaa1564f4c3a/</link><pubDate>Fri, 07 May 2021 13:05:58 +0000</pubDate><guid>https://greycode.top/posts/9944cc0febd34a3ebd04eaa1564f4c3a/</guid><description>☝️搭建脚手架 我们可以去 Spring initializer 网站或者用 IDEA 来快速创建出一个 Spring Cloud Gateway 项目。
这里我们选择的注册中心是 Zookeeper，你也可以自己选择其他的注册中心来注册你的项目，比如阿里巴巴的 Nacos 等。
配置完相关信息后，点击下面的 GENERATE 按钮就可以导出项目的 zip 压缩包，解压后用 IDE 打开。
打开后就是这个样子：
✌️配置路由 Ymal 方式配置 为了方便配置，我们把 application.properties 改成 application.yml 。
然后配置一个转发到百度到路由。
spring: cloud: gateway: routes: - id: route-demo uri: https://baidu.com predicates: - Path=/** 在配置中，我加来一个谓词 Path ，表示所有当请求都会匹配到这个路由下，然后转发到 uri 配置到网址里。所以当我们打开浏览器访问 [http://localhost:8080/](http://localhost:8080/) 是就会自动跳转到百度到首页。
Java 代码方式配置 除了用配置文件配置路由外，我们还可以用代码的方式来配置路由。
下面来展示一下代码方式配置的路由：
@Bean public RouteLocator routesConfig(RouteLocatorBuilder builder){ return builder.routes() .</description></item><item><title>Fegin和RestTemplate添加全局请求头</title><link>https://greycode.top/posts/fegin-resttemplate-addheard/</link><pubDate>Wed, 16 Sep 2020 15:14:43 +0000</pubDate><guid>https://greycode.top/posts/fegin-resttemplate-addheard/</guid><description>Fegin添加全局请求头 实现RequestInterceptor接口 /** * 实现RequestInterceptor接口的apply方法 */ @Configuration public class FeignRequestInterceptor implements RequestInterceptor { @Override public void apply(RequestTemplate requestTemplate) { ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder .getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames(); if (headerNames != null) { while (headerNames.hasMoreElements()) { String name = headerNames.nextElement(); String values = request.getHeader(name); requestTemplate.header(name, values); } } } } 在@FeginClient注释里configuration所填入的类文件中添加上面的拦截器</description></item><item><title>创建一个自定义注解</title><link>https://greycode.top/posts/apring-aop-ann/</link><pubDate>Mon, 22 Jun 2020 16:23:56 +0000</pubDate><guid>https://greycode.top/posts/apring-aop-ann/</guid><description>前言 平时在用springBoot的使用，常常会用到@Service，@Compent等等注解，简化了我们的开发流程，提升了开发效率.那如何自己来写一个注解呢？下面就来介绍一下。
写一个注解 创建一个注解主要分两部分，一部分是创建注解类，一部分是创建一个切面类。
创建注解类 @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnn { String value() default &amp;#34;d&amp;#34;; } 创建注解类的关键字就是@interface，这个注解类设置了一个value变量，默认值为d；
在注解类上面还有@Target和@Retention注解，下面来说说创建注解类时需要用到的几个注解：
@Target 用来标记这个注解可以用于哪些地方，与ElementType枚举类搭配使用，那这个枚举类里面有什么内容呢？
public enum ElementType { /** 类，接口（包括注释类型）或枚举声明*/ TYPE, /** 字段声明（包括枚举常量）*/ FIELD, /** 方法声明*/ METHOD, /** 形式参数（形参-调用方法时传入的参数）声明 */ PARAMETER, /** 构造函数声明 */ CONSTRUCTOR, /** 局部变量声明 */ LOCAL_VARIABLE, /** 注释类型声明 */ ANNOTATION_TYPE, /** 包声明 */ PACKAGE, /** * 类型参数声明 * java8新特性： * @since 1.</description></item><item><title>RestTemplate简单使用</title><link>https://greycode.top/posts/spring-boot-resttemplate-example/</link><pubDate>Wed, 20 Nov 2019 17:32:18 +0000</pubDate><guid>https://greycode.top/posts/spring-boot-resttemplate-example/</guid><description>前言 本文只讲常用的**GET** 和**POST**请求,其他类型的请求(如**PUT**，**PATCH**)请求方式都差不多，有兴趣的可以查看RestTemplate源码。 GET GET官方给了getForEntity和getForObject两种种方法，每个方法又有三个重载方法
官方源码接口 @Nullable &amp;lt;T&amp;gt; T getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables) throws RestClientException; @Nullable &amp;lt;T&amp;gt; T getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; uriVariables) throws RestClientException; @Nullable &amp;lt;T&amp;gt; T getForObject(URI url, Class&amp;lt;T&amp;gt; responseType) throws RestClientException; &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(String url, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables) throws RestClientException; &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(String url, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?</description></item></channel></rss>