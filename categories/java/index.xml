<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Greycode's Blog</title><link>https://greycode.top/categories/java/</link><description>Recent content in Java on Greycode's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 17 Aug 2021 16:10:53 +0000</lastBuildDate><atom:link href="https://greycode.top/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>AviatorScript轻量级高性能脚本语言</title><link>https://greycode.top/posts/ca3ab1d58ea74b76a5fd69f79dd5ec79/</link><pubDate>Tue, 17 Aug 2021 16:10:53 +0000</pubDate><guid>https://greycode.top/posts/ca3ab1d58ea74b76a5fd69f79dd5ec79/</guid><description>简介 在 5.0 版本以前，它的名字是叫 Aviator ，定位一直只是一个表达式引擎，不支持 if/else 条件语句（仅有三元运算符支持 ?: ），没有内置的 for/while 循环支持（虽然你可以用 seq 库类似函数式的方式来处理集合），也没有赋值（后来在 4.0 引入），没有作用域的概念（也在 4.0 引入 lambda 函数后部分实现）等等一般语言常见的能力。在 5.0 版本后，它变成了一门脚本语言，叫：AviatorScript 。
在 5.0 ，新加了如下新特性：
大括号 { ... } 括起来的词法作用域。
let 语句用于定义局部变量。
条件语句 if/elsif/else 。
循环语句 for 和 while ，以及相应的 break 和 continue 语句支持。
return 语句用于从脚本或者函数中返回值。
fn hello() { println(&amp;quot;hello&amp;quot;); } 新的 fn 语法用于定义命名函数。
## 单行注释 注释支持
模块系统
new 语法用于创建对象
异常处理
命令行工具 aviator
使用 AviatorScript 可以单纯的作为脚本语言使用，也可以和 Java 配合使用。
单纯的作为脚本语言使用 作为脚本语言使用时，需要下载一个 aviator，然后用它去执行脚本文件。</description></item><item><title>Java删除文件后电脑磁盘空间没有恢复</title><link>https://greycode.top/posts/74caaafd610241a1b8ecdb5f3bb33ee4/</link><pubDate>Sat, 03 Jul 2021 17:12:41 +0000</pubDate><guid>https://greycode.top/posts/74caaafd610241a1b8ecdb5f3bb33ee4/</guid><description>问题 当用一下命令删除文件后，电脑磁盘内存没有恢复，还是原来的大小
File folder = new File(&amp;#34;/tmp/file.mp4&amp;#34;) file.delete(); 解决 原来是 FileOutputStream 文件流忘了关了，导致一直占用这个资源。所以使用完后一定记得关文件流，使用下面的代码关闭文件流：
FileOutputStream fileOutputStream = new FileOutputStream(new File()); fileOutputStream.close(); Linux 里的文件被删除后，空间没有被释放是因为在 Linux 系统中，通过 rm 或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的(有一个进程正在使用)，那么进程将仍然可以读取该文件，磁盘空间也一直被占用。
可以使用 lsof +L1 |grep delete 命令来查看状态为 deleted 的文件，状态为 deleted 为标记被删除，其实该文件并没有从磁盘中删除，类似windows下的回收站状态。
所以当进程结束后，磁盘空间就会被释放。
参考资料 http://www.cxyzjd.com/article/su4416160/78212934 https://www.jianshu.com/p/fcb80c878d04</description></item><item><title>Java的NIO编程-Channel</title><link>https://greycode.top/posts/534d0985-a4a0-4239-ae81-d76378f64552/</link><pubDate>Mon, 01 Mar 2021 10:07:09 +0000</pubDate><guid>https://greycode.top/posts/534d0985-a4a0-4239-ae81-d76378f64552/</guid><description>0x1 主要类型 在Java中有许多NIO Channel实现，本文只选最主要的四种Channel：
FileChannel：文件通道，用于文件的数据读写 SocketChannel：套接字通道，用于Socket套接字TCP连接的数据读写。 ServerSocketChannel：服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。 DatagramChannel：数据报通道，用于UDP协议的数据读写。 0x2 使用 FileChannel 读取通道数据 首先在本地创建文件/home/zheng/channeltest，在里面编写内容：hello,world!
public class ChannelTest { public static void main(String[] args) throws IOException { // 创建输入流 File file = new File(&amp;#34;/home/zheng/channeltest&amp;#34;); FileInputStream fis = new FileInputStream(file); // 获取通道 FileChannel fileChannel = fis.getChannel(); // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int length = -1; // 读取通道数据到缓冲区 while ((length=fileChannel.read(byteBuffer))!=-1){ System.out.println(&amp;#34;缓冲区size：&amp;#34;+length); } fis.close(); fileChannel.close(); // 读取Buffer缓存数据 byteBuffer.flip(); StringBuilder str = new StringBuilder(); while (byteBuffer.</description></item><item><title>Java的NIO编程-Selector</title><link>https://greycode.top/posts/2571330c-67ef-4d4c-8717-6c96768009c7/</link><pubDate>Mon, 01 Mar 2021 10:07:07 +0000</pubDate><guid>https://greycode.top/posts/2571330c-67ef-4d4c-8717-6c96768009c7/</guid><description>0x1 监控 通道和选择器之间的关系，通过register（注册）的方式完成。调用通道的Channel.register（Selector sel, int ops）方法，可以将通道实例注册到一个选择器中。register方法有两个参数：第一个参数，指定通道注册到的选择器实例；第二个参数，指定选择器要监控的IO事件类型。
IO事件类型有：
可读：SelectionKey.OP_READ 可写：SelectionKey.OP_WRITE 连接：SelectionKey.OP_CONNECT 接收：SelectionKey.OP_ACCEPT 如果一下要监控多个事件的话可以用位或运算符来实现
int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 0x2 SelectionKey选择键 选择键的功能是很强大的。通过SelectionKey选择键，不仅仅可以获得通道的IO事件类型，比方说SelectionKey.OP_READ；还可以获得发生IO事件所在的通道；另外，也可以获得选出选择键的选择器实例。
常用方法 isAcceptable()：判断IO事件类型是否是SelectionKey.OP_ACCEPT isReadable()：判断IO事件是否是SelectionKey.OP_READ isConnectable():判断IO事件是否是SelectionKey.OP_CONNECT isWritable()：判断IO事件是否是SelectionKey.OP_WRITE 0x3 使用条件 并不是所有的Channel都可以使用Selector，判断一个通道能否被选择器监控或选择，有一个前提：判断它是否继承了抽象类SelectableChannel（可选择通道）。如果继承了SelectableChannel，则可以被选择，否则不能。
简单地说，一条通道若能被选择，必须继承SelectableChannel类。
FileChannel就没有继承SelectableChannel类，所以不能使用Selector
0x4 使用流程 使用选择器，主要有以下三步：
获取选择器实例； 将通道注册到选择器中； 轮询感兴趣的IO就绪事件（选择键集合）。 0x5 Demo 源码地址： https://github.com/GreyCode9/nio-demo/tree/main/src/io/selector</description></item><item><title>Java的NIO编程-Buffer</title><link>https://greycode.top/posts/8d2049e3-3eb1-46ed-a44b-57398964eb21/</link><pubDate>Mon, 01 Mar 2021 10:07:05 +0000</pubDate><guid>https://greycode.top/posts/8d2049e3-3eb1-46ed-a44b-57398964eb21/</guid><description>0x1 子类 Buffer是一个抽象类，所以一般使用他的子类来进行编程，常用的子类有：
ByteBuffer
IntBuffer
LongBuffer
CharBuffer
DoubleBufffer
FloatBuffer
ShortBuffer
MappedByteBuffer
0x2 属性 Buffer中有四个重要的属性，分别是：
capacity：Buffer类的capacity属性，表示内部容量的大小 position：Buffer类的position属性，表示当前的位置 limit：Buffer类的limit属性，表示读写的最大上限。 mark：暂存属性，暂时保存position的值，方便后面的重复使用position值。 0x3 方法 Buffer中几个重要的方法有：
allocate()：创建缓存区（BUffer创建缓存区不是用new，而是用这个方法来创建) put()：向缓冲器插入数据 filp()：翻转模式，将缓冲区改为读模式（缓冲区默认模式为写模式）。其实就改变了limit，position，mark属性的值。 get()：从缓冲区读取数据，从position位置开始读 rewind()：倒带（重复读取），就是将position的位置重置为0 mark()：mark()方法的作用就是将当前position的位置暂存起来，放在mark属性中。 reset()：将position重置为mark属性的位置。 clean()：清空缓存区，重置position，limit，mark属性为初始值</description></item><item><title>Java的NIO编程-Reactor模式</title><link>https://greycode.top/posts/0702ff46-16cd-4520-9d33-0794cfda4b09/</link><pubDate>Mon, 01 Mar 2021 10:07:04 +0000</pubDate><guid>https://greycode.top/posts/0702ff46-16cd-4520-9d33-0794cfda4b09/</guid><description>0x1 Reactor模型 0x1 单Reactor单线程</description></item><item><title>Disruptor-消费模式简介(池化)</title><link>https://greycode.top/posts/c16646bf-1474-42a7-a5cd-84b99669062c/</link><pubDate>Mon, 01 Mar 2021 10:02:15 +0000</pubDate><guid>https://greycode.top/posts/c16646bf-1474-42a7-a5cd-84b99669062c/</guid><description>并行模式(池化) 每个消费端有两个线程实例
disruptor.handleEventsWithWorkerPool(new A1Handler(),new A1Handler()); disruptor.handleEventsWithWorkerPool(new A2Handler(),new A2Handler()); 结果示例 可以看到每次执行的线程是不一样的
++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-0 ************************** 1605100167571+A1Handler:10 ************************** DisruptorWorker-2 1605100167572+A2Handler:30 ************************** ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-1 1605100168572+A1Handler:11 ************************** ************************** DisruptorWorker-3 1605100168573+A2Handler:31 ************************** 串行模式（池化） 每个消费端有两个线程实例
disruptor.handleEventsWithWorkerPool(new A1Handler(),new A1Handler()) .then(new A2Handler(),new A2Handler()); 结果示例 ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-0 1605100492248+A1Handler:10 ************************** ************************** DisruptorWorker-2 1605100492249+A2Handler:30 ************************** ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-1 1605100493249+A1Handler:11 ************************** ************************** DisruptorWorker-3 1605100493249+A2Handler:31 **************************</description></item><item><title>Disruptor-缓存行填充</title><link>https://greycode.top/posts/18e3fbd6-ff4b-4a0a-b82f-a547dbef8d0c/</link><pubDate>Mon, 01 Mar 2021 10:02:08 +0000</pubDate><guid>https://greycode.top/posts/18e3fbd6-ff4b-4a0a-b82f-a547dbef8d0c/</guid><description>伪共享概念 CPU架构 常见的CPU架构如下图：
在某个CPU核心上运行一个线程时，他获取数据是先从L1缓存上面找，没有命中数据时，再从L2缓存上面找、还是没有命中时再从L3缓存上找，如果还没有的话就再从主内存里面找。找到后再一层一层的传递数据。
所以查找数据的顺序为：
L1 》L2 》 L3 》主内存
刷新缓存的顺序为：
主内存 》L3 》L2 》L1
缓存存储结构 在计算机缓存中，存储数据是以缓存行为单位的，不同的系统缓存行的大小也不一样，现在常见的64位操作系统，他每行可以存储64字节数据。比如Java中Long类型的数据占8个字节，所以一行可以存8个Long数据类型的数据。
所以当加载缓存行中任意一个数据时，其他在当前缓存行里的数据也会一起加载
线程数据共享 当线程共享一个变量时，每个线程的更改都会把最新数据刷新回主内存，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中（嗅探机制）。
伪共享 上面说的是共享一个缓存行的一个数据，这样是完全没问题的。可是当不同线程要使用一个缓存行里的不同数据时，这样就会出现一种伪共享的情况:
尽管变量a没有被其他线程更改，可以由于他和变量d在同一缓存行里，所以每次都会受变量d的影响,缓存都会被设置为无效状态，所以每次使用时都会从主内存里重新拉取。这样速度就会大大的打折扣。
RingBuffer的解决方法 在RingBuffer解决伪共享的方法就是缓存行填充
abstract class RingBufferPad { protected long p1, p2, p3, p4, p5, p6, p7; }</description></item><item><title>Disruptor-等待策略</title><link>https://greycode.top/posts/ff51336d-70d4-449c-9214-fff2542bef1f/</link><pubDate>Mon, 01 Mar 2021 10:02:06 +0000</pubDate><guid>https://greycode.top/posts/ff51336d-70d4-449c-9214-fff2542bef1f/</guid><description>BlockingWaitStrategy Disruptor默认策略
对EventProcessor使用等待条件的锁和条件变量的阻塞策略。
当吞吐量和低延迟不如CPU资源那么重要时，可以使用此策略。
LiteBlockingWaitStrategy BlockingWaitStrategy的变体，在无竞争的情况下尝试消除条件唤醒。 显示微基准测试的性能改进。
但是，由于我尚未完全证明锁省略码的正确性，因此应将这种等待策略视为实验性的。
BusySpinWaitStrategy 繁忙旋转策略，该繁忙旋转策略对EventProcessor的障碍使用繁忙的旋转循环。
此策略将使用CPU资源来避免可能导致延迟抖动的系统调用。 最好当线程可以绑定到特定的CPU内核时使用。
TimeoutBlockingWaitStrategy LiteTimeoutBlockingWaitStrategy TimeoutBlockingWaitStrategy的变体，在无竞争的情况下尝试消除条件唤醒。
PhasedBackoffWaitStrategy 在屏障上等待EventProcessor的分阶段等待策略。
当吞吐量和低延迟不如CPU资源那么重要时，可以使用此策略。 旋转，然后屈服，然后使用配置的后备WaitStrategy等待。
SleepingWaitStrategy 最初启动的休眠策略，然后使用Thread.yield（），最后在EventProcessor等待屏障时，休眠操作系统和JVM将允许的最小数量的nanos。
此策略是性能和CPU资源之间的良好折衷。 安静时段后可能会出现延迟峰值。 这也将减少对生产线程的影响，因为它不需要发出信号通知任何条件变量来唤醒事件处理线程。
YieldingWaitStrategy 在初始旋转后，使用Thread.yield（）的EventProcessor在屏障上等待。
如果其他线程需要CPU资源，则此策略将使用100％CPU，但比忙碌的自旋策略更容易放弃CPU。</description></item><item><title>Disruptor-消费模式简介(单个实例)</title><link>https://greycode.top/posts/9a1bdb74-8ed3-4905-88bc-7b3b4e0a4af2/</link><pubDate>Mon, 01 Mar 2021 10:01:00 +0000</pubDate><guid>https://greycode.top/posts/9a1bdb74-8ed3-4905-88bc-7b3b4e0a4af2/</guid><description>并行模式 并行模式下两个Handler同时执行，互不影响
disruptor.handleEventsWith(new A1Handler(),new B1Handler()); 结果示例 ++++++++++ 1605084168915+B1Handler:5 1605084168915+A1Handler:1 ++++++++++ 1605084169915+B1Handler:6 1605084169915+A1Handler:2 串行模式 串行模式下，Handler执行必须是从前往后，按顺序执行。
disruptor.handleEventsWith(new A1Handler()).then(new B1Handler()); // or disruptor.handleEventsWith(new B1Handler()).then(new A1Handler()); 结果示例 结果和handler放置的顺序有关，后面的handler要等前面的执行完才会执行
++++++++++ 1605084411462+A1Handler:1 1605084411467+B1Handler:5 ++++++++++ 1605084412463+A1Handler:2 1605084412463+B1Handler:6 // or ++++++++++ 1605084638285+B1Handler:5 1605084638289+A1Handler:1 ++++++++++ 1605084639286+B1Handler:6 1605084639286+A1Handler:2 菱形模式 菱形模式其实就是并行和串行的结合体，先并行执行，再串行执行
disruptor.handleEventsWith(new A1Handler(), new A2Handler()).then(new B1Handler()); 结果示例 B1Handler要等A1Handler和A2Handler全部执行完，它才会执行。
++++++++++ 1605085280283+A1Handler:1 1605085280283+A2Handler:3 1605085280287+B1Handler:5 ++++++++++ 1605085281283+A1Handler:2 1605085281283+A2Handler:4 1605085281283+B1Handler:6 链式模式 链式模式也是并行和串行的结合，并行模式执行串行模式
disruptor.handleEventsWith(new A1Handler()).then(new A2Handler()); disruptor.handleEventsWith(new B1Handler()).then(new B2Handler()); 结果示例 ++++++++++ 1605085843558+B1Handler:5 1605085843558+A1Handler:1 1605085843563+A2Handler:3 1605085843563+B2Handler:7 ++++++++++ 1605085844558+B1Handler:6 1605085844558+A1Handler:2 1605085844558+B2Handler:8 1605085844559+A2Handler:4 总结 所有的模式都可以根据并行和串行来衍生出各种模式，玩法多种多样。</description></item><item><title>Disruptor-实例化方法</title><link>https://greycode.top/posts/b3025291-ae52-4d26-a70c-66a79bda07d7/</link><pubDate>Mon, 01 Mar 2021 09:58:05 +0000</pubDate><guid>https://greycode.top/posts/b3025291-ae52-4d26-a70c-66a79bda07d7/</guid><description>创建一个事件实体 public class LongEvent{ private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } 创建一个事件实体工厂 public class LongEventFactory implements EventFactory&amp;lt;LongEvent&amp;gt; { public LongEvent newInstance() { return new LongEvent(); } } 创建两个事件处理类 /** * EventHandler&amp;lt;LongEvent&amp;gt; 是没有池化的实现方式,每个消费者中只有一个示例 * WorkHandler&amp;lt;LongEvent&amp;gt; 是池化的实现方式，每个消费者中可以以类似线程池的方式去执行这个事件 * 实际根据业务场景 实现其中一个接口就可以 */ public class A1Handler implements EventHandler&amp;lt;LongEvent&amp;gt; , WorkHandler&amp;lt;LongEvent&amp;gt; { public void onEvent(LongEvent longEvent, long l, boolean b) throws Exception { long id = longEvent.</description></item><item><title>Disruptor-快速开始</title><link>https://greycode.top/posts/a552f7f0-4cbe-4628-8fcf-02f8b8730b56/</link><pubDate>Mon, 01 Mar 2021 09:58:03 +0000</pubDate><guid>https://greycode.top/posts/a552f7f0-4cbe-4628-8fcf-02f8b8730b56/</guid><description>创建一个事件实体 public class LongEvent{ private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } 创建一个事件实体工厂 public class LongEventFactory implements EventFactory&amp;lt;LongEvent&amp;gt; { public LongEvent newInstance() { return new LongEvent(); } } 创建两个事件处理类 /** * EventHandler&amp;lt;LongEvent&amp;gt; 是没有池化的实现方式,每个消费者中只有一个示例 * WorkHandler&amp;lt;LongEvent&amp;gt; 是池化的实现方式，每个消费者中可以以类似线程池的方式去执行这个事件 * 实际根据业务场景 实现其中一个接口就可以 */ public class A1Handler implements EventHandler&amp;lt;LongEvent&amp;gt; , WorkHandler&amp;lt;LongEvent&amp;gt; { public void onEvent(LongEvent longEvent, long l, boolean b) throws Exception { long id = longEvent.</description></item><item><title>Disruptor-生产者发布方式</title><link>https://greycode.top/posts/926f33f0-651d-471a-ad0c-b632fcce8c0f/</link><pubDate>Mon, 01 Mar 2021 09:57:58 +0000</pubDate><guid>https://greycode.top/posts/926f33f0-651d-471a-ad0c-b632fcce8c0f/</guid><description>旧版本API发布方式 import com.lmax.disruptor.RingBuffer; public class LongEventProducer{ private final RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer; public LongEventProducer(RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer){ this.ringBuffer = ringBuffer; } public void onData(ByteBuffer bb){ long sequence = ringBuffer.next(); // Grab the next sequence try{ LongEvent event = ringBuffer.get(sequence); // Get the entry in the Disruptor // for the sequence event.set(bb.getLong(0)); // Fill with data } finally{ ringBuffer.publish(sequence); } } } 使用 RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer = disruptor.start(); LongEventProducer producer = new LongEventProducer(ringBuffer); ByteBuffer bb = ByteBuffer.</description></item><item><title>Git常用命令</title><link>https://greycode.top/posts/git-commend-note/</link><pubDate>Wed, 16 Sep 2020 15:16:56 +0000</pubDate><guid>https://greycode.top/posts/git-commend-note/</guid><description>Git简介 Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。
git对于很多人来说,真的是又爱又恨,用的好可以提示开发效率;用不好,解决各种冲突就要累的你半死
git结构 网上有 我就不画了
workspace 相当于就是我们的本地电脑上的文件
Index 缓存区
Repository 本地仓库
Remote 远程仓库(github/gitlab/gitee)
git命令 git官方提供的命令多达几百个,可是我们日常却用不到这么多
所以我就整理了一下日常使用的命令
现在关注微信公招:灰色Code
回复关键字:git
就可以获取思维导图高清图片及导图源地址</description></item><item><title>浅谈MDC</title><link>https://greycode.top/posts/mdc-test/</link><pubDate>Wed, 16 Sep 2020 15:10:47 +0000</pubDate><guid>https://greycode.top/posts/mdc-test/</guid><description>MDC是什么？ MDC 全拼 Mapped Diagnostic Contexts，是SLF4J类日志系统中实现分布式多线程日志数据传递的重要工具；可利用MDC将一些运行时的上下文数据打印出来。目前只有log4j和logback提供原生的MDC支持；
简单使用 MDC里面提供的都是静态方法，所以可以直接调用
// 设置一个key MDC.put(&amp;#34;name&amp;#34;,&amp;#34;灰色Code&amp;#34;); // 获取一个key的值 MDC.get(&amp;#34;name&amp;#34;); // 删除一个key MDC.remove(&amp;#34;name&amp;#34;); // 清空MDC里的内容 MDC.clear(); // 获取上下文中的map Map&amp;lt;String,String&amp;gt; map = MDC.getCopyOfContextMap(); // 设置MDC的map MDC.setContextMap(map); 源码解析 MDC 通过阅读MDC的源码可以发现，它其实是调用了MDCAdapter的接口来实现的
MDCAdapter MDCAdapter接口有三个实现类，而MDC是调用了LogbackMDCAdapter里的方法(在MDC里有一个静态代码块，实例化了这个对象)
LogbackMDCAdapter 而LogbackMDCAdapter主要是用ThreadLocal在线程上下文中维护一个HashMap来实现的
总结 怎么样,实现原理是不是很简单，就这么短短几行代码，就实现了听起来很高大上的MDC。
所以简单来说，MDC就是利用ThreadLocal在线程中维护了一个HashMap，利用HashMap来存放数据</description></item><item><title>JDKproxy和Cglib初探</title><link>https://greycode.top/posts/jdkproxy-cglib/</link><pubDate>Wed, 16 Sep 2020 15:09:47 +0000</pubDate><guid>https://greycode.top/posts/jdkproxy-cglib/</guid><description>JDKproxy和Cglib初探 简介 在Java中，动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地制定一组接口及委托类对象，便能动态地获得代理类。动态代理在Java中有着广泛的应用，比如Spring AOP，Hibernate数据查询、测试框架的后端mock、RPC，Java注解对象获取等。
JDK原生动态代理(JDKProxy) JDKProxy只能对实现了接口的类生成代理，而不能针对普通类 。JDKProxy原生的反射API进行操作，在生成类上比较高效。
使用 interface TestInterface{ void test(); } class TestClass implements TestInterface{ @Override public void test(){ System.out.println(&amp;#34;JDK动态代理&amp;#34;); } } //主方法 public class JDKProxy { public static void main(String[] args) { TestClass testClass=new TestClass(); ProxyHandle proxyHandle=new ProxyHandle(testClass); //使用接口 TestInterface testClass1= (TestInterface) Proxy.newProxyInstance( testClass.getClass().getClassLoader(), testClass.getClass().getInterfaces(),proxyHandle); testClass1.test(); System.out.println(&amp;#34;代理类名称：&amp;#34;+testClass1.getClass()); } } //代理 class ProxyHandle implements InvocationHandler{ private Object originaObj; public ProxyHandle(Object o){ this.originaObj=o; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.</description></item><item><title>Java包装类缓存机制</title><link>https://greycode.top/posts/java-base-data-pack/</link><pubDate>Wed, 16 Sep 2020 15:08:18 +0000</pubDate><guid>https://greycode.top/posts/java-base-data-pack/</guid><description>面试题 首先,来看一道常见的面试题,下面代码运行后会输出什么?
上面代码运行后,最终会输出false和true;为什么会这样呢?
按道理来说,在Java中==是比较两个对象的地址,上面代码中i3和i4是两个不同的对象,理应也应该返回是false,怎么返回是true呢?让我们慢慢往下看
Integer的缓存机制 让我们来看看他的源代码.
当执行Integer i=128;这个语句时,Java会调用valueOf(int i)方法,然后自动装箱的方式,让其变成Integer i=new Integer(128),具体源码如下:
public static Integer valueOf(int i) { if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; //装箱 return new Integer(i); } 从上面的源码中可以看到,在装箱之前会执行一个if语句,这个if语句就是判断传入的值是否在缓存内,如果在缓存内,就直接返回缓存内的值,如果不在缓存内,就装箱,在堆内创建一个新空间来存放.
//Integer包装类缓存源码 private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.</description></item><item><title>创建线程的3种方式</title><link>https://greycode.top/posts/create-thread-3/</link><pubDate>Mon, 22 Jun 2020 16:29:38 +0000</pubDate><guid>https://greycode.top/posts/create-thread-3/</guid><description>Java线程状态变迁图 构造一个线程 在线程执行start()方法之前,首先需要初始化(NEW)一个线程,初始化的时候,可以设置线程名称,线程所属的线程组、线程优先级、是否是Daemon线程等信息。
Thread常见参数及设置方法:
//线程是否是守护线程 默认false private boolean daemon = false; //设置方法 Thread thread=new Thread(); thread.setDaemon(true); //线程名字 默认&amp;#34;Thread-&amp;#34; + nextThreadNum() private volatile String name; //设置方法 Thread thread=new Thread(); thread.setName(&amp;#34;myThread&amp;#34;); //不能设置为null,会报异常 //线程优先级 是否起作用和操作系统及虚拟机版本相关 private int priority; //设置方法 范围:1-10 默认5 myThread.setPriority(1); Thread源码构造方法 在Thread源码中,一共提供了9种构造方法.
从这些构造方法中,大致可以分为有Runnable构造参数的,和无Runnable构造参数两大类,无Runnable构造参数的就需要去继承Thread来重写run()方法(注:Thread也实现了Runnable接口),有Runnable构造参数的,就实现Runnable接口的run方法,然后通过构造参数,把实现Runnable接口的实例传入Thread.
无返回值的线程 可以看到,通过集成Thread类和实现Runnable接口的run()方法返回值都是void.这类是没有返回值的
方法一:继承Thread类创建一个线程 //继承Thread类,重写run方法 class MyThread extends Thread{ @Override public void run() { System.out.println(&amp;#34;继承Thread,重写run方法&amp;#34;); } } public class ThreadTest{ public static void main(String[] args){ MyThread myThread=new MyThread(); myThread.start(); } } 方法二:实现Runnable接口创建线程 //实现Runnable接口的run方法,然后以构造参数的形式设置Thread的target class MyRun implements Runnable{ @Override public void run() { System.</description></item><item><title>Java四种引用方法使用和对比</title><link>https://greycode.top/posts/jvm-object-four-quote/</link><pubDate>Fri, 29 May 2020 10:22:07 +0000</pubDate><guid>https://greycode.top/posts/jvm-object-four-quote/</guid><description>
强引用（Strongly Reference） 无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
回收时机:强引用关系不存在时
Object obj=new Object(); 软引用（Soft Reference） 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
回收时机:发送内存溢出异常前
//软引用 SoftReference&amp;lt;Object&amp;gt; srf = new SoftReference&amp;lt;Object&amp;gt;(new Object()); //or Object obj=new Object(); SoftReference&amp;lt;Object&amp;gt; srf = new SoftReference&amp;lt;Object&amp;gt;(obj); obj=null; //这种方法一定要设置obj为null,否则这个对象除了软引用可达外,还有原来强引用也可达 弱引用（Weak Reference） 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
回收时机:下一次垃圾回收时
//弱引用 WeakReference&amp;lt;Object&amp;gt; wrf = new WeakReference&amp;lt;Object&amp;gt;(new Object()); //or Object obj=new Object(); WeakReference&amp;lt;Object&amp;gt; wrf = new WeakReference&amp;lt;Object&amp;gt;(new Object()); obj=null; 虚引用（Phantom Reference） 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
回收时机:随时
//虚引用 PhantomReference&amp;lt;Object&amp;gt; prf = new PhantomReference&amp;lt;Object&amp;gt;(new Object(), new ReferenceQueue&amp;lt;&amp;gt;()); //or Object obj=new Object(); PhantomReference&amp;lt;Object&amp;gt; prf = new PhantomReference&amp;lt;Object&amp;gt;(obj, new ReferenceQueue&amp;lt;&amp;gt;()); obj=null;</description></item><item><title>【源码解析】你真的了解ArrayDeque嘛？</title><link>https://greycode.top/posts/java-arraydeque-source-1/</link><pubDate>Wed, 08 Jan 2020 14:00:51 +0000</pubDate><guid>https://greycode.top/posts/java-arraydeque-source-1/</guid><description/></item><item><title>【源码解析】想了解LinkedList？看这篇文章就对了</title><link>https://greycode.top/posts/java-linkedlist-source-1/</link><pubDate>Sun, 05 Jan 2020 00:21:43 +0000</pubDate><guid>https://greycode.top/posts/java-linkedlist-source-1/</guid><description/></item><item><title>【源码解析】扒开ArrayList的外衣</title><link>https://greycode.top/posts/java-arraylist-source-1/</link><pubDate>Fri, 03 Jan 2020 19:13:31 +0000</pubDate><guid>https://greycode.top/posts/java-arraylist-source-1/</guid><description>积千里跬步，汇万里江河；每天进步一点点，终有一天将成大佬。
本文内容 当然ArrayList里的方法不止这些，本文主要讲一些常用的方法
方法变量 Arraylist里的方法变量主要有以下几个
构造方法 有参构造 传入数组的大小 代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(5); 源码解析 传入一个list对象 其实这个就相当于把传入的list对象里的数据复制到新的ArrayList对象
代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&amp;#34;z&amp;#34;,&amp;#34;m&amp;#34;,&amp;#34;h&amp;#34;)); 这里用来Arrays工具类里的asList方法，它的源码里是直接返回一个List，有兴趣的可以去看看，这里就不介绍了
源码解析 无参构造 这个比较简单，直接赋值一个空数组
代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(); 源码解析 add方法 add一般常用的有两个方法，一个就是add(E e)在尾部添加数据，一个就是add(int index,E element)在指定位置插入元素
add(E e) 这个是Arrayist的主要方法，平时用的也是最多的方法之一，所以源码比较复杂，比较长
代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(); list.add(&amp;#34;灰灰HK&amp;#34;); 源码解析 ensureCapacityInternal(int minCapacity)确保数组容量充足 calculateCapacity(Object[] elementData, int minCapacity) 再回到ensureExplicitCapacity(int minCapacity)这个方法，这个方法先修改次数加1，然后判断size+1是不是比当前的数组容量大，如果比当前的数组容量大，则进行扩容操作，扩大容量为原数组的1.5倍 比如第二次调用add方法，此时size+1=2, elementData.length=10,为什么等于10呢？因为第一次默认把数组容量从0扩大到了10,这时size+1比elementData.length小，就不会进行扩容操作
grow(int minCapacity)扩容 这里调用Arrays.copyOf()方法进行复制操作，当进一步深入这个方法时，发现是由System.arraycopy()这个方法实现复制功能的，这个方法由native关键字修饰，表示不是由Java语言实现的，一般是c/cpp实现
小结 到这里，add的方法流程就走完了，其核心步骤：
每次添加元素时判断数组容量是否充足
第一次添加元素，把数组容量扩容到10
扩容时，除第一次，以后的每次扩容为原大小的1.5倍
扩容后调用System.arraycopy()方法把原数组的元素复制到扩容后的新数组
add(int index, E element) 该方法为在指定位置插入元素，该位置及后面所有元素后移
代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(); list.</description></item><item><title>【图】用图片告诉你Java中的位运算</title><link>https://greycode.top/posts/java-base-wei/</link><pubDate>Mon, 30 Dec 2019 22:17:30 +0000</pubDate><guid>https://greycode.top/posts/java-base-wei/</guid><description>前言 ​ 虽然位运算在实际开发中并不常用,但是在各种算法中却常常见到它们的身影.因为是直接操作二进制的,所以机器执行起来就快很多,所以尽管实际业务中不常用,但如果你不想只做个码农,这个基础还是要掌握的;
讲位操作之前,就必须要知道原码、反码、补码
其中正数的原码=反码=补码
原码、反码、补码 在机器的内存中,一个负数的表示是这个负数的绝对值取原码,再取反码,再加一,最后出现的就是这个负数在内存中的表示的二进制数值
比如说-9在内存中的二进制码,这里用8位表示:
最后-9在内存中的二进制值为11110111
在二进制中,最高位为符号位,0代表正,1代表负
位运算 左移和右移 在Java中的int类型有4字节,一个字节有8位,所以这边用32位表示一个数
负数的左移和右移 这边负数表示是在内存中表示的二进制值
右移时:最高位补符号位1
左移时:末尾补0
正数的左移和右移 右移时:最高位补符号位0
左移时:末尾补0
无符号右移 无论是正数还是负数,右移最高位一律补0
&amp;amp;(位与) 当相对应的位都为1时,等于1,否则等于0
为了方便表示,接下来全部都用8位表示一个数
|(位或) 当相对应的位有一个为1时,等于1,否则等于0
^(异或) 当相对应的位不同时,等于1,相同时等于0
~(取反) 1等于0,0等于1
总结 含义 运算符 说明 左移 &amp;laquo; 末尾补0 右移 &amp;gt;&amp;gt; 负数:最高位补符号位1 正数:最高位补符号位0 无符号右移 &amp;gt;&amp;raquo; 无论是正数还是负数,右移最高位一律补0 &amp;amp;(位与) &amp;amp; 当相对应的位都为1时,等于1,否则等于0 |(位或) | 当相对应的位有一个为1时,等于1,否则等于0 ^(异或) ^ 当相对应的位 不同时,等于1 相同时,等于0 ~(取反) ~ 1等于0,0等于1 最后有个小技巧,向左位移几位就是乘以2的几次方,比如9向左移n位,就是
$$ 9向左移n位=9*2^n $$
向右移几位就是除以2的几次方然后向下取整,比如9向右移动n位,就是
$$ 9向右移n位=⌊9/2^n⌋ $$
注:⌊⌋是数学符号向下取整,例如:2.25向下取整是2; -2.25向下取整是-3; 具体的话可以看看这篇文章向上取整与向下取整函数;该技巧不适用无符号右移</description></item><item><title>Java8 Stream方法大全</title><link>https://greycode.top/posts/java-8-stream-method/</link><pubDate>Tue, 10 Dec 2019 09:53:34 +0000</pubDate><guid>https://greycode.top/posts/java-8-stream-method/</guid><description/></item><item><title>Java数组的几种初始化方式</title><link>https://greycode.top/posts/java-array-init/</link><pubDate>Mon, 09 Dec 2019 10:22:12 +0000</pubDate><guid>https://greycode.top/posts/java-array-init/</guid><description>一维数组 初始化容量 /** * 定义容量为5,初始值为0的int一维数组 */ int array[]=new int[5]; int[] array2=new int[5]; 初始化值 /** * 初始化一维容量为5的一维数组的值 */ int[] array10={1,2,3,4,5}; int aray12[]={1,2,3,4,5}; 二维数组 二维数组初始化时必须要声明行数,列数可随意
初始化容量 声明了列数的 /** * 初始化一个5行5列的二维数组 */ int[][] array3=new int[5][5]; int []array4[]=new int[5][5]; int array5[][]=new int[5][5]; 未声明列数的 此种方法初始化后如果要赋值的话要new一个数组,如果按照常规的方法赋值然后取值会报空指针异常
/** * 初始化一个5行空列的二维数组 */ int[][] array6=new int[5][]; int []arra7[]=new int[5][]; int array8[][]=new int[5][]; /** * 赋值方法 */ int[][] array6=new int[5][]; array6[0]=new int[]{1,2,3}; System.out.println(array6[0][0]); //输出:1 初始化值 /** * 初始化并赋值一个2行3列的二维数组 */ int[][] array13={{1,2,3},{4,5,6}}; int []array14[]={{1,2,3},{4,5,6}}; int array15[][]={{1,2,3},{4,5,6}}; 总结 ​ 其他像什么三维数组,多维数组初始化的方式都差不多,可以自己在IDE工具中试一下;</description></item><item><title>Nacos报[NACOS HTTP-POST]</title><link>https://greycode.top/posts/nacos-post-error/</link><pubDate>Thu, 14 Nov 2019 23:50:58 +0000</pubDate><guid>https://greycode.top/posts/nacos-post-error/</guid><description>问题 由于项目使用阿里的Nacos来管理项目的配置文件，今天所有使用Nacos的项目的日志都报[NACOS HTTP-POST] The maximum number of tolerable server reconnection errors has been reached这个错误。
解决方法 查阅资料后说是连接超过了最大重试次数。Nacos有个maxRetry这个配置参数，默认是3;可是和SpringCloud整合后在application文件中找不到这个参数，只好另寻方法；
由于项目都是Docker容器化的，先前出现过连接不到Nacos的问题,于是就查看了各个Docker容器的IP。
修正Nacos的地址 查阅后发现，是因为同事吧服务器重启了一遍，导致Docker服务也重启了，然后Docker容器里的IP全部都变了。因为同一台服务器上我们各个容器间的访问是通过Docker容器内部IP的，也就是172.16.x.x这个IP段。所以导致访问不到报错。
spring.cloud.nacos.config.server-addr=172.16.X.X //更改到最新nacos的地址</description></item><item><title>Java的==和equals</title><link>https://greycode.top/posts/java-equals/</link><pubDate>Tue, 20 Aug 2019 19:22:50 +0000</pubDate><guid>https://greycode.top/posts/java-equals/</guid><description>在平常工作和学习中，我们一般用==和equals来比较两个对象或数据是否相等。但是什么时候用equals，什么时候用==一直都不怎么清楚，今天整理了下；
首先看看Java的栈空间和堆空间的地址引用 ==的说明 在Java中，==对比的是两个对象在空间里的地址是否一致,比如上图的s2==s3返回的是false，s5==s6返回的是为true。话不多说，上代码。
public class demo2 { public static void main(String[] args) { String s1=new String(&amp;#34;t1&amp;#34;); String s2=new String(&amp;#34;t2&amp;#34;); String s3=new String(&amp;#34;t2&amp;#34;); String s4=new String(&amp;#34;t3&amp;#34;); String s5=&amp;#34;t3&amp;#34;; String s6=&amp;#34;t3&amp;#34;; System.out.println(&amp;#34;s2==s3:&amp;#34;+(s2==s3)); System.out.println(&amp;#34;s5==s6:&amp;#34;+(s5==s6)); } } 结果： 这是因为==比的是在空间里的地址，s2和s3在堆里面是两个不同的对象，所以地址也不同，自然返回就是false。s5和s6是Java的基础数据类型，指向的是常量池里同一个引用，所以地址也相同，返回的就是true。
equals的说明 每个Object里的equals都不一样，我们看看String里的源码
public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.</description></item><item><title>Java中String判断为空的4大方法比较</title><link>https://greycode.top/posts/java-isnull-four/</link><pubDate>Tue, 20 Aug 2019 18:59:15 +0000</pubDate><guid>https://greycode.top/posts/java-isnull-four/</guid><description>一.四大方法 public class demo1 { public static void main(String[] args) { String a=&amp;#34;&amp;#34;; String a2=new String(); System.out.println(a==&amp;#34;&amp;#34;); System.out.println(a2==&amp;#34;&amp;#34;); System.out.println(&amp;#34;------------------------------&amp;#34;); System.out.println(a==null); System.out.println(a2==null); System.out.println(&amp;#34;------------------------------&amp;#34;); System.out.println(a.length()&amp;lt;=0); System.out.println(a2.length()&amp;lt;=0); System.out.println(&amp;#34;------------------------------&amp;#34;); System.out.println(a.isEmpty()); System.out.println(a2.isEmpty()); System.out.println(&amp;#34;------------------------------&amp;#34;); } } 二.输出结果 可以看到用&amp;quot;==&amp;ldquo;判断的那组出现了不一致的情况</description></item><item><title>Base64影响泰文字段取值问题</title><link>https://greycode.top/posts/problem-java-base64/</link><pubDate>Wed, 14 Aug 2019 10:39:23 +0000</pubDate><guid>https://greycode.top/posts/problem-java-base64/</guid><description>今天在工作中，图片要用base64上传，上传数据中还有泰文，然后和前端app联调时发现他们传的泰文这边竟然没存到库里，怀疑是app没有传值过来，于是一番操作 查看日志 what,日志里面竟然有他们传过来的泰文的值
对比ios和android的数据 发现日志里的数据都是一样的，但是android上传的数据全部传入了mysql数据库，ios的除了泰文，其他的也都传到了库里
确定问题 最后对比发现，android的泰文字段三放在base64字段前面的然后传上来的，ios是放在base64字段后面传上来的，怀疑问题在此处
修复bug 于是叫ios也和android一样，把上传字段的顺序调整了以下，把泰文的字段放在base64字段前面，然后上传。改了之后试了以下，，竟然解决了，2222333333
总结：暂时不知道具体什么原因，有可能是因为base64数据太长了，影响到泰文的字段存储了。</description></item></channel></rss>