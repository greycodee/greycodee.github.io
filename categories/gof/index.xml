<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GOF on Greycode's Blog</title><link>https://blog.greycode.top/categories/gof/</link><description>Recent content in GOF on Greycode's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 27 Dec 2019 06:50:31 +0000</lastBuildDate><atom:link href="https://blog.greycode.top/categories/gof/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式之建造者模式【用好玩的故事讲清楚设计模式】</title><link>https://blog.greycode.top/posts/gof-builder/</link><pubDate>Fri, 27 Dec 2019 06:50:31 +0000</pubDate><guid>https://blog.greycode.top/posts/gof-builder/</guid><description>积千里跬步,汇万里江河;每天进步一点点,终有一天将成大佬
所有源代码都在这:https://github.com/z573419235/GofDemo
各位大佬记得点个星星哦
前言 建造者模式用于实例化一个比较复杂的实体类,当你实例化一个类时,它的构造参数比较多时,就可以用建造者模式来简化实例化过程;前几篇工厂模式的文章我们说道买车,那只是简单的区工厂买车,我们不关系工厂是怎么造出来的.可是实际工厂造一辆车需要有方向盘、发动机、车架、轮胎等部件,而且不同品牌的车的部件都是不同的,部件虽然不同,但是造车的方式基本都是差不多的步骤,这时候就可以用建造者模式来造一辆车了;
建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成
土豪朋友开车厂 土豪朋友上次买了车之后,发现造车卖还挺赚钱,于是决定涉足汽车领域,真是很有商业头脑啊,不愧是我的玉树临风,疯言疯语,语速惊人,人模狗样的土豪朋友啊. 一天,前去向他讨教汽车的知识,他给我讲了汽车的大致构成:
/** * 汽车 产品类 定义汽车的构成 * */ @Data public class Car { /** * 方向盘 * */ private String steering; /** * 发动机 * */ private String engine; /** * 车架 * */ private String frame; /** * 轮胎 * */ private String tire; /** * 展示一下汽车配置 * */ public String show() { return &amp;#34;{&amp;#34; + &amp;#34;steering=&amp;#39;&amp;#34; + steering + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, engine=&amp;#39;&amp;#34; + engine + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, frame=&amp;#39;&amp;#34; + frame + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, tire=&amp;#39;&amp;#34; + tire + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } 果真是大致啊,忽悠我不懂车是吧,就给我讲4个东西,这谁不知道啊,哼!</description></item><item><title>一个故事一个模式-原型模式</title><link>https://blog.greycode.top/posts/gof-prototype/</link><pubDate>Wed, 25 Dec 2019 23:34:48 +0000</pubDate><guid>https://blog.greycode.top/posts/gof-prototype/</guid><description>积千里跬步,汇万里江河;每天进步一点点,终有一天将成大佬
所有源代码都在这:https://github.com/z573419235/GofDemo
各位大佬记得点个星星哦
前言 前几天生病了,每天头昏脑胀的,诶,生病的时候才知道身体健康的重要性,以后还是要加强锻炼,身体是革命的本钱; 隔了差不多有五六天没写日志了,罪过罪过;好了,今天要说的是原型模式,原型模式在`Java`中核心秘密就是`clone`这个方法,通过重新`Object`中的`clone`方法.来达到原型模式;而要重新`clone`方法就必须要实现`Cloneable`这个接口,不实现这个接口的话就会报`java.lang.CloneNotSupportedException`异常; 我是鸣人 鸣人最喜欢的就是吃拉面,就算是上课的时候也是心心念念的想着一乐大叔的拉面 先来看看鸣人的原型实体类:
/** * @author zheng * * 我是鸣人实体类 */ @Data public class Naruto implements Cloneable{ /** * 姓名 * */ private String name=&amp;#34;鸣人&amp;#34;; /** * 年龄 * */ private int age=13; /** * 任务 * */ private String task; /** *爱好 * */ private ArrayList&amp;lt;String&amp;gt; hobby=new ArrayList&amp;lt;&amp;gt;(); /** * 构造方法 * */ public Naruto(){ this.hobby.add(&amp;#34;吃拉面&amp;#34;); this.hobby.add(&amp;#34;泡温泉&amp;#34;); } /** * 重写Object类的clone方法 * */ @Override public Naruto clone(){ Naruto naruto=null; try { naruto=(Naruto)super.</description></item><item><title>设计模式系列-模板方法模式</title><link>https://blog.greycode.top/posts/gof-taemplate-method/</link><pubDate>Fri, 20 Dec 2019 00:04:28 +0000</pubDate><guid>https://blog.greycode.top/posts/gof-taemplate-method/</guid><description>积千里跬步，汇万里江河．每天进步一点点，终有一天将成大佬
文前常规发言 模板方法的设计符合迪米特法则，也就是最少知道原则，他通过对一些重复方法的封装，减少类之间的耦合，让调用者也更省心，原来要调两三个方法才能实现的功能，现在调一个就可以了；就像我们伟大的祖国，现在也在推行这种模式呢．以前区办一些证明什么的，要跑三四个地方，还要保证这三四个地方都正常帮你办理，如果其中一个地方没办理，那么整个流程就都作废了．现在好了，提倡最多跑一次，只要去一个地方办一次手续就可以了，你只要知道这个地方能办好就行，其他的就不用烦心了；
阿狗卖电脑 阿狗是一个三十五岁没了头发的年轻小伙，当问及为什么没了头发，阿狗摸摸头，眼里充满了悔恨的泪水；要不是小时候没听大人的话，长大了也不至于做程序员啊－－－阿狗唉声叹气的说道．听到这里，我仿佛已经知道了答案．当我问他为什么现在改行卖电脑了，他说外面的世界很大，想趁年轻，多闯闯（实则是被公司裁员，被迫来卖电脑了）；
看看他的电脑店里都有什么
/** * 阿狗电脑店 * */ abstract class AGouShop { /** *显卡 * */ abstract void xianKa(); /** *cpu * */ abstract void cpu(); /** *电源 * */ abstract void dianYuan(); /** *主板 * */ abstract void zhuBan(); /** *硬盘 * */ abstract void yingPan(); /** *内存条 * */ abstract void neiCun(); /** *机箱 * */ abstract void jiXiang(); } 还不错，该有的都有了．当我们正在店里逛着时，来了两个顾客，阿猫和大牛，他们都来到阿狗店电脑店，挑选的电脑配件，准备组装电脑．
看看阿猫：
在看看大牛的：
再看看他们怎么组装的吧：</description></item><item><title>设计模式系列-抽象工厂模式</title><link>https://blog.greycode.top/posts/gof-abstract-factory/</link><pubDate>Mon, 16 Dec 2019 21:17:23 +0000</pubDate><guid>https://blog.greycode.top/posts/gof-abstract-factory/</guid><description>积千里跬步，汇万里江河；每天进步一点点，终有一天将成大佬
突然开始的正文 紧接着上一章的工厂方法模式，其实抽象工厂的概念和工厂方法的概念都是差不多的，抽象工厂模式是对工厂方法模式的更高级，比如上次我们说的那个汽车工厂总部类AllCarFactory，本来他只定义了生产汽车这个方法，下面的各个品牌的汽车厂也只能生产这个汽车，现在由于市场需求，需要生产摩托车，然后AllCarFactory定义了一个生产摩托车的接口，这样这个接口下面的汽车厂就可以生产摩托车了．就在这时他们的生产模式也从工厂方法模式升级到了抽象工厂模式；
话不多说，看两个模式的类图你就明白了：
原本的工厂方法模式类图： 升级后的抽象工厂模式： 可以看到，抽象工厂只是比工厂方法模式多生产了一个产品，当抽象工厂模式的产品减到只有一个的时候，他就又回到了工厂方法模式；
好色的朋友买车了 上次我朋友看见我买车之后，得知是个小姐姐带我区买车的，于是他叫我联系了下那个小姐姐，说他也要买车，点名要叫小姐姐带他去，由于资金有限，他只卖了奔驰和五菱系列的产品，没有买莱斯莱斯的；看看他是怎么买的吧：
可以看到，由于要在一个工厂买两个东西，他是先找到了工厂，然后再一件一件的从工厂买．我们上次是一个工厂买一件东西，所以是直接去工厂买的；
措不及防的结束了 不是我不想讲，而是抽象工厂就是这样的东西．从上面可以看出，抽象工厂每当增加一个产品时，后面相关的的品牌工厂也全部要实现他这个产品，这就违背了开闭原则了．所以，在实际设计中，一个业务场景是稳定的,用抽象工厂是比较好的，因为一次设计,后面就不用改了,这样就不会违反开闭原则了．但是如果一个业务场景是稳定的是不稳定的，那么就不适合使用这个模式了，因为后期需要多次修改，这就违反了开闭原则，同时也及其难维护，应为你不知道修改了代码，到底会影响哪些功能；</description></item><item><title>设计模式系列-工厂模式</title><link>https://blog.greycode.top/posts/gof-factory-method/</link><pubDate>Sun, 15 Dec 2019 17:25:00 +0000</pubDate><guid>https://blog.greycode.top/posts/gof-factory-method/</guid><description>积千里跬步，汇万里江河．每天进步一点点，终有一天将成大佬
前言 工厂模式有一下三种
简单工厂模式 工厂方法模式 抽象工厂模式 其中简单工厂模式不在23中模式之中，更多的是一种编程习惯，而我们平常所说的工厂模式一般指的是工厂方法模式，抽象工厂在实际的业务开发中也用的比较少，因为它有时候违背了开闭原则．由于篇幅有限，抽象工厂本文就不讲了，以后单独讲；
简单工厂模式 简单工厂到底有多简单呢？简单到只有一个工厂，这个工厂相当于是万能工厂，你想要什么，只要和它说一声，它就会想方设法的去抱你创建，然后给你；举个买车的简单的例子：
当我要买车的时候，我选了这两种车．
/** * 创建一个汽车接口 * */ public interface Car { /** * 汽车能动 * */ void run(); } /** * 奔驰车 * */ public class Benz implements Car { @Override public void run() { System.out.println(&amp;#34;大奔开动了&amp;#34;); } } /** * 五菱神车 * */ public class Wuling implements Car { @Override public void run() { System.out.println(&amp;#34;五菱神车开动了&amp;#34;); } } 选是选好了，可是要怎么得到呢？是不是下意识的new一个出来？
//我要奔驰车 Benz　myCar=new Benz(); 如果是这样的话，就相当于自己亲手造了一辆奔驰车出来，因为是你自己new出来的嘛！！！！！</description></item><item><title>OOP程序七大原则</title><link>https://blog.greycode.top/posts/gof-oop-7-all/</link><pubDate>Sun, 15 Dec 2019 10:45:04 +0000</pubDate><guid>https://blog.greycode.top/posts/gof-oop-7-all/</guid><description>开闭原则 开闭原则相当于所有原则的祖先，主张对修改关闭，对拓展开放．
里氏替换原则 当两个类有继承关系时，子类不能修改父类的方法和变量. 里氏替换中的替换指的是：当有父类出现的地方，这个父类可以替换成子类，而且对程序没有影响，这就遵循了里氏替换原则；当替换成子类时对程序有影响，说明子类修改了父类的方法，就没有遵循里氏替换原则了；
依赖倒置原则 依赖倒置原则是对开闭原则的一个实现，也是主张对拓展开放，对修改关闭．它的核心思想是面对接口编程，不要面对具体实现编程．
这是一个遵守依赖倒置原则的UML图，原来的话当客户购买商品时,shopping这个方法要传入相应的网店进去，当要更改店铺时，就要修改Cusromer这个类里的shopping方法，而现在，只要定义一个Shop接口，所有的店铺都实现这个接口的方法，顾客类的shopping方法只要传入Shop这个接口类就可以了．然后具体实现的时候，要到哪里买，就传入哪一个网店就可以了，而不用修改Cusromer这个类的方法；
//代码来之＇C语言中文网＇ public class DIPtest { public static void main(String[] args) { Customer wang=new Customer(); System.out.println(&amp;#34;顾客购买以下商品：&amp;#34;); wang.shopping(new ShaoguanShop()); wang.shopping(new WuyuanShop()); } } //商店 interface Shop { public String sell(); //卖 } //韶关网店 class ShaoguanShop implements Shop { public String sell() { return &amp;#34;韶关土特产：香菇、木耳……&amp;#34;; } } //婺源网店 class WuyuanShop implements Shop { public String sell() { return &amp;#34;婺源土特产：绿茶、酒糟鱼……&amp;#34;; } } //顾客 class Customer { public void shopping(Shop shop) { //购物 System.</description></item><item><title>设计模式系例-单例模式</title><link>https://blog.greycode.top/posts/gof-singleton/</link><pubDate>Tue, 22 Oct 2019 21:16:37 +0000</pubDate><guid>https://blog.greycode.top/posts/gof-singleton/</guid><description>积千里跬步，汇万里江河．每天进步一点点，终有一天将成大佬
前言 网上说单例模式是所有模式中最简单的一种模式，巧的是我也这么认为。不过越简单的东西，往往坑就隐藏的越深，这边文章我会把我知道的几个坑所出来。
一.什么是单例模式 ​ 就如同他的名字一样，&amp;lsquo;单例&amp;rsquo;-就是只有一个实例。也就是说一个类在全局中最多只有一个实例存在，不能在多了，在多就不叫单例模式了。
1.白话小故事 ​ 程序员小H单身已久，每天不是对着电脑，就是抱着手机这样来维持生活。某日，坐在电脑前，突然感觉一切都索然无味。谋生想找一个对象来一起度过人生美好的每一天。
​ 于是精心打扮出门找对象，由于小H很帅，很快就找到了心仪的另一半&amp;ndash;小K。小H的心中永远只有小K一个人，而且发誓永远不会在找新对象。
小H和小K的关系就是单例模式，在小H的全局中只有一个小K对象，且无第二个，如果有第二个的话，他们之间的关系就出问题了。哈哈
2.用在哪里 ​ 单例模式一般用在对实例数量有严格要求的地方，比如数据池，线程池，缓存，session回话等等。
3.在Java中构成的条件 静态变量 静态方法 私有构造器 二.单例模式的两种形态 1.懒汉模式 线程不安全
public class Singleton { private static Singleton unsingleton; private Singleton(){} public static Singleton getInstance(){ if(unsingleton==null){ unsingleton=new Singleton(); } return unsingleton; } } 2.饿汉模式 线程安全
public class Singleton { private static Singleton unsingleton=new Singleton(); private Singleton(){} public static Singleton getInstance(){ return unsingleton; } } 调用 public class Test { public static void main(String[] args) { Singleton singleton1=Singleton.</description></item></channel></rss>