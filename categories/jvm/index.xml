<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on Greycode's Blog</title><link>https://blog.greycode.top/categories/jvm/</link><description>Recent content in JVM on Greycode's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Sep 2020 15:06:15 +0000</lastBuildDate><atom:link href="https://blog.greycode.top/categories/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>JVM运行时栈帧</title><link>https://blog.greycode.top/posts/java-jvm-stack-1/</link><pubDate>Wed, 16 Sep 2020 15:06:15 +0000</pubDate><guid>https://blog.greycode.top/posts/java-jvm-stack-1/</guid><description>在JVM中，每个线程都包含n个栈帧，每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。
栈帧的生命周期随着方法的创建而创建，随着方法的结束而销毁，无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算方法的结束。
在某条线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧称为当前栈帧，这个栈帧对应的方法称为当前方法，定义这个方法的类称为当前类。对局部变量表和操作数栈的各种操作，通常都指的是对当前栈帧的局部变量表和操作数栈所进行的操作。
**注意:**栈帧是线程本地私有的数据，不可能在一个栈帧 之中引用另外一个线程的栈帧
局部变量表 局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
存储方法 局部变量表的容量以变量槽（Variable Slot）为最小单位，一般在虚拟机中，一个Slot占用32位存储空间(这不是固定的，虚拟机可以自行改变每个槽占用空间的大小,但一般都是32位)。
Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。
eg: 在Java中，long在内存占64位，所以局部变量表用2个slot来存储
对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。
long和double的非原子性协定 在Java内存模型中，对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的**“long和double的非原子性协定”（Non-Atomic Treatment of doubleand long Variables）**。
虽然有这个协定，但是，由于局部变量表(Local Variable Table)是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。
初始值问题 我们已经知道类的字段变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。
但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值，那它是完全不能使用的。所以不要认为Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false等这样的默认值规则。
eg： // 这个方法会报： // Error:(12, 28) java: variable y might not have been initialized public class JVMTest { public static void main(String[] args) { int y; int z=3; System.out.println(y+z); } } // 这个会正常输出 3； 因为int的初始值为0 public class JVMTest { private static int y; public static void main(String[] args) { int z=3; System.</description></item><item><title>JVM类加载过程</title><link>https://blog.greycode.top/posts/java-class-load-2/</link><pubDate>Wed, 16 Sep 2020 15:04:22 +0000</pubDate><guid>https://blog.greycode.top/posts/java-class-load-2/</guid><description>加载 通过一个类的全限定名(例如：java.lang.String)来获取定义此类的二进制字节流。
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。
从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
从网络中获取，这种场景最典型的应用就是Web Applet。
运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。
由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。
从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。
验证 文件格式验证 是否以魔数0xCAFEBABE开头。 主、次版本号是否在当前Java虚拟机接受范围之内 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 ·Class文件中各个部分及文件本身是否有被删除的或附加的其他信息 &amp;hellip;&amp;hellip; 元数据验证 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 &amp;hellip;&amp;hellip; 字节码验证 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。 &amp;hellip;&amp;hellip; 符号引用验证 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当前类访问。 &amp;hellip;&amp;hellip; 准备 准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段
例子：
// 变量value在准备阶段过后的初始值为0而不是123 // 因为这时尚未开始执行任何Java方法 value赋值为123的动作要到类的初始化阶段才会被执行 public static int value = 123 解析 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程
符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。
下面红框中的都属于符号引用
直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。
初始化 参考：jvm类初始化</description></item><item><title>JVM中的双亲委派机制</title><link>https://blog.greycode.top/posts/java-class-load-1/</link><pubDate>Wed, 16 Sep 2020 15:02:34 +0000</pubDate><guid>https://blog.greycode.top/posts/java-class-load-1/</guid><description>四种类加载器 启动类加载器(Bootstrap Class Loader )：加载$JAVA_HOME/jre/lib目录下的jar包 拓展类加载器(Extension Class Loader)：加载$JAVA_HOME/jre/lib/ext目录下的jar包 应用程序类加载器(Application Class Loader)：加载ClassPath目录下的jar包 自定义类加载器(User Class Loader)：加载自定义指定目录下的jar包 双亲委派机制 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。
代码示例 当获取Bootstrap class loader的时候，输出了null，说明开发者无法通过引用操作启动类加载器
双亲委派机制的作用 每个加载器都只需要固定的加载自己管理范围内的类，这样的好处就是保证了Java体系的稳定，不然的话你自己定义一个String类的话，这样系统中就会有两个String类，如果没有双亲委派机制的话，系统就不知道到底该加载哪一个，这样系统就变得一片混乱了。
破坏双亲委派机制 双亲委派机制是Java设计者推荐给开发者们的类加载实现方式，并不是一个强制性约束的模型，所以也可以人为的破坏这个机制。
源码 源码在java.lang.ClassLoader有兴趣的可以去看下
可以看到，就这短短的几行代码，就实现了听起来很高大上的双亲委派机制，所以破坏双亲委派机制的话，就直接重写loadClass方法就可以了。</description></item><item><title>Java类初始化</title><link>https://blog.greycode.top/posts/java-class-init/</link><pubDate>Wed, 16 Sep 2020 15:01:03 +0000</pubDate><guid>https://blog.greycode.top/posts/java-class-init/</guid><description>代码结果？ 首先，我们来看看下面的代码的输出的结果，可以先试着想一下
//结果 Code 公众号 这时候有同学就会想，以前不是说类加载时，静态代码块都会加载的嘛！怎么Test1里的静态代码块没有加载呢？下面就来看看到底怎么回事
类的生命周期 了解类加载前，首先熟悉一下类的生命周期
这里注意几个点：
解析阶段可以在初始化阶段之后，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。 初始化和实例化 我相信很多人跟我刚开始一样，搞不清他们两个的区别，搞不清new一个对象，到底是对这个对象进行了初始化还是实例化呢？
初始化：是完成程序执行前的准备工作。在这个阶段，静态的（变量，方法，代码块）会被执行。同时在会开辟一块存储空间用来存放静态的数据。初始化只在类加载的时候执行一次。
实例化：是指创建一个对象的过程。这个过程中会在堆中开辟内存，将一些非静态的方法，变量存放在里面。在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。
类的初始化 《Java虚拟机规范》中并没有对加载进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。那到底什么时候能够生成这些指令呢？其实看下字节码就都明白了
使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
java.lang.invoke.MethodHandle 是JDK7中新加入类似反射功能的一个类
被动引用 对于以上这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。
像文章一开始的代码，就属于被动引用，对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
例子1&amp;ndash;对象数组 直接上图
以上代码执行后并不会输出灰色两个字，因为创建对象数组时并没有去初始化Test1这个类，而是用anewarray字节码指令去初始化了另外一个类，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类。
拓展：数组越界检查没有封装在数组元素的访问类中，而是封装在数组访问的xaload,xastore字节码指令中
例子2&amp;ndash;final修饰的静态字段 被final修饰的静态字段 此时运行该代码时，只会输出灰色Code字样，Test1并没有触发初始化阶段。这是因为在编译阶段通过常量传播优化，已经将此常量的值灰色Code直接存储在ClassLoadTest类的常量池中，所以当ClassLoadTest类调用Test1里的value时，都变成了对自身常量池的调用，和Test1类没有任何关系。
没有final修饰的静态字段
没有使用final修饰的静态变量，字节码出现了getstatic，所以触发Test1的初始化阶段，此时运行结果将会输出灰色和灰色Code</description></item><item><title>JVM4种垃圾收集算法</title><link>https://blog.greycode.top/posts/jvm-gc-alg/</link><pubDate>Fri, 29 May 2020 10:31:30 +0000</pubDate><guid>https://blog.greycode.top/posts/jvm-gc-alg/</guid><description>简介 垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。
标记-清除算法 标记过程就是对象是否属于垃圾的判定过程(采用可达分析算法GC Roots) 算法分为**“标记”和“清除”**两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。 缺点 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低； 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 标记-复制算法 标记过程就是对象是否属于垃圾的判定过程(采用可达分析算法GC Roots)
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
缺点 如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销 代价是将可用内存缩小为了原来的一半,空间浪费未免太多了一点. 标记-整理算法 标记过程就是对象是否属于垃圾的判定过程(采用可达分析算法GC Roots) 在标记-清除的算法基础上改进,后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存， 缺点 在有大量存活对象的老年代区域,移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作,而且这种对象移动操作必须全程暂停用户应用程序才能进行,比标记-清除算法停顿时间长. 分代收集算法 现代商用虚拟机基于以上算法的优缺点,根据分代收集理论,在不同的区域采用了不同的收集算法.
老年代:新生代=2:1
新生代 堆大小默认比例:Eden:S0:S1=8:1:1
采用标记-复制算法
新生代分为Eden区和Survior区,而Survior区又分为From Survior区(S0)和To Survior区(S1).此区域采用标记-复制算法.每次Minor GC/Young GC时,会把Eden区存活的对象复制到S0区,然后清空Eden区,当S0区满时,Eden区和S0区存活的对象会复制到S1区,然后S0和S0进行交换,永远保持S1为空状态,当新生代的对象经过一定次数的Minor GC还未被回收时,就会把这个对象移到老年代.
老年代 采用标记-整理法或标记-清理法
当老年代Old区域满时,会触发Full GC,同时回收新生代和老生代的所有区域.回收后诺内存还是不足时,会引发OOM异常;</description></item><item><title>JVM判断对象是否还活着的两种方法</title><link>https://blog.greycode.top/posts/jvm-object-is-alive/</link><pubDate>Fri, 29 May 2020 10:18:30 +0000</pubDate><guid>https://blog.greycode.top/posts/jvm-object-is-alive/</guid><description>引用计数法 Java虚拟机并不是通过引用计数算法来判断对象是否存活的。
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
优点 原理简单,判定效率高 缺点 不能用于复杂的环境中,比如对象的互相引用问题 可达性分析算法 Java虚拟机使用此算法来判断对象是否存活
这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GCRoots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
Java中作为GC Roots的对象:
在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
所有被同步锁（synchronized关键字）持有的对象。
反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
其他对象临时性地加入,共同构成GC Roots</description></item><item><title>JVM运行时数据区域</title><link>https://blog.greycode.top/posts/jvm-running-data-area/</link><pubDate>Tue, 26 May 2020 16:35:47 +0000</pubDate><guid>https://blog.greycode.top/posts/jvm-running-data-area/</guid><description>JVM运行时数据区域 程序计数器 线程私有
唯一一个没有规定 OutOfMemoryError 异常 的区域
它可以看作是当前线程所执行的字节码的行号指示器
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）
(摘自网上)我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？
答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）；
那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，程序计数器的内存空间是线程私有的 ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！
那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被创建；
程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域;
当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录
Java虚拟机栈 线程私有 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常；(HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的) -Xss5m: 设置5m的栈容量 每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等 本地方法栈 线程私有
与Java虚拟机栈相似
与Java虚拟机栈区别: Java虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。
Hot-Spot虚拟机直接就把本地方法栈和虚拟机栈合二为一
与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常
Java堆 线程共享 所有的Java对象实例不一定都在Java堆上分配内存 Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 Java堆是垃圾收集器(Garbage Collected)管理的内存区域 方法区 线程共享
用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作**“非堆”（Non-Heap），目的是与Java堆区分开来**。
在JDK1.6及之前,使用永久代来实现方法区.
-XX:MaxPermSize 设置永久代内存上限 -XX:PermSize 设置永久代内存 JDK1.7把字符串常量池、类的静态变量(class statics)转移到了java heap,但是永久代还是存在,主要放一些类信息(运算时常量池)等.
JDK1.8彻底移除永久代,方法区采用本地内存中实现的元空间（Meta-space）来代替,将JDK1.7中永久代的信息移到了元空间,像字符串常量池和静态变量还是存在Java Heap中
如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</description></item><item><title>JVM逃逸分析技术</title><link>https://blog.greycode.top/posts/jvm-javastack-escapeanalysis/</link><pubDate>Tue, 26 May 2020 16:02:00 +0000</pubDate><guid>https://blog.greycode.top/posts/jvm-javastack-escapeanalysis/</guid><description>逃逸分析技术的日渐成熟,促使所有的Java对象实例不一定都在Java堆上分配内存
简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。
使用 开启逃逸分析：-XX:+DoEscapeAnalysis 关闭逃逸分析：-XX:-DoEscapeAnalysis 显示分析结果：-XX:+PrintEscapeAnalysis 逃逸分析技术在 Java SE 6u23+ 开始支持,并默认设置为启用状态 逃逸程度 逸分析的基本行为就是分析对象动态作用域,从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。
方法逃逸 当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。
/*StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所 *改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线 *程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。 */ public static StringBuffer craeteStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb; } //上述代码如果想要StringBuffer sb不逃出方法，可以这样写： public static String createStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString(); } 线程逃逸 当一个对象在方法中被定义后，它可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸。 逃逸分析优化 如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化
栈上分配（Stack Allocations） 如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。 由于复杂度等原因，HotSpot中目前暂时还没有做这项优化，但一些其他的虚拟机（如Excelsior JET）使用了这项优化。 栈上分配可以支持方法逃逸，但不能支持线程逃逸。 标量替换（Scalar Replacement） 若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java中的对象就是典型的聚合量。 -XX:+EliminateAllocations 开启标量替换(jdk8默认开启) -XX:+PrintEliminateAllocations 查看标量的替换情况 如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换 假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。 标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。 同步消除（Synchronization Elimination） 也叫锁消除</description></item></channel></rss>