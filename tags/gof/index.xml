<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GOF on Greycode'Blog</title><link>https://greycode.top/tags/gof/</link><description>Recent content in GOF on Greycode'Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 15 Dec 2019 10:45:04 +0000</lastBuildDate><atom:link href="https://greycode.top/tags/gof/index.xml" rel="self" type="application/rss+xml"/><item><title>OOP程序七大原则</title><link>https://greycode.top/posts/gof-oop-7-all/</link><pubDate>Sun, 15 Dec 2019 10:45:04 +0000</pubDate><guid>https://greycode.top/posts/gof-oop-7-all/</guid><description>开闭原则 开闭原则相当于所有原则的祖先，主张对修改关闭，对拓展开放．
里氏替换原则 当两个类有继承关系时，子类不能修改父类的方法和变量. 里氏替换中的替换指的是：当有父类出现的地方，这个父类可以替换成子类，而且对程序没有影响，这就遵循了里氏替换原则；当替换成子类时对程序有影响，说明子类修改了父类的方法，就没有遵循里氏替换原则了；
依赖倒置原则 依赖倒置原则是对开闭原则的一个实现，也是主张对拓展开放，对修改关闭．它的核心思想是面对接口编程，不要面对具体实现编程．
这是一个遵守依赖倒置原则的UML图，原来的话当客户购买商品时,shopping这个方法要传入相应的网店进去，当要更改店铺时，就要修改Cusromer这个类里的shopping方法，而现在，只要定义一个Shop接口，所有的店铺都实现这个接口的方法，顾客类的shopping方法只要传入Shop这个接口类就可以了．然后具体实现的时候，要到哪里买，就传入哪一个网店就可以了，而不用修改Cusromer这个类的方法；
//代码来之＇C语言中文网＇ public class DIPtest { public static void main(String[] args) { Customer wang=new Customer(); System.out.println(&amp;#34;顾客购买以下商品：&amp;#34;); wang.shopping(new ShaoguanShop()); wang.shopping(new WuyuanShop()); } } //商店 interface Shop { public String sell(); //卖 } //韶关网店 class ShaoguanShop implements Shop { public String sell() { return &amp;#34;韶关土特产：香菇、木耳……&amp;#34;; } } //婺源网店 class WuyuanShop implements Shop { public String sell() { return &amp;#34;婺源土特产：绿茶、酒糟鱼……&amp;#34;; } } //顾客 class Customer { public void shopping(Shop shop) { //购物 System.</description></item><item><title>设计模式系例-单例模式</title><link>https://greycode.top/posts/gof-singleton/</link><pubDate>Tue, 22 Oct 2019 21:16:37 +0000</pubDate><guid>https://greycode.top/posts/gof-singleton/</guid><description>积千里跬步，汇万里江河．每天进步一点点，终有一天将成大佬
前言 网上说单例模式是所有模式中最简单的一种模式，巧的是我也这么认为。不过越简单的东西，往往坑就隐藏的越深，这边文章我会把我知道的几个坑所出来。
一.什么是单例模式 ​ 就如同他的名字一样，&amp;lsquo;单例&amp;rsquo;-就是只有一个实例。也就是说一个类在全局中最多只有一个实例存在，不能在多了，在多就不叫单例模式了。
1.白话小故事 ​ 程序员小H单身已久，每天不是对着电脑，就是抱着手机这样来维持生活。某日，坐在电脑前，突然感觉一切都索然无味。谋生想找一个对象来一起度过人生美好的每一天。
​ 于是精心打扮出门找对象，由于小H很帅，很快就找到了心仪的另一半&amp;ndash;小K。小H的心中永远只有小K一个人，而且发誓永远不会在找新对象。
小H和小K的关系就是单例模式，在小H的全局中只有一个小K对象，且无第二个，如果有第二个的话，他们之间的关系就出问题了。哈哈
2.用在哪里 ​ 单例模式一般用在对实例数量有严格要求的地方，比如数据池，线程池，缓存，session回话等等。
3.在Java中构成的条件 静态变量 静态方法 私有构造器 二.单例模式的两种形态 1.懒汉模式 线程不安全
public class Singleton { private static Singleton unsingleton; private Singleton(){} public static Singleton getInstance(){ if(unsingleton==null){ unsingleton=new Singleton(); } return unsingleton; } } 2.饿汉模式 线程安全
public class Singleton { private static Singleton unsingleton=new Singleton(); private Singleton(){} public static Singleton getInstance(){ return unsingleton; } } 调用 public class Test { public static void main(String[] args) { Singleton singleton1=Singleton.</description></item></channel></rss>