<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OOP on Hello,I am Greycode!</title><link>https://greycode.top/tags/oop/</link><description>Recent content in OOP on Hello,I am Greycode!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 15 Dec 2019 10:45:04 +0000</lastBuildDate><atom:link href="https://greycode.top/tags/oop/index.xml" rel="self" type="application/rss+xml"/><item><title>OOP程序七大原则</title><link>https://greycode.top/posts/gof-oop-7-all/</link><pubDate>Sun, 15 Dec 2019 10:45:04 +0000</pubDate><guid>https://greycode.top/posts/gof-oop-7-all/</guid><description>开闭原则 开闭原则相当于所有原则的祖先，主张对修改关闭，对拓展开放．
里氏替换原则 当两个类有继承关系时，子类不能修改父类的方法和变量. 里氏替换中的替换指的是：当有父类出现的地方，这个父类可以替换成子类，而且对程序没有影响，这就遵循了里氏替换原则；当替换成子类时对程序有影响，说明子类修改了父类的方法，就没有遵循里氏替换原则了；
依赖倒置原则 依赖倒置原则是对开闭原则的一个实现，也是主张对拓展开放，对修改关闭．它的核心思想是面对接口编程，不要面对具体实现编程．
这是一个遵守依赖倒置原则的UML图，原来的话当客户购买商品时,shopping这个方法要传入相应的网店进去，当要更改店铺时，就要修改Cusromer这个类里的shopping方法，而现在，只要定义一个Shop接口，所有的店铺都实现这个接口的方法，顾客类的shopping方法只要传入Shop这个接口类就可以了．然后具体实现的时候，要到哪里买，就传入哪一个网店就可以了，而不用修改Cusromer这个类的方法；
//代码来之＇C语言中文网＇ public class DIPtest { public static void main(String[] args) { Customer wang=new Customer(); System.out.println(&amp;#34;顾客购买以下商品：&amp;#34;); wang.shopping(new ShaoguanShop()); wang.shopping(new WuyuanShop()); } } //商店 interface Shop { public String sell(); //卖 } //韶关网店 class ShaoguanShop implements Shop { public String sell() { return &amp;#34;韶关土特产：香菇、木耳……&amp;#34;; } } //婺源网店 class WuyuanShop implements Shop { public String sell() { return &amp;#34;婺源土特产：绿茶、酒糟鱼……&amp;#34;; } } //顾客 class Customer { public void shopping(Shop shop) { //购物 System.</description></item></channel></rss>