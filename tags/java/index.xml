<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Greycode'Blog</title><link>https://greycode.top/tags/java/</link><description>Recent content in Java on Greycode'Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Aug 2021 16:40:05 +0000</lastBuildDate><atom:link href="https://greycode.top/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>用 Json-Schema 来验证你的请求参数</title><link>https://greycode.top/posts/775ff9a0ce4940ebbb45fed3fad7ab5b/</link><pubDate>Thu, 19 Aug 2021 16:40:05 +0000</pubDate><guid>https://greycode.top/posts/775ff9a0ce4940ebbb45fed3fad7ab5b/</guid><description>简介 Json-Schema 是一个用来验证、描述 Json 数据的一个标准，它可以用来验证你的请求数据是否和你定义的 Schema 是否一致。比如下面的 Json 数据中：
{ &amp;#34;name&amp;#34;:&amp;#34;greycode&amp;#34;, &amp;#34;desc&amp;#34;:&amp;#34;coder&amp;#34; } 如果不预先告诉你字段的含义，你知道 name 是什么意思吗？它到底是指人名还是一个物品的名字还是其他？desc 又是什么意思呢？
这时候，就可以用 Json-Schema 来描述它了
{ &amp;#34;$schema&amp;#34;: &amp;#34;http://json-schema.org/draft-07/schema&amp;#34;, &amp;#34;$id&amp;#34;: &amp;#34;http://example.com/example.json&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;, &amp;#34;title&amp;#34;: &amp;#34;这是一个Json数据&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;描述个人信息的数据&amp;#34;, &amp;#34;required&amp;#34;: [ &amp;#34;name&amp;#34;, &amp;#34;desc&amp;#34; ], &amp;#34;properties&amp;#34;: { &amp;#34;name&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;人的姓名&amp;#34;, }, &amp;#34;desc&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;个人简介&amp;#34;, } } } 上面我们用 Json-Schema 来描述了刚开始的 Json 数据，这样就可以清楚的知道 name 是人的姓名，desc 是个人简介，在也不用自己去猜了。</description></item><item><title>AviatorScript轻量级高性能脚本语言</title><link>https://greycode.top/posts/ca3ab1d58ea74b76a5fd69f79dd5ec79/</link><pubDate>Tue, 17 Aug 2021 16:10:53 +0000</pubDate><guid>https://greycode.top/posts/ca3ab1d58ea74b76a5fd69f79dd5ec79/</guid><description>简介 在 5.0 版本以前，它的名字是叫 Aviator ，定位一直只是一个表达式引擎，不支持 if/else 条件语句（仅有三元运算符支持 ?: ），没有内置的 for/while 循环支持（虽然你可以用 seq 库类似函数式的方式来处理集合），也没有赋值（后来在 4.0 引入），没有作用域的概念（也在 4.0 引入 lambda 函数后部分实现）等等一般语言常见的能力。在 5.0 版本后，它变成了一门脚本语言，叫：AviatorScript 。
在 5.0 ，新加了如下新特性：
大括号 { ... } 括起来的词法作用域。
let 语句用于定义局部变量。
条件语句 if/elsif/else 。
循环语句 for 和 while ，以及相应的 break 和 continue 语句支持。
return 语句用于从脚本或者函数中返回值。
fn hello() { println(&amp;quot;hello&amp;quot;); } 新的 fn 语法用于定义命名函数。
## 单行注释 注释支持</description></item><item><title>Java删除文件后电脑磁盘空间没有恢复</title><link>https://greycode.top/posts/74caaafd610241a1b8ecdb5f3bb33ee4/</link><pubDate>Sat, 03 Jul 2021 17:12:41 +0000</pubDate><guid>https://greycode.top/posts/74caaafd610241a1b8ecdb5f3bb33ee4/</guid><description>问题 当用一下命令删除文件后，电脑磁盘内存没有恢复，还是原来的大小
File folder = new File(&amp;#34;/tmp/file.mp4&amp;#34;) file.delete(); 解决 原来是 FileOutputStream 文件流忘了关了，导致一直占用这个资源。所以使用完后一定记得关文件流，使用下面的代码关闭文件流：
FileOutputStream fileOutputStream = new FileOutputStream(new File()); fileOutputStream.close(); Linux 里的文件被删除后，空间没有被释放是因为在 Linux 系统中，通过 rm 或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的(有一个进程正在使用)，那么进程将仍然可以读取该文件，磁盘空间也一直被占用。
可以使用 lsof +L1 |grep delete 命令来查看状态为 deleted 的文件，状态为 deleted 为标记被删除，其实该文件并没有从磁盘中删除，类似windows下的回收站状态。
所以当进程结束后，磁盘空间就会被释放。
参考资料 http://www.cxyzjd.com/article/su4416160/78212934 https://www.jianshu.com/p/fcb80c878d04</description></item><item><title>Java的NIO编程-Channel</title><link>https://greycode.top/posts/534d0985-a4a0-4239-ae81-d76378f64552/</link><pubDate>Mon, 01 Mar 2021 10:07:09 +0000</pubDate><guid>https://greycode.top/posts/534d0985-a4a0-4239-ae81-d76378f64552/</guid><description>0x1 主要类型 在Java中有许多NIO Channel实现，本文只选最主要的四种Channel：
FileChannel：文件通道，用于文件的数据读写 SocketChannel：套接字通道，用于Socket套接字TCP连接的数据读写。 ServerSocketChannel：服务器嵌套字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道。 DatagramChannel：数据报通道，用于UDP协议的数据读写。 0x2 使用 FileChannel 读取通道数据 首先在本地创建文件/home/zheng/channeltest，在里面编写内容：hello,world!
public class ChannelTest { public static void main(String[] args) throws IOException { // 创建输入流 File file = new File(&amp;#34;/home/zheng/channeltest&amp;#34;); FileInputStream fis = new FileInputStream(file); // 获取通道 FileChannel fileChannel = fis.getChannel(); // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int length = -1; // 读取通道数据到缓冲区 while ((length=fileChannel.</description></item><item><title>Java的NIO编程-Selector</title><link>https://greycode.top/posts/2571330c-67ef-4d4c-8717-6c96768009c7/</link><pubDate>Mon, 01 Mar 2021 10:07:07 +0000</pubDate><guid>https://greycode.top/posts/2571330c-67ef-4d4c-8717-6c96768009c7/</guid><description>0x1 监控 通道和选择器之间的关系，通过register（注册）的方式完成。调用通道的Channel.register（Selector sel, int ops）方法，可以将通道实例注册到一个选择器中。register方法有两个参数：第一个参数，指定通道注册到的选择器实例；第二个参数，指定选择器要监控的IO事件类型。
IO事件类型有：
可读：SelectionKey.OP_READ 可写：SelectionKey.OP_WRITE 连接：SelectionKey.OP_CONNECT 接收：SelectionKey.OP_ACCEPT 如果一下要监控多个事件的话可以用位或运算符来实现
int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 0x2 SelectionKey选择键 选择键的功能是很强大的。通过SelectionKey选择键，不仅仅可以获得通道的IO事件类型，比方说SelectionKey.OP_READ；还可以获得发生IO事件所在的通道；另外，也可以获得选出选择键的选择器实例。
常用方法 isAcceptable()：判断IO事件类型是否是SelectionKey.OP_ACCEPT isReadable()：判断IO事件是否是SelectionKey.OP_READ isConnectable():判断IO事件是否是SelectionKey.OP_CONNECT isWritable()：判断IO事件是否是SelectionKey.OP_WRITE 0x3 使用条件 并不是所有的Channel都可以使用Selector，判断一个通道能否被选择器监控或选择，有一个前提：判断它是否继承了抽象类SelectableChannel（可选择通道）。如果继承了SelectableChannel，则可以被选择，否则不能。
简单地说，一条通道若能被选择，必须继承SelectableChannel类。
FileChannel就没有继承SelectableChannel类，所以不能使用Selector
0x4 使用流程 使用选择器，主要有以下三步：
获取选择器实例； 将通道注册到选择器中； 轮询感兴趣的IO就绪事件（选择键集合）。 0x5 Demo 源码地址： https://github.com/GreyCode9/nio-demo/tree/main/src/io/selector</description></item><item><title>Java的NIO编程-Buffer</title><link>https://greycode.top/posts/8d2049e3-3eb1-46ed-a44b-57398964eb21/</link><pubDate>Mon, 01 Mar 2021 10:07:05 +0000</pubDate><guid>https://greycode.top/posts/8d2049e3-3eb1-46ed-a44b-57398964eb21/</guid><description>0x1 子类 Buffer是一个抽象类，所以一般使用他的子类来进行编程，常用的子类有：
ByteBuffer
IntBuffer
LongBuffer
CharBuffer
DoubleBufffer
FloatBuffer
ShortBuffer
MappedByteBuffer
0x2 属性 Buffer中有四个重要的属性，分别是：
capacity：Buffer类的capacity属性，表示内部容量的大小 position：Buffer类的position属性，表示当前的位置 limit：Buffer类的limit属性，表示读写的最大上限。 mark：暂存属性，暂时保存position的值，方便后面的重复使用position值。 0x3 方法 Buffer中几个重要的方法有：
allocate()：创建缓存区（BUffer创建缓存区不是用new，而是用这个方法来创建) put()：向缓冲器插入数据 filp()：翻转模式，将缓冲区改为读模式（缓冲区默认模式为写模式）。其实就改变了limit，position，mark属性的值。 get()：从缓冲区读取数据，从position位置开始读 rewind()：倒带（重复读取），就是将position的位置重置为0 mark()：mark()方法的作用就是将当前position的位置暂存起来，放在mark属性中。 reset()：将position重置为mark属性的位置。 clean()：清空缓存区，重置position，limit，mark属性为初始值</description></item><item><title>Java的NIO编程-Reactor模式</title><link>https://greycode.top/posts/0702ff46-16cd-4520-9d33-0794cfda4b09/</link><pubDate>Mon, 01 Mar 2021 10:07:04 +0000</pubDate><guid>https://greycode.top/posts/0702ff46-16cd-4520-9d33-0794cfda4b09/</guid><description>0x1 Reactor模型 0x1 单Reactor单线程</description></item><item><title>Disruptor-消费模式简介(池化)</title><link>https://greycode.top/posts/c16646bf-1474-42a7-a5cd-84b99669062c/</link><pubDate>Mon, 01 Mar 2021 10:02:15 +0000</pubDate><guid>https://greycode.top/posts/c16646bf-1474-42a7-a5cd-84b99669062c/</guid><description>并行模式(池化) 每个消费端有两个线程实例
disruptor.handleEventsWithWorkerPool(new A1Handler(),new A1Handler()); disruptor.handleEventsWithWorkerPool(new A2Handler(),new A2Handler()); 结果示例 可以看到每次执行的线程是不一样的
++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-0 ************************** 1605100167571+A1Handler:10 ************************** DisruptorWorker-2 1605100167572+A2Handler:30 ************************** ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-1 1605100168572+A1Handler:11 ************************** ************************** DisruptorWorker-3 1605100168573+A2Handler:31 ************************** 串行模式（池化） 每个消费端有两个线程实例
disruptor.handleEventsWithWorkerPool(new A1Handler(),new A1Handler()) .then(new A2Handler(),new A2Handler()); 结果示例 ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-0 1605100492248+A1Handler:10 ************************** ************************** DisruptorWorker-2 1605100492249+A2Handler:30 ************************** ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-1 1605100493249+A1Handler:11 ************************** ************************** DisruptorWorker-3 1605100493249+A2Handler:31 **************************</description></item><item><title>Disruptor-缓存行填充</title><link>https://greycode.top/posts/18e3fbd6-ff4b-4a0a-b82f-a547dbef8d0c/</link><pubDate>Mon, 01 Mar 2021 10:02:08 +0000</pubDate><guid>https://greycode.top/posts/18e3fbd6-ff4b-4a0a-b82f-a547dbef8d0c/</guid><description>伪共享概念 CPU架构 常见的CPU架构如下图：
在某个CPU核心上运行一个线程时，他获取数据是先从L1缓存上面找，没有命中数据时，再从L2缓存上面找、还是没有命中时再从L3缓存上找，如果还没有的话就再从主内存里面找。找到后再一层一层的传递数据。
所以查找数据的顺序为：
L1 》L2 》 L3 》主内存
刷新缓存的顺序为：
主内存 》L3 》L2 》L1
缓存存储结构 在计算机缓存中，存储数据是以缓存行为单位的，不同的系统缓存行的大小也不一样，现在常见的64位操作系统，他每行可以存储64字节数据。比如Java中Long类型的数据占8个字节，所以一行可以存8个Long数据类型的数据。
所以当加载缓存行中任意一个数据时，其他在当前缓存行里的数据也会一起加载
线程数据共享 当线程共享一个变量时，每个线程的更改都会把最新数据刷新回主内存，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中（嗅探机制）。
伪共享 上面说的是共享一个缓存行的一个数据，这样是完全没问题的。可是当不同线程要使用一个缓存行里的不同数据时，这样就会出现一种伪共享的情况:
尽管变量a没有被其他线程更改，可以由于他和变量d在同一缓存行里，所以每次都会受变量d的影响,缓存都会被设置为无效状态，所以每次使用时都会从主内存里重新拉取。这样速度就会大大的打折扣。
RingBuffer的解决方法 在RingBuffer解决伪共享的方法就是缓存行填充
abstract class RingBufferPad { protected long p1, p2, p3, p4, p5, p6, p7; }</description></item><item><title>Disruptor-等待策略</title><link>https://greycode.top/posts/ff51336d-70d4-449c-9214-fff2542bef1f/</link><pubDate>Mon, 01 Mar 2021 10:02:06 +0000</pubDate><guid>https://greycode.top/posts/ff51336d-70d4-449c-9214-fff2542bef1f/</guid><description>BlockingWaitStrategy Disruptor默认策略
对EventProcessor使用等待条件的锁和条件变量的阻塞策略。
当吞吐量和低延迟不如CPU资源那么重要时，可以使用此策略。
LiteBlockingWaitStrategy BlockingWaitStrategy的变体，在无竞争的情况下尝试消除条件唤醒。 显示微基准测试的性能改进。
但是，由于我尚未完全证明锁省略码的正确性，因此应将这种等待策略视为实验性的。
BusySpinWaitStrategy 繁忙旋转策略，该繁忙旋转策略对EventProcessor的障碍使用繁忙的旋转循环。
此策略将使用CPU资源来避免可能导致延迟抖动的系统调用。 最好当线程可以绑定到特定的CPU内核时使用。
TimeoutBlockingWaitStrategy LiteTimeoutBlockingWaitStrategy TimeoutBlockingWaitStrategy的变体，在无竞争的情况下尝试消除条件唤醒。
PhasedBackoffWaitStrategy 在屏障上等待EventProcessor的分阶段等待策略。
当吞吐量和低延迟不如CPU资源那么重要时，可以使用此策略。 旋转，然后屈服，然后使用配置的后备WaitStrategy等待。
SleepingWaitStrategy 最初启动的休眠策略，然后使用Thread.yield（），最后在EventProcessor等待屏障时，休眠操作系统和JVM将允许的最小数量的nanos。
此策略是性能和CPU资源之间的良好折衷。 安静时段后可能会出现延迟峰值。 这也将减少对生产线程的影响，因为它不需要发出信号通知任何条件变量来唤醒事件处理线程。
YieldingWaitStrategy 在初始旋转后，使用Thread.yield（）的EventProcessor在屏障上等待。
如果其他线程需要CPU资源，则此策略将使用100％CPU，但比忙碌的自旋策略更容易放弃CPU。</description></item><item><title>Disruptor-消费模式简介(单个实例)</title><link>https://greycode.top/posts/9a1bdb74-8ed3-4905-88bc-7b3b4e0a4af2/</link><pubDate>Mon, 01 Mar 2021 10:01:00 +0000</pubDate><guid>https://greycode.top/posts/9a1bdb74-8ed3-4905-88bc-7b3b4e0a4af2/</guid><description>并行模式 并行模式下两个Handler同时执行，互不影响
disruptor.handleEventsWith(new A1Handler(),new B1Handler()); 结果示例 ++++++++++ 1605084168915+B1Handler:5 1605084168915+A1Handler:1 ++++++++++ 1605084169915+B1Handler:6 1605084169915+A1Handler:2 串行模式 串行模式下，Handler执行必须是从前往后，按顺序执行。
disruptor.handleEventsWith(new A1Handler()).then(new B1Handler()); // or disruptor.handleEventsWith(new B1Handler()).then(new A1Handler()); 结果示例 结果和handler放置的顺序有关，后面的handler要等前面的执行完才会执行
++++++++++ 1605084411462+A1Handler:1 1605084411467+B1Handler:5 ++++++++++ 1605084412463+A1Handler:2 1605084412463+B1Handler:6 // or ++++++++++ 1605084638285+B1Handler:5 1605084638289+A1Handler:1 ++++++++++ 1605084639286+B1Handler:6 1605084639286+A1Handler:2 菱形模式 菱形模式其实就是并行和串行的结合体，先并行执行，再串行执行
disruptor.handleEventsWith(new A1Handler(), new A2Handler()).then(new B1Handler()); 结果示例 B1Handler要等A1Handler和A2Handler全部执行完，它才会执行。
++++++++++ 1605085280283+A1Handler:1 1605085280283+A2Handler:3 1605085280287+B1Handler:5 ++++++++++ 1605085281283+A1Handler:2 1605085281283+A2Handler:4 1605085281283+B1Handler:6 链式模式 链式模式也是并行和串行的结合，并行模式执行串行模式
disruptor.handleEventsWith(new A1Handler()).then(new A2Handler()); disruptor.handleEventsWith(new B1Handler()).then(new B2Handler()); 结果示例 ++++++++++ 1605085843558+B1Handler:5 1605085843558+A1Handler:1 1605085843563+A2Handler:3 1605085843563+B2Handler:7 ++++++++++ 1605085844558+B1Handler:6 1605085844558+A1Handler:2 1605085844558+B2Handler:8 1605085844559+A2Handler:4 总结 所有的模式都可以根据并行和串行来衍生出各种模式，玩法多种多样。</description></item><item><title>Disruptor-实例化方法</title><link>https://greycode.top/posts/b3025291-ae52-4d26-a70c-66a79bda07d7/</link><pubDate>Mon, 01 Mar 2021 09:58:05 +0000</pubDate><guid>https://greycode.top/posts/b3025291-ae52-4d26-a70c-66a79bda07d7/</guid><description>创建一个事件实体 public class LongEvent{ private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } 创建一个事件实体工厂 public class LongEventFactory implements EventFactory&amp;lt;LongEvent&amp;gt; { public LongEvent newInstance() { return new LongEvent(); } } 创建两个事件处理类 /** * EventHandler&amp;lt;LongEvent&amp;gt; 是没有池化的实现方式,每个消费者中只有一个示例 * WorkHandler&amp;lt;LongEvent&amp;gt; 是池化的实现方式，每个消费者中可以以类似线程池的方式去执行这个事件 * 实际根据业务场景 实现其中一个接口就可以 */ public class A1Handler implements EventHandler&amp;lt;LongEvent&amp;gt; , WorkHandler&amp;lt;LongEvent&amp;gt; { public void onEvent(LongEvent longEvent, long l, boolean b) throws Exception { long id = longEvent.</description></item><item><title>Disruptor-快速开始</title><link>https://greycode.top/posts/a552f7f0-4cbe-4628-8fcf-02f8b8730b56/</link><pubDate>Mon, 01 Mar 2021 09:58:03 +0000</pubDate><guid>https://greycode.top/posts/a552f7f0-4cbe-4628-8fcf-02f8b8730b56/</guid><description>创建一个事件实体 public class LongEvent{ private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } 创建一个事件实体工厂 public class LongEventFactory implements EventFactory&amp;lt;LongEvent&amp;gt; { public LongEvent newInstance() { return new LongEvent(); } } 创建两个事件处理类 /** * EventHandler&amp;lt;LongEvent&amp;gt; 是没有池化的实现方式,每个消费者中只有一个示例 * WorkHandler&amp;lt;LongEvent&amp;gt; 是池化的实现方式，每个消费者中可以以类似线程池的方式去执行这个事件 * 实际根据业务场景 实现其中一个接口就可以 */ public class A1Handler implements EventHandler&amp;lt;LongEvent&amp;gt; , WorkHandler&amp;lt;LongEvent&amp;gt; { public void onEvent(LongEvent longEvent, long l, boolean b) throws Exception { long id = longEvent.</description></item><item><title>Disruptor-生产者发布方式</title><link>https://greycode.top/posts/926f33f0-651d-471a-ad0c-b632fcce8c0f/</link><pubDate>Mon, 01 Mar 2021 09:57:58 +0000</pubDate><guid>https://greycode.top/posts/926f33f0-651d-471a-ad0c-b632fcce8c0f/</guid><description>旧版本API发布方式 import com.lmax.disruptor.RingBuffer; public class LongEventProducer{ private final RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer; public LongEventProducer(RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer){ this.ringBuffer = ringBuffer; } public void onData(ByteBuffer bb){ long sequence = ringBuffer.next(); // Grab the next sequence try{ LongEvent event = ringBuffer.get(sequence); // Get the entry in the Disruptor // for the sequence event.set(bb.getLong(0)); // Fill with data } finally{ ringBuffer.</description></item><item><title>JDKproxy和Cglib初探</title><link>https://greycode.top/posts/jdkproxy-cglib/</link><pubDate>Wed, 16 Sep 2020 15:09:47 +0000</pubDate><guid>https://greycode.top/posts/jdkproxy-cglib/</guid><description>JDKproxy和Cglib初探 简介 在Java中，动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地制定一组接口及委托类对象，便能动态地获得代理类。动态代理在Java中有着广泛的应用，比如Spring AOP，Hibernate数据查询、测试框架的后端mock、RPC，Java注解对象获取等。
JDK原生动态代理(JDKProxy) JDKProxy只能对实现了接口的类生成代理，而不能针对普通类 。JDKProxy原生的反射API进行操作，在生成类上比较高效。
使用 interface TestInterface{ void test(); } class TestClass implements TestInterface{ @Override public void test(){ System.out.println(&amp;#34;JDK动态代理&amp;#34;); } } //主方法 public class JDKProxy { public static void main(String[] args) { TestClass testClass=new TestClass(); ProxyHandle proxyHandle=new ProxyHandle(testClass); //使用接口 TestInterface testClass1= (TestInterface) Proxy.newProxyInstance( testClass.getClass().getClassLoader(), testClass.getClass().getInterfaces(),proxyHandle); testClass1.test(); System.out.println(&amp;#34;代理类名称：&amp;#34;+testClass1.getClass()); } } //代理 class ProxyHandle implements InvocationHandler{ private Object originaObj; public ProxyHandle(Object o){ this.</description></item><item><title>Java包装类缓存机制</title><link>https://greycode.top/posts/java-base-data-pack/</link><pubDate>Wed, 16 Sep 2020 15:08:18 +0000</pubDate><guid>https://greycode.top/posts/java-base-data-pack/</guid><description>面试题 首先,来看一道常见的面试题,下面代码运行后会输出什么?
上面代码运行后,最终会输出false和true;为什么会这样呢?
按道理来说,在Java中==是比较两个对象的地址,上面代码中i3和i4是两个不同的对象,理应也应该返回是false,怎么返回是true呢?让我们慢慢往下看
Integer的缓存机制 让我们来看看他的源代码.
当执行Integer i=128;这个语句时,Java会调用valueOf(int i)方法,然后自动装箱的方式,让其变成Integer i=new Integer(128),具体源码如下:
public static Integer valueOf(int i) { if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; //装箱 return new Integer(i); } 从上面的源码中可以看到,在装箱之前会执行一个if语句,这个if语句就是判断传入的值是否在缓存内,如果在缓存内,就直接返回缓存内的值,如果不在缓存内,就装箱,在堆内创建一个新空间来存放.
//Integer包装类缓存源码 private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.</description></item><item><title>JVM运行时栈帧</title><link>https://greycode.top/posts/java-jvm-stack-1/</link><pubDate>Wed, 16 Sep 2020 15:06:15 +0000</pubDate><guid>https://greycode.top/posts/java-jvm-stack-1/</guid><description>在JVM中，每个线程都包含n个栈帧，每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。
栈帧的生命周期随着方法的创建而创建，随着方法的结束而销毁，无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算方法的结束。
在某条线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧称为当前栈帧，这个栈帧对应的方法称为当前方法，定义这个方法的类称为当前类。对局部变量表和操作数栈的各种操作，通常都指的是对当前栈帧的局部变量表和操作数栈所进行的操作。
**注意:**栈帧是线程本地私有的数据，不可能在一个栈帧 之中引用另外一个线程的栈帧
局部变量表 局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
存储方法 局部变量表的容量以变量槽（Variable Slot）为最小单位，一般在虚拟机中，一个Slot占用32位存储空间(这不是固定的，虚拟机可以自行改变每个槽占用空间的大小,但一般都是32位)。
Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。
eg: 在Java中，long在内存占64位，所以局部变量表用2个slot来存储
对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。
long和double的非原子性协定 在Java内存模型中，对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的**“long和double的非原子性协定”（Non-Atomic Treatment of doubleand long Variables）**。
虽然有这个协定，但是，由于局部变量表(Local Variable Table)是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。
初始值问题 我们已经知道类的字段变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。
但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值，那它是完全不能使用的。所以不要认为Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false等这样的默认值规则。
eg： // 这个方法会报： // Error:(12, 28) java: variable y might not have been initialized public class JVMTest { public static void main(String[] args) { int y; int z=3; System.out.println(y+z); } } // 这个会正常输出 3； 因为int的初始值为0 public class JVMTest { private static int y; public static void main(String[] args) { int z=3; System.</description></item><item><title>JVM类加载过程</title><link>https://greycode.top/posts/java-class-load-2/</link><pubDate>Wed, 16 Sep 2020 15:04:22 +0000</pubDate><guid>https://greycode.top/posts/java-class-load-2/</guid><description>加载 通过一个类的全限定名(例如：java.lang.String)来获取定义此类的二进制字节流。
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。
从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
从网络中获取，这种场景最典型的应用就是Web Applet。
运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。
由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。
从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。
可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。
验证 文件格式验证 是否以魔数0xCAFEBABE开头。 主、次版本号是否在当前Java虚拟机接受范围之内 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 ·Class文件中各个部分及文件本身是否有被删除的或附加的其他信息 &amp;hellip;&amp;hellip; 元数据验证 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 &amp;hellip;&amp;hellip; 字节码验证 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。 &amp;hellip;&amp;hellip; 符号引用验证 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当前类访问。 &amp;hellip;&amp;hellip; 准备 准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</description></item><item><title>JVM中的双亲委派机制</title><link>https://greycode.top/posts/java-class-load-1/</link><pubDate>Wed, 16 Sep 2020 15:02:34 +0000</pubDate><guid>https://greycode.top/posts/java-class-load-1/</guid><description>四种类加载器 启动类加载器(Bootstrap Class Loader )：加载$JAVA_HOME/jre/lib目录下的jar包 拓展类加载器(Extension Class Loader)：加载$JAVA_HOME/jre/lib/ext目录下的jar包 应用程序类加载器(Application Class Loader)：加载ClassPath目录下的jar包 自定义类加载器(User Class Loader)：加载自定义指定目录下的jar包 双亲委派机制 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。
代码示例 当获取Bootstrap class loader的时候，输出了null，说明开发者无法通过引用操作启动类加载器
双亲委派机制的作用 每个加载器都只需要固定的加载自己管理范围内的类，这样的好处就是保证了Java体系的稳定，不然的话你自己定义一个String类的话，这样系统中就会有两个String类，如果没有双亲委派机制的话，系统就不知道到底该加载哪一个，这样系统就变得一片混乱了。
破坏双亲委派机制 双亲委派机制是Java设计者推荐给开发者们的类加载实现方式，并不是一个强制性约束的模型，所以也可以人为的破坏这个机制。
源码 源码在java.lang.ClassLoader有兴趣的可以去看下
可以看到，就这短短的几行代码，就实现了听起来很高大上的双亲委派机制，所以破坏双亲委派机制的话，就直接重写loadClass方法就可以了。</description></item><item><title>Java类初始化</title><link>https://greycode.top/posts/java-class-init/</link><pubDate>Wed, 16 Sep 2020 15:01:03 +0000</pubDate><guid>https://greycode.top/posts/java-class-init/</guid><description>代码结果？ 首先，我们来看看下面的代码的输出的结果，可以先试着想一下
//结果 Code 公众号 这时候有同学就会想，以前不是说类加载时，静态代码块都会加载的嘛！怎么Test1里的静态代码块没有加载呢？下面就来看看到底怎么回事
类的生命周期 了解类加载前，首先熟悉一下类的生命周期
这里注意几个点：
解析阶段可以在初始化阶段之后，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。 初始化和实例化 我相信很多人跟我刚开始一样，搞不清他们两个的区别，搞不清new一个对象，到底是对这个对象进行了初始化还是实例化呢？
初始化：是完成程序执行前的准备工作。在这个阶段，静态的（变量，方法，代码块）会被执行。同时在会开辟一块存储空间用来存放静态的数据。初始化只在类加载的时候执行一次。
实例化：是指创建一个对象的过程。这个过程中会在堆中开辟内存，将一些非静态的方法，变量存放在里面。在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。
类的初始化 《Java虚拟机规范》中并没有对加载进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。那到底什么时候能够生成这些指令呢？其实看下字节码就都明白了
使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
java.lang.invoke.MethodHandle 是JDK7中新加入类似反射功能的一个类
被动引用 对于以上这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。
像文章一开始的代码，就属于被动引用，对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
例子1&amp;ndash;对象数组 直接上图
以上代码执行后并不会输出灰色两个字，因为创建对象数组时并没有去初始化Test1这个类，而是用anewarray字节码指令去初始化了另外一个类，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类。
拓展：数组越界检查没有封装在数组元素的访问类中，而是封装在数组访问的xaload,xastore字节码指令中
例子2&amp;ndash;final修饰的静态字段 被final修饰的静态字段 此时运行该代码时，只会输出灰色Code字样，Test1并没有触发初始化阶段。这是因为在编译阶段通过常量传播优化，已经将此常量的值灰色Code直接存储在ClassLoadTest类的常量池中，所以当ClassLoadTest类调用Test1里的value时，都变成了对自身常量池的调用，和Test1类没有任何关系。
没有final修饰的静态字段
没有使用final修饰的静态变量，字节码出现了getstatic，所以触发Test1的初始化阶段，此时运行结果将会输出灰色和灰色Code</description></item><item><title>Java四种引用方法使用和对比</title><link>https://greycode.top/posts/jvm-object-four-quote/</link><pubDate>Fri, 29 May 2020 10:22:07 +0000</pubDate><guid>https://greycode.top/posts/jvm-object-four-quote/</guid><description>强引用（Strongly Reference） 无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
回收时机:强引用关系不存在时 Object obj=new Object(); 软引用（Soft Reference） 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
回收时机:发送内存溢出异常前 //软引用 SoftReference&amp;lt;Object&amp;gt; srf = new SoftReference&amp;lt;Object&amp;gt;(new Object()); //or Object obj=new Object(); SoftReference&amp;lt;Object&amp;gt; srf = new SoftReference&amp;lt;Object&amp;gt;(obj); obj=null; //这种方法一定要设置obj为null,否则这个对象除了软引用可达外,还有原来强引用也可达 弱引用（Weak Reference） 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
回收时机:下一次垃圾回收时 //弱引用 WeakReference&amp;lt;Object&amp;gt; wrf = new WeakReference&amp;lt;Object&amp;gt;(new Object()); //or Object obj=new Object(); WeakReference&amp;lt;Object&amp;gt; wrf = new WeakReference&amp;lt;Object&amp;gt;(new Object()); obj=null; 虚引用（Phantom Reference） 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
回收时机:随时 //虚引用 PhantomReference&amp;lt;Object&amp;gt; prf = new PhantomReference&amp;lt;Object&amp;gt;(new Object(), new ReferenceQueue&amp;lt;&amp;gt;()); //or Object obj=new Object(); PhantomReference&amp;lt;Object&amp;gt; prf = new PhantomReference&amp;lt;Object&amp;gt;(obj, new ReferenceQueue&amp;lt;&amp;gt;()); obj=null;</description></item><item><title>【源码解析】你真的了解ArrayDeque嘛？</title><link>https://greycode.top/posts/java-arraydeque-source-1/</link><pubDate>Wed, 08 Jan 2020 14:00:51 +0000</pubDate><guid>https://greycode.top/posts/java-arraydeque-source-1/</guid><description/></item><item><title>【源码解析】想了解LinkedList？看这篇文章就对了</title><link>https://greycode.top/posts/java-linkedlist-source-1/</link><pubDate>Sun, 05 Jan 2020 00:21:43 +0000</pubDate><guid>https://greycode.top/posts/java-linkedlist-source-1/</guid><description/></item><item><title>【源码解析】扒开ArrayList的外衣</title><link>https://greycode.top/posts/java-arraylist-source-1/</link><pubDate>Fri, 03 Jan 2020 19:13:31 +0000</pubDate><guid>https://greycode.top/posts/java-arraylist-source-1/</guid><description>积千里跬步，汇万里江河；每天进步一点点，终有一天将成大佬。
本文内容 当然ArrayList里的方法不止这些，本文主要讲一些常用的方法
方法变量 Arraylist里的方法变量主要有以下几个
构造方法 有参构造 传入数组的大小 代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(5); 源码解析 传入一个list对象 其实这个就相当于把传入的list对象里的数据复制到新的ArrayList对象
代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&amp;#34;z&amp;#34;,&amp;#34;m&amp;#34;,&amp;#34;h&amp;#34;)); 这里用来Arrays工具类里的asList方法，它的源码里是直接返回一个List，有兴趣的可以去看看，这里就不介绍了
源码解析 无参构造 这个比较简单，直接赋值一个空数组
代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(); 源码解析 add方法 add一般常用的有两个方法，一个就是add(E e)在尾部添加数据，一个就是add(int index,E element)在指定位置插入元素
add(E e) 这个是Arrayist的主要方法，平时用的也是最多的方法之一，所以源码比较复杂，比较长
代码实现 List&amp;lt;String&amp;gt; list=new ArrayList&amp;lt;&amp;gt;(); list.add(&amp;#34;灰灰HK&amp;#34;); 源码解析 ensureCapacityInternal(int minCapacity)确保数组容量充足 calculateCapacity(Object[] elementData, int minCapacity) 再回到ensureExplicitCapacity(int minCapacity)这个方法，这个方法先修改次数加1，然后判断size+1是不是比当前的数组容量大，如果比当前的数组容量大，则进行扩容操作，扩大容量为原数组的1.5倍 比如第二次调用add方法，此时size+1=2, elementData.length=10,为什么等于10呢？因为第一次默认把数组容量从0扩大到了10,这时size+1比elementData.length小，就不会进行扩容操作
grow(int minCapacity)扩容 这里调用Arrays.</description></item><item><title>【图】用图片告诉你Java中的位运算</title><link>https://greycode.top/posts/java-base-wei/</link><pubDate>Mon, 30 Dec 2019 22:17:30 +0000</pubDate><guid>https://greycode.top/posts/java-base-wei/</guid><description>前言 ​ 虽然位运算在实际开发中并不常用,但是在各种算法中却常常见到它们的身影.因为是直接操作二进制的,所以机器执行起来就快很多,所以尽管实际业务中不常用,但如果你不想只做个码农,这个基础还是要掌握的;
讲位操作之前,就必须要知道原码、反码、补码 其中正数的原码=反码=补码 原码、反码、补码 在机器的内存中,一个负数的表示是这个负数的绝对值取原码,再取反码,再加一,最后出现的就是这个负数在内存中的表示的二进制数值
比如说-9在内存中的二进制码,这里用8位表示:
最后-9在内存中的二进制值为11110111 在二进制中,最高位为符号位,0代表正,1代表负 位运算 左移和右移 在Java中的int类型有4字节,一个字节有8位,所以这边用32位表示一个数
负数的左移和右移 这边负数表示是在内存中表示的二进制值右移时:最高位补符号位1左移时:末尾补0
正数的左移和右移 右移时:最高位补符号位0左移时:末尾补0
无符号右移 无论是正数还是负数,右移最高位一律补0 &amp;amp;(位与) 当相对应的位都为1时,等于1,否则等于0
为了方便表示,接下来全部都用8位表示一个数
|(位或) 当相对应的位有一个为1时,等于1,否则等于0
^(异或) 当相对应的位不同时,等于1,相同时等于0
~(取反) 1等于0,0等于1
总结 含义 运算符 说明 左移 &amp;laquo; 末尾补0 右移 &amp;gt;&amp;gt; 负数:最高位补符号位1正数:最高位补符号位0 无符号右移 &amp;gt;&amp;raquo; 无论是正数还是负数,右移最高位一律补0 &amp;amp;(位与) &amp;amp; 当相对应的位都为1时,等于1,否则等于0 |(位或) | 当相对应的位有一个为1时,等于1,否则等于0 ^(异或) ^ 当相对应的位 不同时,等于1 相同时,等于0 ~(取反) ~ 1等于0,0等于1 最后有个小技巧,向左位移几位就是乘以2的几次方,比如9向左移n位,就是 $$ 9向左移n位=9*2^n $$</description></item><item><title>Java8 Stream方法大全</title><link>https://greycode.top/posts/java-8-stream-method/</link><pubDate>Tue, 10 Dec 2019 09:53:34 +0000</pubDate><guid>https://greycode.top/posts/java-8-stream-method/</guid><description/></item><item><title>Java数组的几种初始化方式</title><link>https://greycode.top/posts/java-array-init/</link><pubDate>Mon, 09 Dec 2019 10:22:12 +0000</pubDate><guid>https://greycode.top/posts/java-array-init/</guid><description>一维数组 初始化容量 /** * 定义容量为5,初始值为0的int一维数组 */ int array[]=new int[5]; int[] array2=new int[5]; 初始化值 /** * 初始化一维容量为5的一维数组的值 */ int[] array10={1,2,3,4,5}; int aray12[]={1,2,3,4,5}; 二维数组 二维数组初始化时必须要声明行数,列数可随意
初始化容量 声明了列数的 /** * 初始化一个5行5列的二维数组 */ int[][] array3=new int[5][5]; int []array4[]=new int[5][5]; int array5[][]=new int[5][5]; 未声明列数的 此种方法初始化后如果要赋值的话要new一个数组,如果按照常规的方法赋值然后取值会报空指针异常
/** * 初始化一个5行空列的二维数组 */ int[][] array6=new int[5][]; int []arra7[]=new int[5][]; int array8[][]=new int[5][]; /** * 赋值方法 */ int[][] array6=new int[5][]; array6[0]=new int[]{1,2,3}; System.</description></item><item><title>JDK时区问题</title><link>https://greycode.top/posts/problem-jdk-timezone/</link><pubDate>Tue, 27 Aug 2019 15:26:30 +0000</pubDate><guid>https://greycode.top/posts/problem-jdk-timezone/</guid><description>今天碰到一个大坑，弄了快一个小时才解决掉；
一个管理台后端服务，用docker隔离了三个容器，oracle,nginx,tomcat;后发现管理台查出来的时间和现实时间相差8个小时，一查是linux时区问题；
于是改之,三台容器都输入一下代码 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 测试了一下，发现问题docker容器的时区是正确了，可是问题并未得到解决，数据库时间还是慢了8个小时。
于是又查资料，换另外一种设置时区的方法； vi /etc/sysconfig/clock 在里面输入如下内容
ZONE=&amp;#34;Asia/Shanghai&amp;#34; UTC=false ARC=false 保存，重启，测试。。。。。发现还是一样,快疯了
第三种方法，设置TZ环境变量 设置环境变量可以在设置系统级别的/etc/profile ,也可以设置用户级别的home目录的.bashrc。由于用的是docker，防止变量重启失效，只能在.bashrc里设置。在.bashrc加入如下内容：
export TZ=&amp;#39;CST-8&amp;#39; 保存：然后执行
source .bashrc 使设置立即生效。
重启容器，测试，发现时间正常了。。。。哈哈哈哈
总结 上面问题出在jdk的new Date()方法，所以只要设置jdk所在的那个docker容器的变量就可以，不用每个都设置。jdk的new Date()方法每次调用都会去取环境变量TZ的时区，TZ是TimeZone的缩写，容器内部操作系统并未指定时区（TimeZone）信息，系统默认使用世界标准时（UTC+0),所以导致new Date()出来的数据存库会比当前时间慢8个小时；</description></item><item><title>Java的==和equals</title><link>https://greycode.top/posts/java-equals/</link><pubDate>Tue, 20 Aug 2019 19:22:50 +0000</pubDate><guid>https://greycode.top/posts/java-equals/</guid><description>在平常工作和学习中，我们一般用==和equals来比较两个对象或数据是否相等。但是什么时候用equals，什么时候用==一直都不怎么清楚，今天整理了下；
首先看看Java的栈空间和堆空间的地址引用 ==的说明 在Java中，==对比的是两个对象在空间里的地址是否一致,比如上图的s2==s3返回的是false，s5==s6返回的是为true。话不多说，上代码。
public class demo2 { public static void main(String[] args) { String s1=new String(&amp;#34;t1&amp;#34;); String s2=new String(&amp;#34;t2&amp;#34;); String s3=new String(&amp;#34;t2&amp;#34;); String s4=new String(&amp;#34;t3&amp;#34;); String s5=&amp;#34;t3&amp;#34;; String s6=&amp;#34;t3&amp;#34;; System.out.println(&amp;#34;s2==s3:&amp;#34;+(s2==s3)); System.out.println(&amp;#34;s5==s6:&amp;#34;+(s5==s6)); } } 结果： 这是因为==比的是在空间里的地址，s2和s3在堆里面是两个不同的对象，所以地址也不同，自然返回就是false。s5和s6是Java的基础数据类型，指向的是常量池里同一个引用，所以地址也相同，返回的就是true。
equals的说明 每个Object里的equals都不一样，我们看看String里的源码
public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.</description></item><item><title>Java中String判断为空的4大方法比较</title><link>https://greycode.top/posts/java-isnull-four/</link><pubDate>Tue, 20 Aug 2019 18:59:15 +0000</pubDate><guid>https://greycode.top/posts/java-isnull-four/</guid><description>一.四大方法 public class demo1 { public static void main(String[] args) { String a=&amp;#34;&amp;#34;; String a2=new String(); System.out.println(a==&amp;#34;&amp;#34;); System.out.println(a2==&amp;#34;&amp;#34;); System.out.println(&amp;#34;------------------------------&amp;#34;); System.out.println(a==null); System.out.println(a2==null); System.out.println(&amp;#34;------------------------------&amp;#34;); System.out.println(a.length()&amp;lt;=0); System.out.println(a2.length()&amp;lt;=0); System.out.println(&amp;#34;------------------------------&amp;#34;); System.out.println(a.isEmpty()); System.out.println(a2.isEmpty()); System.out.println(&amp;#34;------------------------------&amp;#34;); } } 二.输出结果 可以看到用&amp;quot;==&amp;ldquo;判断的那组出现了不一致的情况</description></item><item><title>递归算法-获取json中指定key的所有值</title><link>https://greycode.top/posts/algorithm-recursive-01/</link><pubDate>Sat, 17 Aug 2019 12:38:52 +0000</pubDate><guid>https://greycode.top/posts/algorithm-recursive-01/</guid><description>今天在工作中遇到要解析json并获取json里所有指定key的值，再把key的值插入对应的数据映射表。于是写了一个递归算法来取值。
1.首先导入alibaba的fastjson，用来解析json。当然也可以用其他的解析包 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.58&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.创建两个工具类方法，用来判断传入的是不是json对象或json数组 public static boolean isJSONObj(Object json){ return json instanceof JSONObject; } public static boolean isJSONArray(Object json){ return json instanceof JSONArray; } java中的instanceof也称为类型比较运算符，因为它将实例与类型进行比较。它返回true或false。
3.建立核心重载方法 public static void getJSONValue(JSONObject json,String k,List&amp;lt;String&amp;gt; list){ for (Object j:json.keySet()){ if(isJSONObj(json.get(j))){ //是对象 JSONObject j2= JSON.parseObject(json.get(j).toString()); getJSONValue(j2,k,list); }else if(isJSONArray(json.get(j))){ JSONArray j3=JSON.parseArray(json.get(j).toString()); //是数组 getJSONValue(j3,k,list); }else if(j==k){ //是字符串 list.</description></item><item><title>Base64影响泰文字段取值问题</title><link>https://greycode.top/posts/problem-java-base64/</link><pubDate>Wed, 14 Aug 2019 10:39:23 +0000</pubDate><guid>https://greycode.top/posts/problem-java-base64/</guid><description>今天在工作中，图片要用base64上传，上传数据中还有泰文，然后和前端app联调时发现他们传的泰文这边竟然没存到库里，怀疑是app没有传值过来，于是一番操作 查看日志 what,日志里面竟然有他们传过来的泰文的值
对比ios和android的数据 发现日志里的数据都是一样的，但是android上传的数据全部传入了mysql数据库，ios的除了泰文，其他的也都传到了库里
确定问题 最后对比发现，android的泰文字段三放在base64字段前面的然后传上来的，ios是放在base64字段后面传上来的，怀疑问题在此处
修复bug 于是叫ios也和android一样，把上传字段的顺序调整了以下，把泰文的字段放在base64字段前面，然后上传。改了之后试了以下，，竟然解决了，2222333333
总结：暂时不知道具体什么原因，有可能是因为base64数据太长了，影响到泰文的字段存储了。</description></item></channel></rss>