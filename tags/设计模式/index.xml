<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on Hello,I‘m Greycode!</title><link>https://greycode.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on Hello,I‘m Greycode!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 27 Dec 2019 06:50:31 +0000</lastBuildDate><atom:link href="https://greycode.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式之建造者模式【用好玩的故事讲清楚设计模式】</title><link>https://greycode.top/posts/gof-builder/</link><pubDate>Fri, 27 Dec 2019 06:50:31 +0000</pubDate><guid>https://greycode.top/posts/gof-builder/</guid><description>积千里跬步,汇万里江河;每天进步一点点,终有一天将成大佬
所有源代码都在这:https://github.com/z573419235/GofDemo
各位大佬记得点个星星哦
前言 建造者模式用于实例化一个比较复杂的实体类,当你实例化一个类时,它的构造参数比较多时,就可以用建造者模式来简化实例化过程;前几篇工厂模式的文章我们说道买车,那只是简单的区工厂买车,我们不关系工厂是怎么造出来的.可是实际工厂造一辆车需要有方向盘、发动机、车架、轮胎等部件,而且不同品牌的车的部件都是不同的,部件虽然不同,但是造车的方式基本都是差不多的步骤,这时候就可以用建造者模式来造一辆车了;
建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成
土豪朋友开车厂 土豪朋友上次买了车之后,发现造车卖还挺赚钱,于是决定涉足汽车领域,真是很有商业头脑啊,不愧是我的玉树临风,疯言疯语,语速惊人,人模狗样的土豪朋友啊. 一天,前去向他讨教汽车的知识,他给我讲了汽车的大致构成:
/** * 汽车 产品类 定义汽车的构成 * */ @Data public class Car { /** * 方向盘 * */ private String steering; /** * 发动机 * */ private String engine; /** * 车架 * */ private String frame; /** * 轮胎 * */ private String tire; /** * 展示一下汽车配置 * */ public String show() { return &amp;#34;{&amp;#34; + &amp;#34;steering=&amp;#39;&amp;#34; + steering + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, engine=&amp;#39;&amp;#34; + engine + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, frame=&amp;#39;&amp;#34; + frame + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, tire=&amp;#39;&amp;#34; + tire + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } 果真是大致啊,忽悠我不懂车是吧,就给我讲4个东西,这谁不知道啊,哼!</description></item><item><title>一个故事一个模式-原型模式</title><link>https://greycode.top/posts/gof-prototype/</link><pubDate>Wed, 25 Dec 2019 23:34:48 +0000</pubDate><guid>https://greycode.top/posts/gof-prototype/</guid><description>积千里跬步,汇万里江河;每天进步一点点,终有一天将成大佬
所有源代码都在这:https://github.com/z573419235/GofDemo
各位大佬记得点个星星哦
前言 前几天生病了,每天头昏脑胀的,诶,生病的时候才知道身体健康的重要性,以后还是要加强锻炼,身体是革命的本钱; 隔了差不多有五六天没写日志了,罪过罪过;好了,今天要说的是原型模式,原型模式在`Java`中核心秘密就是`clone`这个方法,通过重新`Object`中的`clone`方法.来达到原型模式;而要重新`clone`方法就必须要实现`Cloneable`这个接口,不实现这个接口的话就会报`java.lang.CloneNotSupportedException`异常; 我是鸣人 鸣人最喜欢的就是吃拉面,就算是上课的时候也是心心念念的想着一乐大叔的拉面 先来看看鸣人的原型实体类:
/** * @author zheng * * 我是鸣人实体类 */ @Data public class Naruto implements Cloneable{ /** * 姓名 * */ private String name=&amp;#34;鸣人&amp;#34;; /** * 年龄 * */ private int age=13; /** * 任务 * */ private String task; /** *爱好 * */ private ArrayList&amp;lt;String&amp;gt; hobby=new ArrayList&amp;lt;&amp;gt;(); /** * 构造方法 * */ public Naruto(){ this.</description></item><item><title>设计模式系列-模板方法模式</title><link>https://greycode.top/posts/gof-taemplate-method/</link><pubDate>Fri, 20 Dec 2019 00:04:28 +0000</pubDate><guid>https://greycode.top/posts/gof-taemplate-method/</guid><description>积千里跬步，汇万里江河．每天进步一点点，终有一天将成大佬
文前常规发言 　模板方法的设计符合迪米特法则，也就是最少知道原则，他通过对一些重复方法的封装，减少类之间的耦合，让调用者也更省心，原来要调两三个方法才能实现的功能，现在调一个就可以了；就像我们伟大的祖国，现在也在推行这种模式呢．以前区办一些证明什么的，要跑三四个地方，还要保证这三四个地方都正常帮你办理，如果其中一个地方没办理，那么整个流程就都作废了．现在好了，提倡最多跑一次，只要去一个地方办一次手续就可以了，你只要知道这个地方能办好就行，其他的就不用烦心了；
阿狗卖电脑 　阿狗是一个三十五岁没了头发的年轻小伙，当问及为什么没了头发，阿狗摸摸头，眼里充满了悔恨的泪水；要不是小时候没听大人的话，长大了也不至于做程序员啊－－－阿狗唉声叹气的说道．听到这里，我仿佛已经知道了答案．当我问他为什么现在改行卖电脑了，他说外面的世界很大，想趁年轻，多闯闯（实则是被公司裁员，被迫来卖电脑了）；
看看他的电脑店里都有什么
/** * 阿狗电脑店 * */ abstract class AGouShop { /** *显卡 * */ abstract void xianKa(); /** *cpu * */ abstract void cpu(); /** *电源 * */ abstract void dianYuan(); /** *主板 * */ abstract void zhuBan(); /** *硬盘 * */ abstract void yingPan(); /** *内存条 * */ abstract void neiCun(); /** *机箱 * */ abstract void jiXiang(); } 还不错，该有的都有了．当我们正在店里逛着时，来了两个顾客，阿猫和大牛，他们都来到阿狗店电脑店，挑选的电脑配件，准备组装电脑．</description></item><item><title>设计模式系列-抽象工厂模式</title><link>https://greycode.top/posts/gof-abstract-factory/</link><pubDate>Mon, 16 Dec 2019 21:17:23 +0000</pubDate><guid>https://greycode.top/posts/gof-abstract-factory/</guid><description>积千里跬步，汇万里江河；每天进步一点点，终有一天将成大佬
突然开始的正文 紧接着上一章的工厂方法模式，其实抽象工厂的概念和工厂方法的概念都是差不多的，抽象工厂模式是对工厂方法模式的更高级，比如上次我们说的那个汽车工厂总部类AllCarFactory，本来他只定义了生产汽车这个方法，下面的各个品牌的汽车厂也只能生产这个汽车，现在由于市场需求，需要生产摩托车，然后AllCarFactory定义了一个生产摩托车的接口，这样这个接口下面的汽车厂就可以生产摩托车了．就在这时他们的生产模式也从工厂方法模式升级到了抽象工厂模式；
话不多说，看两个模式的类图你就明白了：
原本的工厂方法模式类图： 升级后的抽象工厂模式： 可以看到，抽象工厂只是比工厂方法模式多生产了一个产品，当抽象工厂模式的产品减到只有一个的时候，他就又回到了工厂方法模式；
好色的朋友买车了 上次我朋友看见我买车之后，得知是个小姐姐带我区买车的，于是他叫我联系了下那个小姐姐，说他也要买车，点名要叫小姐姐带他去，由于资金有限，他只卖了奔驰和五菱系列的产品，没有买莱斯莱斯的；看看他是怎么买的吧：
可以看到，由于要在一个工厂买两个东西，他是先找到了工厂，然后再一件一件的从工厂买．我们上次是一个工厂买一件东西，所以是直接去工厂买的；
措不及防的结束了 不是我不想讲，而是抽象工厂就是这样的东西．从上面可以看出，抽象工厂每当增加一个产品时，后面相关的的品牌工厂也全部要实现他这个产品，这就违背了开闭原则了．所以，在实际设计中，一个业务场景是稳定的,用抽象工厂是比较好的，因为一次设计,后面就不用改了,这样就不会违反开闭原则了．但是如果一个业务场景是稳定的是不稳定的，那么就不适合使用这个模式了，因为后期需要多次修改，这就违反了开闭原则，同时也及其难维护，应为你不知道修改了代码，到底会影响哪些功能；</description></item><item><title>设计模式系列-工厂模式</title><link>https://greycode.top/posts/gof-factory-method/</link><pubDate>Sun, 15 Dec 2019 17:25:00 +0000</pubDate><guid>https://greycode.top/posts/gof-factory-method/</guid><description>积千里跬步，汇万里江河．每天进步一点点，终有一天将成大佬
前言 工厂模式有一下三种
简单工厂模式 工厂方法模式 抽象工厂模式 其中简单工厂模式不在23中模式之中，更多的是一种编程习惯，而我们平常所说的工厂模式一般指的是工厂方法模式，抽象工厂在实际的业务开发中也用的比较少，因为它有时候违背了开闭原则．由于篇幅有限，抽象工厂本文就不讲了，以后单独讲；
简单工厂模式 简单工厂到底有多简单呢？简单到只有一个工厂，这个工厂相当于是万能工厂，你想要什么，只要和它说一声，它就会想方设法的去抱你创建，然后给你；举个买车的简单的例子：
当我要买车的时候，我选了这两种车．
/** * 创建一个汽车接口 * */ public interface Car { /** * 汽车能动 * */ void run(); } /** * 奔驰车 * */ public class Benz implements Car { @Override public void run() { System.out.println(&amp;#34;大奔开动了&amp;#34;); } } /** * 五菱神车 * */ public class Wuling implements Car { @Override public void run() { System.</description></item></channel></rss>