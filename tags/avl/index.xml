<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AVL on Hello,I am Greycode!</title><link>https://greycode.top/tags/avl/</link><description>Recent content in AVL on Hello,I am Greycode!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 01 Feb 2020 15:56:00 +0000</lastBuildDate><atom:link href="https://greycode.top/tags/avl/index.xml" rel="self" type="application/rss+xml"/><item><title>【数据结构】手写平衡二叉树（AVL）</title><link>https://greycode.top/posts/algorithm-avltree-01/</link><pubDate>Sat, 01 Feb 2020 15:56:00 +0000</pubDate><guid>https://greycode.top/posts/algorithm-avltree-01/</guid><description>【数据结构】手写平衡二叉树（AVL） 积千里跬步，汇万里江河。每天进步一点点，终有一天将成大佬
本文源代码：手写AVL树
什么是平衡二叉树？ 平衡二叉树，又称为AVL树，当树不是空树时，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。AVL树查找的时间复杂度为O(logN)。
平衡二叉树基本特点 左右子树深度差不能大于1 左边子树永远比根节点小 右边子树永远比根节点大 平衡二叉树基本结构及操作 左左结构——右旋 右右结构——左旋 左右结构——左子先左旋，然后整体右旋 右左结构——右子先右旋，然后整体左旋 代码实现 先创建一个内部类Node，来表示树的每个节点
public class AVLTree { private Node rootNode; //二叉树节点 private class Node{ public Node parent; //父 public Node left; //左子树 public Node right; //右子树 @NotNull public int data; //存放的数据 private int depth; //深度 private int balance; //平衡因子 //有参构造方法 public Node(int data){ this.</description></item></channel></rss>