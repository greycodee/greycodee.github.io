<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Disruptor on Hello,I‘m Greycode!</title><link>https://greycode.top/tags/disruptor/</link><description>Recent content in Disruptor on Hello,I‘m Greycode!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Mar 2021 10:02:15 +0000</lastBuildDate><atom:link href="https://greycode.top/tags/disruptor/index.xml" rel="self" type="application/rss+xml"/><item><title>Disruptor-消费模式简介(池化)</title><link>https://greycode.top/posts/c16646bf-1474-42a7-a5cd-84b99669062c/</link><pubDate>Mon, 01 Mar 2021 10:02:15 +0000</pubDate><guid>https://greycode.top/posts/c16646bf-1474-42a7-a5cd-84b99669062c/</guid><description>并行模式(池化) 每个消费端有两个线程实例
disruptor.handleEventsWithWorkerPool(new A1Handler(),new A1Handler()); disruptor.handleEventsWithWorkerPool(new A2Handler(),new A2Handler()); 结果示例 可以看到每次执行的线程是不一样的
++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-0 ************************** 1605100167571+A1Handler:10 ************************** DisruptorWorker-2 1605100167572+A2Handler:30 ************************** ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-1 1605100168572+A1Handler:11 ************************** ************************** DisruptorWorker-3 1605100168573+A2Handler:31 ************************** 串行模式（池化） 每个消费端有两个线程实例
disruptor.handleEventsWithWorkerPool(new A1Handler(),new A1Handler()) .then(new A2Handler(),new A2Handler()); 结果示例 ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-0 1605100492248+A1Handler:10 ************************** ************************** DisruptorWorker-2 1605100492249+A2Handler:30 ************************** ++++++++++++++++++++++++++++++++++++++++++++++++ ************************** DisruptorWorker-1 1605100493249+A1Handler:11 ************************** ************************** DisruptorWorker-3 1605100493249+A2Handler:31 **************************</description></item><item><title>Disruptor-缓存行填充</title><link>https://greycode.top/posts/18e3fbd6-ff4b-4a0a-b82f-a547dbef8d0c/</link><pubDate>Mon, 01 Mar 2021 10:02:08 +0000</pubDate><guid>https://greycode.top/posts/18e3fbd6-ff4b-4a0a-b82f-a547dbef8d0c/</guid><description>伪共享概念 CPU架构 常见的CPU架构如下图：
在某个CPU核心上运行一个线程时，他获取数据是先从L1缓存上面找，没有命中数据时，再从L2缓存上面找、还是没有命中时再从L3缓存上找，如果还没有的话就再从主内存里面找。找到后再一层一层的传递数据。
所以查找数据的顺序为：
L1 》L2 》 L3 》主内存
刷新缓存的顺序为：
主内存 》L3 》L2 》L1
缓存存储结构 在计算机缓存中，存储数据是以缓存行为单位的，不同的系统缓存行的大小也不一样，现在常见的64位操作系统，他每行可以存储64字节数据。比如Java中Long类型的数据占8个字节，所以一行可以存8个Long数据类型的数据。
所以当加载缓存行中任意一个数据时，其他在当前缓存行里的数据也会一起加载
线程数据共享 当线程共享一个变量时，每个线程的更改都会把最新数据刷新回主内存，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中（嗅探机制）。
伪共享 上面说的是共享一个缓存行的一个数据，这样是完全没问题的。可是当不同线程要使用一个缓存行里的不同数据时，这样就会出现一种伪共享的情况:
尽管变量a没有被其他线程更改，可以由于他和变量d在同一缓存行里，所以每次都会受变量d的影响,缓存都会被设置为无效状态，所以每次使用时都会从主内存里重新拉取。这样速度就会大大的打折扣。
RingBuffer的解决方法 在RingBuffer解决伪共享的方法就是缓存行填充
abstract class RingBufferPad { protected long p1, p2, p3, p4, p5, p6, p7; }</description></item><item><title>Disruptor-等待策略</title><link>https://greycode.top/posts/ff51336d-70d4-449c-9214-fff2542bef1f/</link><pubDate>Mon, 01 Mar 2021 10:02:06 +0000</pubDate><guid>https://greycode.top/posts/ff51336d-70d4-449c-9214-fff2542bef1f/</guid><description>BlockingWaitStrategy Disruptor默认策略
对EventProcessor使用等待条件的锁和条件变量的阻塞策略。
当吞吐量和低延迟不如CPU资源那么重要时，可以使用此策略。
LiteBlockingWaitStrategy BlockingWaitStrategy的变体，在无竞争的情况下尝试消除条件唤醒。 显示微基准测试的性能改进。
但是，由于我尚未完全证明锁省略码的正确性，因此应将这种等待策略视为实验性的。
BusySpinWaitStrategy 繁忙旋转策略，该繁忙旋转策略对EventProcessor的障碍使用繁忙的旋转循环。
此策略将使用CPU资源来避免可能导致延迟抖动的系统调用。 最好当线程可以绑定到特定的CPU内核时使用。
TimeoutBlockingWaitStrategy LiteTimeoutBlockingWaitStrategy TimeoutBlockingWaitStrategy的变体，在无竞争的情况下尝试消除条件唤醒。
PhasedBackoffWaitStrategy 在屏障上等待EventProcessor的分阶段等待策略。
当吞吐量和低延迟不如CPU资源那么重要时，可以使用此策略。 旋转，然后屈服，然后使用配置的后备WaitStrategy等待。
SleepingWaitStrategy 最初启动的休眠策略，然后使用Thread.yield（），最后在EventProcessor等待屏障时，休眠操作系统和JVM将允许的最小数量的nanos。
此策略是性能和CPU资源之间的良好折衷。 安静时段后可能会出现延迟峰值。 这也将减少对生产线程的影响，因为它不需要发出信号通知任何条件变量来唤醒事件处理线程。
YieldingWaitStrategy 在初始旋转后，使用Thread.yield（）的EventProcessor在屏障上等待。
如果其他线程需要CPU资源，则此策略将使用100％CPU，但比忙碌的自旋策略更容易放弃CPU。</description></item><item><title>Disruptor-消费模式简介(单个实例)</title><link>https://greycode.top/posts/9a1bdb74-8ed3-4905-88bc-7b3b4e0a4af2/</link><pubDate>Mon, 01 Mar 2021 10:01:00 +0000</pubDate><guid>https://greycode.top/posts/9a1bdb74-8ed3-4905-88bc-7b3b4e0a4af2/</guid><description>并行模式 并行模式下两个Handler同时执行，互不影响
disruptor.handleEventsWith(new A1Handler(),new B1Handler()); 结果示例 ++++++++++ 1605084168915+B1Handler:5 1605084168915+A1Handler:1 ++++++++++ 1605084169915+B1Handler:6 1605084169915+A1Handler:2 串行模式 串行模式下，Handler执行必须是从前往后，按顺序执行。
disruptor.handleEventsWith(new A1Handler()).then(new B1Handler()); // or disruptor.handleEventsWith(new B1Handler()).then(new A1Handler()); 结果示例 结果和handler放置的顺序有关，后面的handler要等前面的执行完才会执行
++++++++++ 1605084411462+A1Handler:1 1605084411467+B1Handler:5 ++++++++++ 1605084412463+A1Handler:2 1605084412463+B1Handler:6 // or ++++++++++ 1605084638285+B1Handler:5 1605084638289+A1Handler:1 ++++++++++ 1605084639286+B1Handler:6 1605084639286+A1Handler:2 菱形模式 菱形模式其实就是并行和串行的结合体，先并行执行，再串行执行
disruptor.handleEventsWith(new A1Handler(), new A2Handler()).then(new B1Handler()); 结果示例 B1Handler要等A1Handler和A2Handler全部执行完，它才会执行。
++++++++++ 1605085280283+A1Handler:1 1605085280283+A2Handler:3 1605085280287+B1Handler:5 ++++++++++ 1605085281283+A1Handler:2 1605085281283+A2Handler:4 1605085281283+B1Handler:6 链式模式 链式模式也是并行和串行的结合，并行模式执行串行模式
disruptor.handleEventsWith(new A1Handler()).then(new A2Handler()); disruptor.handleEventsWith(new B1Handler()).then(new B2Handler()); 结果示例 ++++++++++ 1605085843558+B1Handler:5 1605085843558+A1Handler:1 1605085843563+A2Handler:3 1605085843563+B2Handler:7 ++++++++++ 1605085844558+B1Handler:6 1605085844558+A1Handler:2 1605085844558+B2Handler:8 1605085844559+A2Handler:4 总结 所有的模式都可以根据并行和串行来衍生出各种模式，玩法多种多样。</description></item><item><title>Disruptor-实例化方法</title><link>https://greycode.top/posts/b3025291-ae52-4d26-a70c-66a79bda07d7/</link><pubDate>Mon, 01 Mar 2021 09:58:05 +0000</pubDate><guid>https://greycode.top/posts/b3025291-ae52-4d26-a70c-66a79bda07d7/</guid><description>创建一个事件实体 public class LongEvent{ private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } 创建一个事件实体工厂 public class LongEventFactory implements EventFactory&amp;lt;LongEvent&amp;gt; { public LongEvent newInstance() { return new LongEvent(); } } 创建两个事件处理类 /** * EventHandler&amp;lt;LongEvent&amp;gt; 是没有池化的实现方式,每个消费者中只有一个示例 * WorkHandler&amp;lt;LongEvent&amp;gt; 是池化的实现方式，每个消费者中可以以类似线程池的方式去执行这个事件 * 实际根据业务场景 实现其中一个接口就可以 */ public class A1Handler implements EventHandler&amp;lt;LongEvent&amp;gt; , WorkHandler&amp;lt;LongEvent&amp;gt; { public void onEvent(LongEvent longEvent, long l, boolean b) throws Exception { long id = longEvent.</description></item><item><title>Disruptor-快速开始</title><link>https://greycode.top/posts/a552f7f0-4cbe-4628-8fcf-02f8b8730b56/</link><pubDate>Mon, 01 Mar 2021 09:58:03 +0000</pubDate><guid>https://greycode.top/posts/a552f7f0-4cbe-4628-8fcf-02f8b8730b56/</guid><description>创建一个事件实体 public class LongEvent{ private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } 创建一个事件实体工厂 public class LongEventFactory implements EventFactory&amp;lt;LongEvent&amp;gt; { public LongEvent newInstance() { return new LongEvent(); } } 创建两个事件处理类 /** * EventHandler&amp;lt;LongEvent&amp;gt; 是没有池化的实现方式,每个消费者中只有一个示例 * WorkHandler&amp;lt;LongEvent&amp;gt; 是池化的实现方式，每个消费者中可以以类似线程池的方式去执行这个事件 * 实际根据业务场景 实现其中一个接口就可以 */ public class A1Handler implements EventHandler&amp;lt;LongEvent&amp;gt; , WorkHandler&amp;lt;LongEvent&amp;gt; { public void onEvent(LongEvent longEvent, long l, boolean b) throws Exception { long id = longEvent.</description></item><item><title>Disruptor-生产者发布方式</title><link>https://greycode.top/posts/926f33f0-651d-471a-ad0c-b632fcce8c0f/</link><pubDate>Mon, 01 Mar 2021 09:57:58 +0000</pubDate><guid>https://greycode.top/posts/926f33f0-651d-471a-ad0c-b632fcce8c0f/</guid><description>旧版本API发布方式 import com.lmax.disruptor.RingBuffer; public class LongEventProducer{ private final RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer; public LongEventProducer(RingBuffer&amp;lt;LongEvent&amp;gt; ringBuffer){ this.ringBuffer = ringBuffer; } public void onData(ByteBuffer bb){ long sequence = ringBuffer.next(); // Grab the next sequence try{ LongEvent event = ringBuffer.get(sequence); // Get the entry in the Disruptor // for the sequence event.set(bb.getLong(0)); // Fill with data } finally{ ringBuffer.</description></item></channel></rss>