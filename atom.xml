<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>打工纪实</title>
  
  <subtitle>记录打工每一天</subtitle>
  <link href="https://greycode.top/atom.xml" rel="self"/>
  
  <link href="https://greycode.top/"/>
  <updated>2022-04-16T02:52:58.649Z</updated>
  <id>https://greycode.top/</id>
  
  <author>
    <name>ooooooh灰灰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】为什么 Web 3.0 很重要，你应该知道</title>
    <link href="https://greycode.top/archive/7F482D9706354A288702DCCB66C81BF2/"/>
    <id>https://greycode.top/archive/7F482D9706354A288702DCCB66C81BF2/</id>
    <published>2022-04-16T10:42:57.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://medium.com/@essentia1/why-the-web-3-0-matters-and-you-should-know-about-it-a5851d63c949">https://medium.com/@essentia1/why-the-web-3-0-matters-and-you-should-know-about-it-a5851d63c949</a></p></blockquote><p>Web 3.0 及其将给行业带来的巨大变化引起了很多关注，但很少有人真正知道它为什么会产生以及它会带来什么。要理解这一点，有必要回到过去并检查它的前身，Web 1.0 和 2.0。</p><p>就像中世纪一样，Web 1.0 直到尘埃落定才被命名。众所周知，“万维网”只是一组静态网站，包含大量信息，没有互动内容。连接意味着通过摇摇晃晃的调制解调器拨号并阻止房子里的任何人使用电话。它是 AOL 聊天室和 MSN Messenger、AltaVista 和 Ask Jeeves 的网络。它慢得令人发指。流媒体视频和音乐？忘了它。下载一首歌曲至少需要一天时间。</p><h2 id="然后是-2-0"><a href="#然后是-2-0" class="headerlink" title="然后是 2.0"></a>然后是 2.0</h2><p>令人毛骨悚然的调制解调器和无聊的接口的内存在很大程度上已经消失了。更快的互联网速度为互动内容铺平了道路，网络不再是为了观察，而是为了参与。全球信息共享催生了“社交媒体”时代。Youtube、维基百科、Flickr 和 Facebook 为无声者发声，并为志同道合的社区提供了蓬勃发展的途径。</p><p>发布这篇博文将花费我 30 秒的时间，这与设计师、开发人员和管理员共同努力进行简单的网站编辑相比，这是一个不可估量的改进。我们可以称之为“读写发布”时代——信息的传播就像这三个词一样简单。那么问题来了，web 2.0 很棒，哪里出了问题？</p><h2 id="信息就是金钱"><a href="#信息就是金钱" class="headerlink" title="信息就是金钱"></a>信息就是金钱</h2><p>联合国估计，从 2000 年到 2015 年，互联网用户从 7.38 亿增加到 32 亿。这是一个不可估量的数据，正如大型数字公司所意识到的那样，个人信息是一项非常有价值的资产。于是开始在集中式服务器中大量存储数据，亚马逊、Facebook 和 Twitter 是最大的托管方。人们为了这些服务的便利而牺牲了安全性；不管他们是否知道，他们的身份、浏览习惯、搜索和在线购物信息都被卖给出价最高的人。</p><h2 id="3-0-革命"><a href="#3-0-革命" class="headerlink" title="3.0 革命"></a>3.0 革命</h2><p>到了这个阶段，Web 2.0 的倡导者已经在构想继任者了。他们设想，下一个网络将怀旧地转向网络 1.0 的愿景：更“人性化”和更多隐私。与其将权力（和数据）集中在动机可疑的庞然大物手中，不如归还给合法所有者。</p><p>一个更公平、更透明的网络的愿景可以追溯到 2006 年左右，但当时还没有工具和技术来实现它。比特币还有三年的时间，它带来了分布式账本或区块链的概念，用于点对点数字存储。去中心化是一个想法。区块链是手段。现在我们有了所谓的以人为本的互联网。</p><h2 id="支持隐私、反垄断的网络"><a href="#支持隐私、反垄断的网络" class="headerlink" title="支持隐私、反垄断的网络"></a>支持隐私、反垄断的网络</h2><p>虽然 Web 2.0 使许多权力结构民主化并创造了<a href="https://medium.com/@matteozago/2017-was-the-year-of-blockchain-education-2018-is-the-year-of-adoption-bb862e0faae5">新的机会</a>，但经济引擎在很大程度上是私有化和垄断的。Facebook、Uber 和 AirBnB 已经为它们主导的公共基础设施创建了专用网络。Web 3.0 与此相反，它是关于通过开放网络共享价值的多个利润中心。</p><p>很容易想象在不久的将来，基于加密的手机、VPN、去中心化存储和加密货币钱包将广泛普及。未来不需要暂停或监视我们信息的网络和蜂窝提供商。如果我们要避免梦游进入黑镜式的隐私反乌托邦，这些就是我们需要的工具。Web 3.0 提供了许多优势：</p><p><strong>没有中心控制点：</strong>中间人被从等式中删除，像以太坊这样的区块链提供了一个无需信任的平台，其中的规则是牢不可破的，数据是完全加密的。Alphabet 和 Apple 将不再控制用户数据。任何政府或实体都没有能力扼杀网站和服务；没有一个人可以控制他人的身份。</p><p><strong>数据所有权：</strong>最终用户将重新获得对数据的完全控制权并拥有加密的安全性。然后可以在逐案和许可的基础上共享信息。目前，亚马逊和 Facebook 等大公司拥有服务器工厂，存储饮食偏好、收入、兴趣、信用卡详细信息等信息。这不仅仅是为了改善他们的服务——营销人员和广告商每年为数据支付数十亿美元。</p><p><strong>黑客和数据泄露的显着减少：</strong>由于数据将分散和分布，黑客将需要关闭整个网络，而三字母机构使用的国家支持的工具（如<a href="https://wikileaks.org/vault7/">Vault7</a>）将被淘汰。目前，互联网公司被迫交出用户数据或屈服于对整个数据库的审查。这些数据入侵不仅限于恐怖主义等重大安全威胁；<a href="http://fortune.com/2017/11/29/irs-coinbase/">2017 年，Coinbase 将美国国税局告上法庭，要求其查看超过 15,000 名客户的数据</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2022/04/16/1*h9aFk0xCbpRLMZq7LK-qLg-20220416104354829.png" alt="img"></p><p>到 2019 年，数据泄露的成本预计将<a href="https://www.juniperresearch.com/press/press-releases/cybercrime-cost-businesses-over-2trillion">超过 2.1 万亿美元</a>。</p><p>Coinbase 最终败诉的此案为政府实体接管数千名客户的财务铺平了道路，几乎没有正当理由证明这种入侵是正当的。不幸的是，这样的案例并不是孤立的。2013 年，安全电子邮件提供商 Lavabit 选择关闭而不是将其 SSL 密钥交给美国政府，以便监视爱德华·斯诺登。</p><p><strong>互操作性：</strong>应用程序将易于定制且与设备无关，能够在智能手机、电视、汽车、微波炉和智能传感器上运行。目前，应用程序是特定于操作系统的，并且通常仅限于单个操作系统。例如，许多 Android 加密货币钱包在 iO 上不可用，这让使用多种设备的消费者感到沮丧。它增加了负责发布软件多次迭代和更新的开发人员的费用。</p><p><strong>无许可区块链：</strong>任何人都可以创建地址并与网络交互。访问无许可链的能力怎么强调都不为过。用户不会因为地理、收入、性别、方向或许多其他社会学和人口学因素而被禁止。财富和其他数字资产可以在世界任何地方快速高效地跨境转移。</p><p><strong>不间断服务：</strong>账户暂停和分布式拒绝服务显着减少。因为没有单点故障，服务中断将是最小的。数据将存储在分布式节点上以确保冗余，并且多个备份将防止服务器故障或被占用。</p><h2 id="它将如何运作？"><a href="#它将如何运作？" class="headerlink" title="它将如何运作？"></a>它将如何运作？</h2><p><em>就像任何新兴技术一样，仍在完善中。为了访问去</em><a href="https://medium.com/@matteozago/web-2-0-is-broken-its-time-for-a-new-paradigm-shift-2a4b1fc2ff60"><em>中心化的网络</em></a>，人们只需要一个种子。这将是一个单一的资产，可以与 dApp 和其他服务进行交互。个人仍将使用网络浏览器访问互联网，并且在视觉上它将是 Web 2.0 用户友好的。</p><p><em>从表面上看，从 2.0 到 3.0 的学习曲线会很平缓。但在幕后，将用户与数字服务联系起来的框架却截然不同。交易是手动签名和验证的，以防止平台在没有正当理由的情况下窃取个人信息。网络用户会选择加入，而不是尝试——而且经常失败——选择退出。</em></p><ul><li><em>我们使用 Storj、Siacoin、Filecoin 或 IPFS 技术等服务来分发和存储文件，而不是 Google Drive 或 Dropbox。</em></li><li><em>我们有 Experty.io 等平台，而不是 Skype。</em></li><li><em>我们有状态，而不是 WhatsApp 和微信</em></li><li><em>取代 iOS 和 Android 等操作系统，Essentia.one 和 EOS 等框架提供了通往新网络的门户。</em></li><li><em>Akasha 或 Steemit 将扮演 Facebook 的角色，Brave 浏览器将充当 Chrome，而 Ethlance 可以接替 Upwork。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2022/04/16/1*M5JgwC4zOcX0LaQsLd1fkw-20220416104355351.png" alt="网络 2.0 &gt; 网络 3.0"></p><p><em>这些只是几个例子。随着 Web 3.0 的兴起，新平台将会出现，竞争水平不会受到垄断服务提供商的限制。三年后我们将使用的最好的 dApp 和去中心化服务可能只是开发人员眼中的微光。</em></p><p>概念是这样的：目前构成 Web 3.0 的去中心化应用程序、钱包、平台和其他数字资产是分散的。访问这些接口需要单独的种子、登录名和身份——很像现有的 Web 2.0。<a href="https://essentia.one/">Essentia.one</a>将通过一个种子将这些不同的平台链接在一起。因为这将作为可以与其所有者关联的加密密钥运行，所以 Essentia 将提供身份证明，但不会放弃任何不必要的个人身份。</p><p><em>正如 Web 2.0 并没有自动消灭 Web 1.0（仍然在互联网的某些部分周围积聚灰尘），向 3.0 的迁移需要时间并与现有的在线系统集成。车轮已经启动，火车已经离开车站。Web 3.0 是一场运动革命，我们已经过了不归路。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://medium.com/@essentia1/why-the-web-3-0-matters-and-you-should-know-about-it-a5851d63c949&quot;&gt;https://mediu</summary>
      
    
    
    
    <category term="web3.0" scheme="https://greycode.top/categories/web3-0/"/>
    
    
    <category term="web3.0" scheme="https://greycode.top/tags/web3-0/"/>
    
  </entry>
  
  <entry>
    <title>Redis是怎样通讯的？</title>
    <link href="https://greycode.top/archive/8B135153FD9D41DE928DF42F84AD1ECA/"/>
    <id>https://greycode.top/archive/8B135153FD9D41DE928DF42F84AD1ECA/</id>
    <published>2022-03-29T13:41:40.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>Redis 协议模型就是简单的请求-响应模型，和平常的 Http 协议有点类似。客户端发送 Redis 命令，然后服务端处理命令并返回结果给客户端。Redis 官方说这可能是最简单的网络协议模型了。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2022/04/15/image-20220415110028732.png" alt="image-20220415110028732"></p><p>有两种情况下不 不适用这个模型，一个是批量流水线命令，一个是发布&#x2F;订阅功能。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2022/04/15/image-20220415110051982.png" alt="image-20220415110051982"></p><h2 id="协议描述"><a href="#协议描述" class="headerlink" title="协议描述"></a>协议描述</h2><p>Redis 协议一般简单的分为 5 类数据结构，简单字符串、错误信息、数值、大字符串、数组。每种数据类型在第一个字节用不同的符号来区分：</p><ul><li>**简单字符串(Simple Strings)**：开头第一个符号为 <code>+</code>，对应 HEX 值为：<code>0x2b</code></li><li>**错误信息(Errors)**：第一个字节符号为 <code>-</code>，对应 HEX 值为：<code>0x2d</code></li><li>**数值(Integers)**：第一个字节符号为 <code>:</code>，对应 HEX 值为：<code>0x3a</code></li><li>**大字符串(Bulk Strings)**：第一个字节符号为 <code>$</code>，对应 HEX 值为：<code>0x24</code></li><li>**数组(Arrays)**：第一个字节符号为 <code>*</code>，对应 HEX 值为：<code>0x2a</code></li></ul><p>这 5 种数据类型可以组合起来使用，每种数据类型通过 <strong>CRLF</strong> 结尾，就是平常的 <code>\r\n</code>，对应的 HEX 值为：<code>0x0d,0x0a</code>。一般我们判断一种数据类型是否结束时，只要判断是否有 <code>\r</code> 出现就可以了。Redis 客户端和服务端之间就是通过这些规则来进行通信的。</p><h3 id="简单字符串"><a href="#简单字符串" class="headerlink" title="简单字符串"></a>简单字符串</h3><p>一般简单字符串用于返回 Redis 服务端的系统响应，如果要响应用户存储的数据时，一般会用大字符串(Bulk Strings)的数据类型来返回。</p><p>比如说客户端发送 set 命令新增一个 Key 来存储字符串，此时客户端就会返回 <code>+OK</code>。这种方式返回的数据不能有空格和换行，因为空格和换行表示该类型的数据结尾。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;<span class="built_in">set</span> name 灰灰</span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 服务端响应数据</span></span><br><span class="line">0000  2b 4f 4b 0d 0a                                     +OK··</span><br></pre></td></tr></table></figure><h3 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h3><p>当我们执行的命令发生错误时，Redis 服务端就会返回错误信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;incr name</span><br><span class="line"><span class="string">&quot;ERR value is not an integer or out of range&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 服务端响应数据</span></span><br><span class="line">0000  2d 45 52 52 20 76 61 6c  75 65 20 69 73 20 6e 6f   -ERR val ue is no</span><br><span class="line">0010  74 20 61 6e 20 69 6e 74  65 67 65 72 20 6f 72 20   t an int eger or </span><br><span class="line">0020  6f 75 74 20 6f 66 20 72  61 6e 67 65 0d 0a         out of r ange··</span><br></pre></td></tr></table></figure><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>返回数值的其中一种情况就是执行 <code>exists</code> 命令来判断某个 Key 存不存在，返回 1 表示存在，返回 0 表示不存在</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;exists name</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 服务端响应数据</span></span><br><span class="line">0000  3a 31 0d 0a                                        :1··</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">redis:0&gt;exists hui</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 服务端响应数据</span></span><br><span class="line">0000   3a 30 0d 0a                                       :0..</span><br></pre></td></tr></table></figure><h3 id="大字符串"><a href="#大字符串" class="headerlink" title="大字符串"></a>大字符串</h3><p>大字符串返回值有两部分组成，一部分是表示字符串长度的数据，一部分是字符串本身数据。它由 <code>$</code> 符号开头，后面跟着的是表示字符串长度的数据，<strong>该数值直接用字符串的形式表示</strong>，也就说读取该字节数据的时候，要用读取字符串数据的方式来读取。读取完后再转换为数值数据，然后再根据这个数值来读取相对应长度的字节数据。这样数据中就可以包含空格和换行了，因为是根据开头的长度数值来读取相对应的字节数据的，而不是通过判断 <code>\r\n</code> 符号来读取。</p><p>比如客户端获取前面设置的 Key 为 name 的数据：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;get name</span><br><span class="line"><span class="string">&quot;灰灰&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 服务端响应数据</span></span><br><span class="line">0000   24 36 0d 0a e7 81 b0 e7 81 b0 0d 0a               <span class="variable">$6</span>..........</span><br></pre></td></tr></table></figure><p>其中 <code>e7 81 b0 e7 81 b0</code> 就是 <code>灰灰</code> 字符的字节数据</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>当服务端返回数组数据时，它由 <code>*</code> 符号开头，后面紧跟着的是这个数值的长度，和大字符串的字节长度一样，该长度也是以字符串的形式返回。数组中的每个元素再通过相对应的数据类型来表示。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*2</span><br><span class="line">+value1</span><br><span class="line">+value2</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">*3</span><br><span class="line">:22</span><br><span class="line">:52</span><br><span class="line">:99</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然也可以表示嵌套数组</span></span><br><span class="line">*2</span><br><span class="line">*1</span><br><span class="line">:123</span><br><span class="line">*2</span><br><span class="line">:433</span><br><span class="line">:92</span><br></pre></td></tr></table></figure><p>比如客户端设置一个 list 数据，然后获取它</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;lpush mylist value1 value2</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 list</span></span><br><span class="line">redis:0&gt;lrange mylist 0 1</span><br><span class="line">[<span class="string">&quot;value2&quot;</span>,<span class="string">&quot;value1&quot;</span>]</span><br><span class="line"></span><br><span class="line">0000   2a 32 0d 0a 24 36 0d 0a 76 61 6c 75 65 32 0d 0a   *2..<span class="variable">$6</span>..value2..</span><br><span class="line">0010   24 36 0d 0a 76 61 6c 75 65 31 0d 0a               <span class="variable">$6</span>..value1..</span><br></pre></td></tr></table></figure><h2 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h2><p>当客户端发送命令给服务端时，客户端一般会把命令组装成上面的<strong>数组</strong>加<strong>大字符串</strong>的数据格式再发送给服务端。比如上面的我们发送一个简单的新增一个 Key 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;<span class="built_in">set</span> name 灰灰</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端发送给服务端端数据</span></span><br><span class="line">0000   2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d   *3..<span class="variable">$3</span>..<span class="built_in">set</span>..<span class="variable">$4</span>.</span><br><span class="line">0010   0a 6e 61 6d 65 0d 0a 24 36 0d 0a e7 81 b0 e7 81   .name..<span class="variable">$6</span>.......</span><br><span class="line">0020   b0 0d 0a                                          ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><p>Redis 一般常用的有 5 种数据类型，下面看看 5 种数据类型对应的客户端和服务端之间的数据是怎么交互的。</p><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;<span class="built_in">set</span> name greycode</span><br><span class="line"></span><br><span class="line">0000   2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d   *3..<span class="variable">$3</span>..<span class="built_in">set</span>..<span class="variable">$4</span>.</span><br><span class="line">0010   0a 6e 61 6d 65 0d 0a 24 38 0d 0a 67 72 65 79 63   .name..<span class="variable">$8</span>..greyc</span><br><span class="line">0020   6f 64 65 0d 0a                                    ode..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   2b 4f 4b 0d 0a                                    +OK..</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">redis:0&gt;get name</span><br><span class="line"></span><br><span class="line">0000   2a 32 0d 0a 24 33 0d 0a 67 65 74 0d 0a 24 34 0d   *2..<span class="variable">$3</span>..get..<span class="variable">$4</span>.</span><br><span class="line">0010   0a 6e 61 6d 65 0d 0a                              .name..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   24 38 0d 0a 67 72 65 79 63 6f 64 65 0d 0a         <span class="variable">$8</span>..greycode..</span><br></pre></td></tr></table></figure><h3 id="哈希表-Hash"><a href="#哈希表-Hash" class="headerlink" title="哈希表 Hash"></a>哈希表 Hash</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;hset myHash name huihui</span><br><span class="line"></span><br><span class="line">0000   2a 34 0d 0a 24 34 0d 0a 68 73 65 74 0d 0a 24 36   *4..<span class="variable">$4</span>..hset..<span class="variable">$6</span></span><br><span class="line">0010   0d 0a 6d 79 48 61 73 68 0d 0a 24 34 0d 0a 6e 61   ..myHash..<span class="variable">$4</span>..na</span><br><span class="line">0020   6d 65 0d 0a 24 36 0d 0a 68 75 69 68 75 69 0d 0a   me..<span class="variable">$6</span>..huihui..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   3a 31 0d 0a                                       :1..</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">redis:0&gt;hget myHash name</span><br><span class="line"></span><br><span class="line">0000   2a 33 0d 0a 24 34 0d 0a 68 67 65 74 0d 0a 24 36   *3..<span class="variable">$4</span>..hget..<span class="variable">$6</span></span><br><span class="line">0010   0d 0a 6d 79 48 61 73 68 0d 0a 24 34 0d 0a 6e 61   ..myHash..<span class="variable">$4</span>..na</span><br><span class="line">0020   6d 65 0d 0a                                       me..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   24 36 0d 0a 68 75 69 68 75 69 0d 0a               <span class="variable">$6</span>..huihui..</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">redis:0&gt;hgetall myHash</span><br><span class="line"></span><br><span class="line">0000   2a 32 0d 0a 24 37 0d 0a 68 67 65 74 61 6c 6c 0d   *2..<span class="variable">$7</span>..hgetall.</span><br><span class="line">0010   0a 24 36 0d 0a 6d 79 48 61 73 68 0d 0a            .<span class="variable">$6</span>..myHash..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   2a 32 0d 0a 24 34 0d 0a 6e 61 6d 65 0d 0a 24 36   *2..<span class="variable">$4</span>..name..<span class="variable">$6</span></span><br><span class="line">0010   0d 0a 68 75 69 68 75 69 0d 0a                     ..huihui..</span><br></pre></td></tr></table></figure><h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;lpush lists huihui greycode</span><br><span class="line"></span><br><span class="line">0000   2a 34 0d 0a 24 35 0d 0a 6c 70 75 73 68 0d 0a 24   *4..<span class="variable">$5</span>..lpush..$</span><br><span class="line">0010   35 0d 0a 6c 69 73 74 73 0d 0a 24 36 0d 0a 68 75   5..lists..<span class="variable">$6</span>..hu</span><br><span class="line">0020   69 68 75 69 0d 0a 24 38 0d 0a 67 72 65 79 63 6f   ihui..<span class="variable">$8</span>..greyco</span><br><span class="line">0030   64 65 0d 0a                                       de..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   3a 32 0d 0a                                       :2..</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">redis:0&gt;lrange lists 0 1</span><br><span class="line"></span><br><span class="line">0000   2a 34 0d 0a 24 36 0d 0a 6c 72 61 6e 67 65 0d 0a   *4..<span class="variable">$6</span>..lrange..</span><br><span class="line">0010   24 35 0d 0a 6c 69 73 74 73 0d 0a 24 31 0d 0a 30   <span class="variable">$5</span>..lists..<span class="variable">$1</span>..0</span><br><span class="line">0020   0d 0a 24 31 0d 0a 31 0d 0a                        ..<span class="variable">$1</span>..1..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   2a 32 0d 0a 24 38 0d 0a 67 72 65 79 63 6f 64 65   *2..<span class="variable">$8</span>..greycode</span><br><span class="line">0010   0d 0a 24 36 0d 0a 68 75 69 68 75 69 0d 0a         ..<span class="variable">$6</span>..huihui..</span><br></pre></td></tr></table></figure><h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;sadd myset hello hi</span><br><span class="line"></span><br><span class="line">0000   2a 34 0d 0a 24 34 0d 0a 73 61 64 64 0d 0a 24 35   *4..<span class="variable">$4</span>..sadd..<span class="variable">$5</span></span><br><span class="line">0010   0d 0a 6d 79 73 65 74 0d 0a 24 35 0d 0a 68 65 6c   ..myset..<span class="variable">$5</span>..hel</span><br><span class="line">0020   6c 6f 0d 0a 24 32 0d 0a 68 69 0d 0a               lo..<span class="variable">$2</span>..hi..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   3a 32 0d 0a                                       :2..</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">redis:0&gt;smembers myset</span><br><span class="line"></span><br><span class="line">0000   2a 32 0d 0a 24 38 0d 0a 73 6d 65 6d 62 65 72 73   *2..<span class="variable">$8</span>..smembers</span><br><span class="line">0010   0d 0a 24 35 0d 0a 6d 79 73 65 74 0d 0a            ..<span class="variable">$5</span>..myset..</span><br><span class="line"></span><br><span class="line"><span class="comment">#响应</span></span><br><span class="line">0000   2a 32 0d 0a 24 35 0d 0a 68 65 6c 6c 6f 0d 0a 24   *2..<span class="variable">$5</span>..hello..$</span><br><span class="line">0010   32 0d 0a 68 69 0d 0a                              2..hi..</span><br></pre></td></tr></table></figure><h3 id="有序集合-ZSet"><a href="#有序集合-ZSet" class="headerlink" title="有序集合 ZSet"></a>有序集合 ZSet</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis:0&gt;zadd myZset 1 hello 2 world</span><br><span class="line"></span><br><span class="line">0000   2a 36 0d 0a 24 34 0d 0a 7a 61 64 64 0d 0a 24 36   *6..<span class="variable">$4</span>..zadd..<span class="variable">$6</span></span><br><span class="line">0010   0d 0a 6d 79 5a 73 65 74 0d 0a 24 31 0d 0a 31 0d   ..myZset..<span class="variable">$1</span>..1.</span><br><span class="line">0020   0a 24 35 0d 0a 68 65 6c 6c 6f 0d 0a 24 31 0d 0a   .<span class="variable">$5</span>..hello..<span class="variable">$1</span>..</span><br><span class="line">0030   32 0d 0a 24 35 0d 0a 77 6f 72 6c 64 0d 0a         2..<span class="variable">$5</span>..world..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   3a 32 0d 0a                                       :2..</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">redis:0&gt;zrange myset 0 -1</span><br><span class="line"></span><br><span class="line">0000   2a 34 0d 0a 24 36 0d 0a 7a 72 61 6e 67 65 0d 0a   *4..<span class="variable">$6</span>..zrange..</span><br><span class="line">0010   24 36 0d 0a 6d 79 5a 73 65 74 0d 0a 24 31 0d 0a   <span class="variable">$6</span>..myZset..<span class="variable">$1</span>..</span><br><span class="line">0020   30 0d 0a 24 32 0d 0a 2d 31 0d 0a                  0..<span class="variable">$2</span>..-1..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">0000   2a 32 0d 0a 24 35 0d 0a 68 65 6c 6c 6f 0d 0a 24   *2..<span class="variable">$5</span>..hello..$</span><br><span class="line">0010   35 0d 0a 77 6f 72 6c 64 0d 0a                     5..world..</span><br></pre></td></tr></table></figure><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>Redis 执行 Pipeline 命令，可以一次用一个数据包发送多条命令，然后服务端在把所有命令的执行结果打包成一个数据包返回给客户端，这样在执行大量命令的时候可以减少系统开销。比如我们要执行 <code>set num 998</code> 和 <code>incr num</code> 这两条命令，那么我们就可以把这两条命令分别组装然后拼接在一起发送给服务端。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000   2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 33 0d   *3..<span class="variable">$3</span>..<span class="built_in">set</span>..<span class="variable">$3</span>.</span><br><span class="line">0010   0a 6e 75 6d 0d 0a 24 33 0d 0a 39 39 38 0d 0a 2a   .num..<span class="variable">$3</span>..998..*</span><br><span class="line">0020   32 0d 0a 24 34 0d 0a 69 6e 63 72 0d 0a 24 33 0d   2..<span class="variable">$4</span>..incr..<span class="variable">$3</span>.</span><br><span class="line">0030   0a 6e 75 6d 0d 0a                                 .num..</span><br></pre></td></tr></table></figure><p>服务端接收到数据包后，处理每条命令，然后把结果打包返回。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0000   2b 4f 4b 0d 0a 3a 39 39 39 0d 0a                  +OK..:999..</span><br></pre></td></tr></table></figure><p>其中， <code>set num 998</code>  命令的结果为：OK</p><p><code>incr num</code>  的结果为：999</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>了解了以上交互协议的规则后，我们就可以自己手写一个 Redis 客户端来与 Redis 服务器通讯了。</p><p>完整代码地址：<a href="https://gist.github.com/greycodee/4a102aa9ae689aea1874b1fe06190192">https://gist.github.com/greycodee/4a102aa9ae689aea1874b1fe06190192</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模型&quot;&gt;&lt;a href=&quot;#模型&quot; class=&quot;headerlink&quot; title=&quot;模型&quot;&gt;&lt;/a&gt;模型&lt;/h2&gt;&lt;p&gt;Redis 协议模型就是简单的请求-响应模型，和平常的 Http 协议有点类似。客户端发送 Redis 命令，然后服务端处理命令并返回结果给</summary>
      
    
    
    
    <category term="协议" scheme="https://greycode.top/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Redis" scheme="https://greycode.top/tags/Redis/"/>
    
    <category term="协议" scheme="https://greycode.top/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL是怎样通讯的？</title>
    <link href="https://greycode.top/archive/2852F14D7D13471798CE28C544741E89/"/>
    <id>https://greycode.top/archive/2852F14D7D13471798CE28C544741E89/</id>
    <published>2022-03-27T23:51:51.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们平常使用数据库的场景一般是程序里面代码直接连接使用，然后进行 CRUD 操作。或者使用有 GUI 界面的数据库软件来手动操作数据库， 这类软件有 DataGrip、Navicat等等…。平常很少关心它们的底层数据交互是怎么样的，相信你看了这篇文章一定能有大概的了解。本篇文章的代码使用 Go 语言来实现 MySQL 的协议。</p><h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><p>MySQL 协议一般分为两个阶段，一个是连接阶段，一个是命令阶段。<br>连接阶段主要是客户端和服务端进行相互认证的阶段，就像我们平常登陆某个网站的一个操作。<br>命令阶段主要是客户端向服务端进行的一些指令的发送，然后服务端处理指令并返回结果的一个过程。<br>在客户端和服务端发送的数据包中，前 3 个字节表示这个数据包的大小，所以这里就有一个问题，就是它有一个大小的限制，数据包大小不能超过16777215 ($2^{24}-1$) bytes，也就是 16M 大小（16进制表示：ff ff ff，刚刚 3 个字节）。这就会有三种情况出现，一种是数据包小于 16M，一种是等于，一种是大于。所以在 MySQL 协议中是这样处理的：</p><ul><li>小于 16M：发送一个数据包就可以了</li><li>等于 16M：发送两个数据包，第二个包为空包</li><li>大于 16M：发送多个数据包，每个数据包大小最大为 16M，当最后一个数据包等于 16M 时，再多发送一个空数据包</li></ul><p>每个数据包中的第 4 个字节表示这个数据包的序号ID，这个 ID 在不同阶段会递增，比如在连接阶段，这个 ID 会随着包的数量而递增，当连接阶段完成后进入命令阶段，这个 ID 又会从 0 开始递增，直到这个命令的生命周期结束。</p><h2 id="初始握手包"><a href="#初始握手包" class="headerlink" title="初始握手包"></a>初始握手包</h2><p>当客户端进行尝试使用 TCP 连接 MySQL 服务端时，服务端就会响应一个初始的握手包，这个握手包有 V9、V10 两个版本。不过现在一般用的都是 V10 版本，如果 MySQL 的版本在 3.21.0 之前，那么服务端响应的是 V9 版本的初始握手包。本篇文章就讲讲现在常用的 V10 版本的初始握手包。</p><p>我们可以使用以下代码来尝试连接我们本地的 MySQL 服务:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;127.0.0.1:3306&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">err := conn.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;(conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运作程序后，服务端就会响应一个初始握手包给我们，那么怎么清楚明了的查看这个数据包呢？此时我们可以用 Wireshark 这个软件来查看 MySQL 服务端返回的数据包<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9eef1979e07465bb18236a94b2e3ba8~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"><br>可以看到前 4 个字节为 16 进制的数据: 4e 00 00 00 ，表示了这个数据包大小为 78 字节，序号 ID 为 0。具体的字段字节大小和描述如下表示：</p><table><thead><tr><th>字段名</th><th>字节数据长度(byte)</th><th>描述</th></tr></thead><tbody><tr><td>Protocol</td><td>1</td><td>初始握手包协议版本，可以根据这个字节数据来判断握手包的协议版本，然后按不同版本来处理接下来的数据</td></tr><tr><td>Version</td><td>直到遇到字节数据为 0 的时候停止</td><td>MySQL 服务端版本描述字符串</td></tr><tr><td>Thread ID</td><td>4</td><td>连接 ID</td></tr><tr><td>Slat（第一段）</td><td>8</td><td>用于处理后续客户端的密码加密</td></tr><tr><td>filler</td><td>1</td><td>填充一个字节，默认为 0</td></tr><tr><td>Service Capability（Low）</td><td>2</td><td>服务端能力标志，一共有 4 个字节，这里表示的是低 2 位字节的数据</td></tr><tr><td>Server Language</td><td>1</td><td>服务端字符编码</td></tr><tr><td>Server Status</td><td>2</td><td>服务端状态</td></tr><tr><td>Service Capability（Upper）</td><td>2</td><td>服务端能力标志，这里表示的是高 2 位字节的数据</td></tr><tr><td>Authentication Plugin Length</td><td>1</td><td>身份验证插件长度</td></tr><tr><td>Unused</td><td>10</td><td>预留的 10 个字节数据，默认全部为 0</td></tr><tr><td>Slat（第二段）</td><td>计算公式：MAX(13, 身份验证插件长度 - 8)</td><td>用于处理后续客户端的密码加密</td></tr><tr><td>Authentication Plugin</td><td>直到遇到字节数据为 0 的时候停止</td><td>身份验证插件</td></tr></tbody></table><p>这个初始握手包里包含了很多的数据，在后续的整个连接阶段需要用到里面的大部分数据。</p><h2 id="能力标志"><a href="#能力标志" class="headerlink" title="能力标志"></a>能力标志</h2><p>上面服务端响应端初始握手包中包含了一个能力标志，这个能力标志一共有 4 个字节来表示，我们知道 1 个字节有 8 个 bit，所以 4 个字节一共有 32 个 bit，其中除了最高的 7 个 bit，另外的每一个 bit 都代表着一个能力标志的状态（0 为不支持，1 为支持）,就像下面这样表示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Capabilities 字节数据中的低 2 位</span><br><span class="line">Server Capabilities: 0xffff</span><br><span class="line">.... .... .... ...1 = Long Password: Set</span><br><span class="line">.... .... .... ..1. = Found Rows: Set</span><br><span class="line">.... .... .... .1.. = Long Column Flags: Set</span><br><span class="line">.... .... .... 1... = Connect With Database: Set</span><br><span class="line">.... .... ...1 .... = Don&#x27;t Allow database.table.column: Set</span><br><span class="line">.... .... ..1. .... = Can use compression protocol: Set</span><br><span class="line">.... .... .1.. .... = ODBC Client: Set</span><br><span class="line">.... .... 1... .... = Can Use LOAD DATA LOCAL: Set</span><br><span class="line">.... ...1 .... .... = Ignore Spaces before &#x27;(&#x27;: Set</span><br><span class="line">.... ..1. .... .... = Speaks 4.1 protocol (new flag): Set</span><br><span class="line">.... .1.. .... .... = Interactive Client: Set</span><br><span class="line">.... 1... .... .... = Switch to SSL after handshake: Set</span><br><span class="line">...1 .... .... .... = Ignore sigpipes: Set</span><br><span class="line">..1. .... .... .... = Knows about transactions: Set</span><br><span class="line">.1.. .... .... .... = Speaks 4.1 protocol (old flag): Set</span><br><span class="line">1... .... .... .... = Can do 4.1 authentication: Set</span><br><span class="line"></span><br><span class="line"># Capabilities 字节数据中的高 2 位</span><br><span class="line">Extended Server Capabilities: 0xc1ff</span><br><span class="line">.... .... .... ...1 = Multiple statements: Set</span><br><span class="line">.... .... .... ..1. = Multiple results: Set</span><br><span class="line">.... .... .... .1.. = PS Multiple results: Set</span><br><span class="line">.... .... .... 1... = Plugin Auth: Set</span><br><span class="line">.... .... ...1 .... = Connect attrs: Set</span><br><span class="line">.... .... ..1. .... = Plugin Auth LENENC Client Data: Set</span><br><span class="line">.... .... .1.. .... = Client can handle expired passwords: Set</span><br><span class="line">.... .... 1... .... = Session variable tracking: Set</span><br><span class="line">.... ...1 .... .... = Deprecate EOF: Set</span><br><span class="line">1100 000. .... .... = Unused: 0x60</span><br></pre></td></tr></table></figure><p>除了服务端响应的初始握手包会返回这个能力标志，后续我们发送给服务端的 <strong>HandshakeResponse</strong> 数据包中也包含这个能力标志数据，那么我们该怎么发送这个能力标志数据呢？官方给出力各个能力的值，如下表：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>Capability Flags</strong></th><th><strong>值【16进制】</strong></th></tr></thead><tbody><tr><td>1</td><td>CLIENT_LONG_PASSWORD</td><td>0x1</td></tr><tr><td>2</td><td>CLIENT_FOUND_ROWS</td><td>0x2</td></tr><tr><td>3</td><td>CLIENT_LONG_FLAG</td><td>0x4</td></tr><tr><td>4</td><td>CLIENT_CONNECT_WITH_DB</td><td>0x8</td></tr><tr><td>5</td><td>CLIENT_NO_SCHEMA</td><td>0x10</td></tr><tr><td>6</td><td>CLIENT_COMPRESS</td><td>0x20</td></tr><tr><td>7</td><td>CLIENT_ODBC</td><td>0x40</td></tr><tr><td>8</td><td>CLIENT_LOCAL_FILES</td><td>0x80</td></tr><tr><td>9</td><td>CLIENT_IGNORE_SPACE</td><td>0x100</td></tr><tr><td>10</td><td>CLIENT_PROTOCOL_41</td><td>0x200</td></tr><tr><td>11</td><td>CLIENT_INTERACTIVE</td><td>0x400</td></tr><tr><td>12</td><td>CLIENT_SSL</td><td>0x800</td></tr><tr><td>13</td><td>CLIENT_IGNORE_SIGPIPE</td><td>0x1000</td></tr><tr><td>14</td><td>CLIENT_TRANSACTIONS</td><td>0x2000</td></tr><tr><td>15</td><td>CLIENT_RESERVED</td><td>0x4000</td></tr><tr><td>16</td><td>CLIENT_SECURE_CONNECTION</td><td>0x8000</td></tr><tr><td>17</td><td>CLIENT_MULTI_STATEMENTS</td><td>0x10000</td></tr><tr><td>18</td><td>CLIENT_MULTI_RESULTS</td><td>0x20000</td></tr><tr><td>19</td><td>CLIENT_PS_MULTI_RESULTS</td><td>0x40000</td></tr><tr><td>20</td><td>CLIENT_PLUGIN_AUTH</td><td>0x80000</td></tr><tr><td>21</td><td>CLIENT_CONNECT_ATTRS</td><td>0x100000</td></tr><tr><td>22</td><td>CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA</td><td>0x200000</td></tr><tr><td>23</td><td>CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS</td><td>0x400000</td></tr><tr><td>24</td><td>CLIENT_SESSION_TRACK</td><td>0x800000</td></tr><tr><td>25</td><td>CLIENT_DEPRECATE_EOF</td><td>0x1000000</td></tr></tbody></table><p>当我们要发送客户端支持的能力标志时，只要把所有支持的能力标志的值相加，然后转换为 4 字节大小的数据。<br>例如我们要发送个给服务端说明我们支持 <strong>CLIENT_PROTOCOL_41</strong> 这个能力，那么我们就可以把这个 16 进制的值转换为 4 个字节的数据来表示，转换后的数据为：[0 0 16 0]。HEX 表示法为：[00 00 10 00]</p><blockquote><p>注意：上面转换的字节数据为小端数据，这方面端知识具体可以查询字节序的大小端</p></blockquote><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>初始握手包还有一个字节表示了支持的字符编码，后续我们响应的 <strong>HandshakeResponse</strong> 数据包中也要发送客户端支持的字符编码，相对应的字符编码对应的 ID 如下表，当我们支持什么字符编码时，只要发送对应编码的 ID<br>就可以了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+--------------------+---------------------+-----+</span><br><span class="line">| CHARACTER_SET_NAME | COLLATION_NAME      | ID  |</span><br><span class="line">+--------------------+---------------------+-----+</span><br><span class="line">| big5               | big5_chinese_ci     |   <span class="number">1</span> |</span><br><span class="line">| dec8               | dec8_swedish_ci     |   <span class="number">3</span> |</span><br><span class="line">| cp850              | cp850_general_ci    |   <span class="number">4</span> |</span><br><span class="line">| hp8                | hp8_english_ci      |   <span class="number">6</span> |</span><br><span class="line">| koi8r              | koi8r_general_ci    |   <span class="number">7</span> |</span><br><span class="line">| latin1             | latin1_swedish_ci   |   <span class="number">8</span> |</span><br><span class="line">| latin2             | latin2_general_ci   |   <span class="number">9</span> |</span><br><span class="line">| swe7               | swe7_swedish_ci     |  <span class="number">10</span> |</span><br><span class="line">| ascii              | ascii_general_ci    |  <span class="number">11</span> |</span><br><span class="line">| ujis               | ujis_japanese_ci    |  <span class="number">12</span> |</span><br><span class="line">| sjis               | sjis_japanese_ci    |  <span class="number">13</span> |</span><br><span class="line">| hebrew             | hebrew_general_ci   |  <span class="number">16</span> |</span><br><span class="line">| tis620             | tis620_thai_ci      |  <span class="number">18</span> |</span><br><span class="line">| euckr              | euckr_korean_ci     |  <span class="number">19</span> |</span><br><span class="line">| koi8u              | koi8u_general_ci    |  <span class="number">22</span> |</span><br><span class="line">| gb2312             | gb2312_chinese_ci   |  <span class="number">24</span> |</span><br><span class="line">| greek              | greek_general_ci    |  <span class="number">25</span> |</span><br><span class="line">| cp1250             | cp1250_general_ci   |  <span class="number">26</span> |</span><br><span class="line">| gbk                | gbk_chinese_ci      |  <span class="number">28</span> |</span><br><span class="line">| latin5             | latin5_turkish_ci   |  <span class="number">30</span> |</span><br><span class="line">| armscii8           | armscii8_general_ci |  <span class="number">32</span> |</span><br><span class="line">| utf8               | utf8_general_ci     |  <span class="number">33</span> |</span><br><span class="line">| ucs2               | ucs2_general_ci     |  <span class="number">35</span> |</span><br><span class="line">| cp866              | cp866_general_ci    |  <span class="number">36</span> |</span><br><span class="line">| keybcs2            | keybcs2_general_ci  |  <span class="number">37</span> |</span><br><span class="line">| macce              | macce_general_ci    |  <span class="number">38</span> |</span><br><span class="line">| macroman           | macroman_general_ci |  <span class="number">39</span> |</span><br><span class="line">| cp852              | cp852_general_ci    |  <span class="number">40</span> |</span><br><span class="line">| latin7             | latin7_general_ci   |  <span class="number">41</span> |</span><br><span class="line">| cp1251             | cp1251_general_ci   |  <span class="number">51</span> |</span><br><span class="line">| utf16              | utf16_general_ci    |  <span class="number">54</span> |</span><br><span class="line">| utf16le            | utf16le_general_ci  |  <span class="number">56</span> |</span><br><span class="line">| cp1256             | cp1256_general_ci   |  <span class="number">57</span> |</span><br><span class="line">| cp1257             | cp1257_general_ci   |  <span class="number">59</span> |</span><br><span class="line">| utf32              | utf32_general_ci    |  <span class="number">60</span> |</span><br><span class="line">| binary             | binary              |  <span class="number">63</span> |</span><br><span class="line">| geostd8            | geostd8_general_ci  |  <span class="number">92</span> |</span><br><span class="line">| cp932              | cp932_japanese_ci   |  <span class="number">95</span> |</span><br><span class="line">| eucjpms            | eucjpms_japanese_ci |  <span class="number">97</span> |</span><br><span class="line">| gb18030            | gb18030_chinese_ci  | <span class="number">248</span> |</span><br><span class="line">| utf8mb4            | utf8mb4_0900_ai_ci  | <span class="number">255</span> |</span><br><span class="line">+--------------------+---------------------+-----+</span><br></pre></td></tr></table></figure><h2 id="客户端握手响应包（HandshakeResponse）"><a href="#客户端握手响应包（HandshakeResponse）" class="headerlink" title="客户端握手响应包（HandshakeResponse）"></a>客户端握手响应包（HandshakeResponse）</h2><p>客户端和 MySQL 服务端进行数据交互时，有明文数据交互和SSL加密数据交互，这里贴一张 MySQL 官网给出的一张图，这张图大致的描述了客户端和服务端连接的流程<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e65f83b1bcc4b5296d913bf0ac830b1~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"><br>本篇文章就讲下简单的明文连接，不管是明文连接和加密连接，客户端都必须返回 <strong>HandshakeResponse</strong> 这个数据包给服务端。<br>这个数据包也有两个版本，一个是 <strong>HandshakeResponse41</strong>，另一个是 <strong>HandshakeResponse320</strong>。现在一般都是用 <strong>HandshakeResponse41</strong> 这个版本的数据包。那么服务端要怎么知道客户端发送的数据包到底是什么版本呢？<br>这个就要用到上面的 <strong>CLIENT_PROTOCOL_41</strong> 这个能力标志了，服务端只要解析客户端发来的 <strong>HandshakeResponse</strong> 数据包中的 Capability Flags 数据中是否支持 <strong>CLIENT_PROTOCOL_41</strong> 这个能力，来判断客户端握手响应包的版本。当 <strong>CLIENT_PROTOCOL_41</strong> 这个能力为支持状态，说明版本是 <strong>HandshakeResponse41</strong>，否则就是 <strong>HandshakeResponse320</strong>。</p><h3 id="HandshakeResponse41"><a href="#HandshakeResponse41" class="headerlink" title="HandshakeResponse41"></a>HandshakeResponse41</h3><p>现在常用的就是 <strong>HandshakeResponse41</strong> 这个握手响应包，本篇文章就讲一讲这个握手响应包吧。这个包的描述如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>              capability flags, CLIENT_PROTOCOL_41 always set</span><br><span class="line"><span class="number">4</span>              max-packet size</span><br><span class="line"><span class="number">1</span>              character set</span><br><span class="line">string[<span class="number">23</span>]   <span class="built_in">reserved</span> (all [<span class="number">0</span>])</span><br><span class="line">string[NUL]    username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA &#123;</span><br><span class="line">  <span class="comment">// 如果支持 CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA 标志就返回这些数据</span></span><br><span class="line">  lenenc-<span class="type">int</span>     length of auth-response</span><br><span class="line">  string[n]      auth-response</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> capabilities &amp; CLIENT_SECURE_CONNECTION &#123;</span><br><span class="line">  <span class="comment">// 如果支持 CLIENT_SECURE_CONNECTION 标志就返回这些数据</span></span><br><span class="line">  <span class="number">1</span>              length of auth-response</span><br><span class="line">  string[n]      auth-response</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 否则就返回这个数据</span></span><br><span class="line">  string[NUL]    auth-response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_CONNECT_WITH_DB &#123;</span><br><span class="line">  <span class="comment">// 如果支持 CLIENT_CONNECT_WITH_DB 标志就返回这些数据</span></span><br><span class="line">  string[NUL]    database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_PLUGIN_AUTH &#123;</span><br><span class="line">  <span class="comment">// 如果支持 CLIENT_PLUGIN_AUTH 标志就返回这些数据</span></span><br><span class="line">  string[NUL]    auth plugin name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_CONNECT_ATTRS &#123;</span><br><span class="line">  <span class="comment">// 如果支持 CLIENT_CONNECT_ATTRS 标志就返回这些数据</span></span><br><span class="line">  lenenc-<span class="type">int</span>     length of all key-values</span><br><span class="line">  lenenc-str     key</span><br><span class="line">  lenenc-str     value</span><br><span class="line">  <span class="keyword">if</span>-more data in <span class="string">&#x27;length of all key-values&#x27;</span>, more keys <span class="keyword">and</span> value pairs</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>capability_flags</strong> – 客户端的能力标志，占用 4 个字节</li><li><strong>max_packet_size</strong>  – 客户端要发送到服务器的命令包的最大大小，占用 4 个字节</li><li><strong>character_set</strong> - 连接的默认字符集，占用 1 个字节</li><li>username – 客户端要登录的 SQL 帐户的名称 – 此字符串应使用character set字段指示的字符集进行编码。</li><li><strong>auth-response</strong>  –由 auth plugin name 字段指示的 <a href="https://dev.mysql.com/doc/internals/en/authentication-method.html">Authentication Method</a> 生成的加密的身份验证响应数据。</li><li><strong>database</strong>  – 用于连接的初始数据库 – 此字符串应使用 character set字段指示的字符集进行编码。</li><li>auth plugin name  – 客户端用此加密方法加密密码然后赋值给 auth-response 返回给服务端<h3 id="密码加密方式"><a href="#密码加密方式" class="headerlink" title="密码加密方式"></a>密码加密方式</h3>客户端传输给服务端的 MySQL 账户的密码加密方式采用插件的形式，就是 auth plugin name 这个字段的数据，一般支持以下几种加密方式</li></ul><table><thead><tr><th><strong>名称</strong></th><th><strong>Auth Plugin Name</strong></th><th><strong>能力标志</strong></th></tr></thead><tbody><tr><td>旧密码认证</td><td>mysql_old_password</td><td>不能使用，无能力标志</td></tr><tr><td>安全密码认证</td><td>mysql_native_password</td><td><a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_SECURE_CONNECTION">CLIENT_SECURE_CONNECTION</a></td></tr><tr><td>明文认证</td><td>mysql_clear_password</td><td><a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_PLUGIN_AUTH">CLIENT_PLUGIN_AUTH</a></td></tr><tr><td>Windows 原生身份验证</td><td>authentication_windows_client</td><td><a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_PLUGIN_AUTH">CLIENT_PLUGIN_AUTH</a></td></tr><tr><td>SHA256</td><td>sha256_password</td><td><a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_PLUGIN_AUTH">CLIENT_PLUGIN_AUTH</a></td></tr></tbody></table><p>现在一般常用的是安全密码认证，就是 <strong>Auth Plugin Name</strong> 为 mysql_native_password 的认证加密方式。这个方法的加密方式如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHA1( password ) XOR SHA1( <span class="string">&quot;20-bytes random data from server&quot;</span> &lt;concat&gt; SHA1( SHA1( password ) ) )</span><br></pre></td></tr></table></figure><p>它先对明文密码进行一次 SHA1 的散列运算生成密码 1，然后再将服务端初始握手包中的 20 位 Slat 数据和对明文密码进行两次 SHA1 散列的结果进行连接，然后对连接的结果再进行一次散列运算生成密码 2，最后密码 1 和密码 2 进行异或运算，得到来最终发送给服务端的数据。</p><h2 id="响应数据包"><a href="#响应数据包" class="headerlink" title="响应数据包"></a>响应数据包</h2><p>当我们发送响应握手包 <strong>HandshakeResponse</strong> 后，服务端就会返回一个通用的响应包给我们，这个响应包可以是以下其中一个：</p><ul><li>OK_Packet</li><li>ERR_Packet</li><li>EOF_Packet</li></ul><p>那么我们要怎么区分这三个包呢？区分的关键在于包的第一个字节的数据，如果第一个字节数据为 0x00，则代表这是一个 OK_Packet 。如果第一个字节数据为 0xff，则表示这是一个 ERR_Packet。如果第一个字节为 0xfe，则代表这是一个 EOF_Packet。<br>从 MySQL 5.7.5 开始，OK_Packet 包也用于指示 EOF_Packet，并且不推荐使用 EOF_Packet 包。为了确保 MySQL 的旧版本（5.7.5 之前）和新版本（5.7.5 及更高版本）之间的向后兼容性，新客户端会向服务端该送 <a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_DEPRECATE_EOF">CLIENT_DEPRECATE_EOF</a> 能力标志。如果没有传送这个能力标志，服务端返回端数据结果集中还是会以 EOF_Packet 包结尾，如果传送了这个能力标志的话，服务端返回端结果集中会以 OK_Packet 包结尾，并且第一个字节数据会是 0xfe。<br>那么我们怎么区分新版 OK_Packet 包在什么时候代表 OK_Packet，在什么时候代表 EOF_Packet 呢？主要可以通过以下几点来判断：</p><ul><li>一个是判断客户端刚才是否传送了 <a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_DEPRECATE_EOF">CLIENT_DEPRECATE_EOF</a> 能力标志</li><li>OK_Packet: 第一个字节数据为 0x00，且数据包长度 &gt; 7</li><li>EOF_Packet: 第一个字节数据为 0xfe，且数据包长度 &lt; 9<h3 id="OK-Packet-格式"><a href="#OK-Packet-格式" class="headerlink" title="OK_Packet 格式"></a>OK_Packet 格式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&lt;<span class="number">1</span>&gt;header[<span class="number">00</span>] <span class="keyword">or</span> [fe] the OK packet header</span><br><span class="line"><span class="type">int</span>&lt;lenenc&gt;affected_rows受影响行数</span><br><span class="line"><span class="type">int</span>&lt;lenenc&gt;last_insert_id最后插入 ID</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_PROTOCOL_41 &#123;</span><br><span class="line">    <span class="type">int</span>&lt;<span class="number">2</span>&gt;status_flags状态标志</span><br><span class="line">    <span class="type">int</span>&lt;<span class="number">2</span>&gt;warnings警告数</span><br><span class="line">&#125; elseif capabilities &amp; CLIENT_TRANSACTIONS &#123;</span><br><span class="line">    <span class="type">int</span>&lt;<span class="number">2</span>&gt;status_flagsStatus Flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_SESSION_TRACK &#123;</span><br><span class="line">    string&lt;lenenc&gt;info人类可读的状态信息</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> status_flags &amp; SERVER_SESSION_STATE_CHANGED &#123;</span><br><span class="line">        string&lt;lenenc&gt;session_state_changes会话状态信息</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    string&lt;EOF&gt;info人类可读的状态信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ERR-Packet-格式"><a href="#ERR-Packet-格式" class="headerlink" title="ERR_Packet 格式"></a>ERR_Packet 格式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&lt;<span class="number">1</span>&gt;header[ff] header of the ERR packet</span><br><span class="line"><span class="type">int</span>&lt;<span class="number">2</span>&gt;error_code错误代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_PROTOCOL_41 &#123;</span><br><span class="line">  string&lt;<span class="number">1</span>&gt;sql_state_markerSQL 状态的标记</span><br><span class="line">  string&lt;<span class="number">5</span>&gt;sql_stateSQL 状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&lt;EOF&gt;error_message人类可读的错误信息</span><br></pre></td></tr></table></figure><h3 id="EOF-Packet-格式"><a href="#EOF-Packet-格式" class="headerlink" title="EOF_Packet 格式"></a>EOF_Packet 格式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&lt;<span class="number">1</span>&gt;header[fe] EOF header</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> capabilities &amp; CLIENT_PROTOCOL_41 &#123;</span><br><span class="line">  <span class="type">int</span>&lt;<span class="number">2</span>&gt;warnings警告数</span><br><span class="line">  <span class="type">int</span>&lt;<span class="number">2</span>&gt;status_flags状态标志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据包数据类型介绍"><a href="#数据包数据类型介绍" class="headerlink" title="数据包数据类型介绍"></a>数据包数据类型介绍</h2>在上面的数据包格式中，你是不是看到例如 int&lt;1&gt;、string<EOF>、int<lenenc> 等等这些一头雾水？这个是 MySQL 官网文档中表示协议数据类型和长度的。主要数据类型如下表：</li></ul><table><thead><tr><th><strong>数据类型</strong></th><th><strong>字节长度</strong></th></tr></thead><tbody><tr><td>int&lt;1&gt;</td><td>1 字节</td></tr><tr><td>int&lt;2&gt;</td><td>2 字节</td></tr><tr><td>int&lt;3&gt;</td><td>3 字节</td></tr><tr><td>int&lt;4&gt;</td><td>4 字节</td></tr><tr><td>int&lt;6&gt;</td><td>6 字节</td></tr><tr><td>int&lt;8&gt;</td><td>8 字节</td></tr><tr><td>int&lt;lenenc&gt;</td><td>见下文详细介绍</td></tr><tr><td>string&lt;lenenc&gt;</td><td>见下文详细介绍</td></tr><tr><td>string&lt;fix&gt;</td><td>固定字节长度的字符串，其中 fix 代表一个指定的数值，例如 string&lt;5&gt;，其中 fix 就等于 5</td></tr><tr><td>string&lt;var&gt;</td><td>字符串的长度由另一个字段确定或在运行时计算</td></tr><tr><td>string&lt;EOF&gt;</td><td>如果字符串是数据包的最后一个组成部分，则它的长度可以从整个数据包长度减去当前位置来计算。</td></tr><tr><td>string&lt;NUL&gt;</td><td>以 [00] 字节结尾的字符串。</td></tr></tbody></table><p>在上面的表格中，大部分的数据类型的长度基本上都可以直接得知，但是其中 int&lt;lenenc&gt;、string&lt;lenenc&gt; 这两个类型的长度需要通过稍微复杂一点的计算来得到最终的数据长度。</p><h3 id="int-lt-lenenc-gt"><a href="#int-lt-lenenc-gt" class="headerlink" title="int&lt;lenenc&gt;"></a>int&lt;lenenc&gt;</h3><p>当要解析这个长度的数据时，它一般开头的第一个字节有 4 中表现形式</p><ul><li>第一个字节的值小于 0xfb：代表这个数据就是这一个字节长度，并且第一个字节的值就是对应字段的值</li><li>第一个字节的值等于 0xfc：代表这个字节往后的两个字节就是这个字段的数据，就是说这个字段一个占用 3 个字节长度，其中第 1 个字节表示该字段占用的字节长度数据，第 2 和第 3 个字节表示的是这个字段的数据</li><li>第一个字节的值等于 0xfd：和上面类似，只是字段数据字节一共占用 4 个字节，其中后 3 个字节表示这个字段的数据</li><li>第一个字节的值等于 0xfe：字段数据字节一共占用 9 个字节，其中后 8 个字节表示这个字段的数据<blockquote><p>注意：在 MySQL 3.22 版本以前，0xfe 表示的这个字段只有 4 个字节长度。<br>如果数据包的第一个字节是长度编码的整数并且其字节值为 0xfe，则必须检查数据包的长度以验证它是否有足够的空间容纳 8 字节整数。<br>如果不是，它可能是一个 <a href="https://dev.mysql.com/doc/internals/en/packet-EOF_Packet.html">EOF_Packet</a> 替代。</p></blockquote></li></ul><p>所以要得到这个字段对应的字节长度时，只要判断第一个字节的数据，然后就可以轻松获得这个字段的长度了</p><h3 id="string-lt-lenenc-gt"><a href="#string-lt-lenenc-gt" class="headerlink" title="string&lt;lenenc&gt;"></a>string&lt;lenenc&gt;</h3><p>这个数据类型分为两部分</p><ul><li><strong>length</strong> (<a href="https://dev.mysql.com/doc/internals/en/describing-packets.html#type-lenenc_int">int<lenenc></a>) – string 数据的占用字节长度</li><li><strong>string</strong> (<a href="https://dev.mysql.com/doc/internals/en/describing-packets.html#type-string.fix_len">string<fix></a>) – [len&#x3D;$length] string</li></ul><p>其中 length 这个数据通过上面 int&lt;lenenc&gt; 的方法获得，然后 string 的数据的字节长度就是 length 的值</p><h2 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h2><p>当我们连接成功后，这时就可以向服务端发送命令了，命令如下表：</p><table><thead><tr><th><strong>HEX 值</strong></th><th><strong>NAME</strong></th></tr></thead><tbody><tr><td>00</td><td><a href="https://dev.mysql.com/doc/internals/en/com-sleep.html#packet-COM_SLEEP">COM_SLEEP</a></td></tr><tr><td>01</td><td><a href="https://dev.mysql.com/doc/internals/en/com-quit.html#packet-COM_QUIT">COM_QUIT</a></td></tr><tr><td>02</td><td><a href="https://dev.mysql.com/doc/internals/en/com-init-db.html#packet-COM_INIT_DB">COM_INIT_DB</a></td></tr><tr><td>03</td><td><a href="https://dev.mysql.com/doc/internals/en/com-query.html#packet-COM_QUERY">COM_QUERY</a></td></tr><tr><td>04</td><td><a href="https://dev.mysql.com/doc/internals/en/com-field-list.html#packet-COM_FIELD_LIST">COM_FIELD_LIST</a></td></tr><tr><td>05</td><td><a href="https://dev.mysql.com/doc/internals/en/com-create-db.html#packet-COM_CREATE_DB">COM_CREATE_DB</a></td></tr><tr><td>06</td><td><a href="https://dev.mysql.com/doc/internals/en/com-drop-db.html#packet-COM_DROP_DB">COM_DROP_DB</a></td></tr><tr><td>07</td><td><a href="https://dev.mysql.com/doc/internals/en/com-refresh.html#packet-COM_REFRESH">COM_REFRESH</a></td></tr><tr><td>08</td><td><a href="https://dev.mysql.com/doc/internals/en/com-shutdown.html#packet-COM_SHUTDOWN">COM_SHUTDOWN</a></td></tr><tr><td>09</td><td><a href="https://dev.mysql.com/doc/internals/en/com-statistics.html#packet-COM_STATISTICS">COM_STATISTICS</a></td></tr><tr><td>0a</td><td><a href="https://dev.mysql.com/doc/internals/en/com-process-info.html#packet-COM_PROCESS_INFO">COM_PROCESS_INFO</a></td></tr><tr><td>0b</td><td><a href="https://dev.mysql.com/doc/internals/en/com-connect.html#packet-COM_CONNECT">COM_CONNECT</a></td></tr><tr><td>0c</td><td><a href="https://dev.mysql.com/doc/internals/en/com-process-kill.html#packet-COM_PROCESS_KILL">COM_PROCESS_KILL</a></td></tr><tr><td>0d</td><td><a href="https://dev.mysql.com/doc/internals/en/com-debug.html#packet-COM_DEBUG">COM_DEBUG</a></td></tr><tr><td>0e</td><td><a href="https://dev.mysql.com/doc/internals/en/com-ping.html#packet-COM_PING">COM_PING</a></td></tr><tr><td>0f</td><td><a href="https://dev.mysql.com/doc/internals/en/com-time.html#packet-COM_TIME">COM_TIME</a></td></tr><tr><td>10</td><td><a href="https://dev.mysql.com/doc/internals/en/com-delayed-insert.html#packet-COM_DELAYED_INSERT">COM_DELAYED_INSERT</a></td></tr><tr><td>11</td><td><a href="https://dev.mysql.com/doc/internals/en/com-change-user.html#packet-COM_CHANGE_USER">COM_CHANGE_USER</a></td></tr><tr><td>12</td><td><a href="https://dev.mysql.com/doc/internals/en/com-binlog-dump.html#packet-COM_BINLOG_DUMP">COM_BINLOG_DUMP</a></td></tr><tr><td>13</td><td><a href="https://dev.mysql.com/doc/internals/en/com-table-dump.html#packet-COM_TABLE_DUMP">COM_TABLE_DUMP</a></td></tr><tr><td>14</td><td><a href="https://dev.mysql.com/doc/internals/en/com-connect-out.html#packet-COM_CONNECT_OUT">COM_CONNECT_OUT</a></td></tr><tr><td>15</td><td><a href="https://dev.mysql.com/doc/internals/en/com-register-slave.html#packet-COM_REGISTER_SLAVE">COM_REGISTER_SLAVE</a></td></tr><tr><td>16</td><td><a href="https://dev.mysql.com/doc/internals/en/com-stmt-prepare.html#packet-COM_STMT_PREPARE">COM_STMT_PREPARE</a></td></tr><tr><td>17</td><td><a href="https://dev.mysql.com/doc/internals/en/com-stmt-execute.html#packet-COM_STMT_EXECUTE">COM_STMT_EXECUTE</a></td></tr><tr><td>18</td><td><a href="https://dev.mysql.com/doc/internals/en/com-stmt-send-long-data.html#packet-COM_STMT_SEND_LONG_DATA">COM_STMT_SEND_LONG_DATA</a></td></tr><tr><td>19</td><td><a href="https://dev.mysql.com/doc/internals/en/com-stmt-close.html#packet-COM_STMT_CLOSE">COM_STMT_CLOSE</a></td></tr><tr><td>1a</td><td><a href="https://dev.mysql.com/doc/internals/en/com-stmt-reset.html#packet-COM_STMT_RESET">COM_STMT_RESET</a></td></tr><tr><td>1b</td><td><a href="https://dev.mysql.com/doc/internals/en/com-set-option.html#packet-COM_SET_OPTION">COM_SET_OPTION</a></td></tr><tr><td>1c</td><td><a href="https://dev.mysql.com/doc/internals/en/com-stmt-fetch.html#packet-COM_STMT_FETCH">COM_STMT_FETCH</a></td></tr><tr><td>1d</td><td><a href="https://dev.mysql.com/doc/internals/en/com-daemon.html#packet-COM_DAEMON">COM_DAEMON</a></td></tr><tr><td>1e</td><td><a href="https://dev.mysql.com/doc/internals/en/com-binlog-dump-gtid.html#packet-COM_BINLOG_DUMP_GTID">COM_BINLOG_DUMP_GTID</a></td></tr><tr><td>1f</td><td><a href="https://dev.mysql.com/doc/internals/en/com-reset-connection.html#packet-COM_RESET_CONNECTION">COM_RESET_CONNECTION</a></td></tr></tbody></table><p>一般我们用的最多的就是 COM_QUERY 这个命令，像 CRUD 都可以通过这个命令来发送，例如我们发送一个查询当前数据库，就可以发送下面的字节数据给服务端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0f 00 00 00 03 73 68 6f 77 20 64 61 74 61 62 61</span><br><span class="line">73 65 73</span><br></pre></td></tr></table></figure><p>其中前 4 个字节代表这个包的大小和序号 ID，后面的字节数据就是我们发送的命令。<br>03 代表这个命令是 COM_QUERY。<br>后面所有的字节数据都是 show databses 转换 byte 后的字节数据</p><h2 id="结果集"><a href="#结果集" class="headerlink" title="结果集"></a>结果集</h2><p>当你发送的 COM_QUERY 命令时，它返回三种数据包的其中一种。我们可以通过第一个字节来判断它：</p><ul><li>当第一个字节数据等于 0x00：返回的是 OK_Packet</li><li>当第一个字节的数据等于 0xff：返回的是 ERR_Packet</li><li>当第一个字节的数据不是以上两个值时：返回一个结果集，并且第一个字节的值代表返回结果集中列（columns）的总数。</li></ul><p><strong>结果集分 3 个部分来读取：</strong></p><ul><li>第一个数据包表示返回结果集中列（columns）的总数。</li><li>然后通过第一个数据包获取的列总数来读取相关列的所有数据包，一列有一个数据包，比如说上面得到列总数为 3，那么接下来的 3 个数据包就是这 3 列的说明。</li><li>读完列的所有数据包后，紧接着就是没行数据的数据包了，一个数据包代表一行数据，每个数据包中有所有列的字段值。其中，如果值长度的值为 0xfe 时，则代表这行中这列的数据为 NULL。行数据直到读取到 OK_Packet&#x2F;EOF_Packet 包出现为止。<h3 id="COM-QUERY-Response-格式"><a href="#COM-QUERY-Response-格式" class="headerlink" title="COM_QUERY_Response 格式"></a>COM_QUERY_Response 格式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字节长度计算方法见上面的 int&lt;lenenc&gt; 介绍</span></span><br><span class="line"><span class="type">int</span>&lt;lenenc&gt;     结果集中列（columns）的总数。</span><br></pre></td></tr></table></figure><h3 id="列数据包格式"><a href="#列数据包格式" class="headerlink" title="列数据包格式"></a>列数据包格式</h3>列数据包格式也分为两种格式，也是通过客户端上传的 <a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_PROTOCOL_41">CLIENT_PROTOCOL_41</a> 能力标志来觉得的。<br>如果客户端支持 <a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_PROTOCOL_41">CLIENT_PROTOCOL_41</a> 这个能力标志，服务端返回 <strong>ColumnDefinition41</strong> 这个列数据包。<br>如果客户端不支持  <a href="https://dev.mysql.com/doc/internals/en/capability-flags.html#flag-CLIENT_PROTOCOL_41">CLIENT_PROTOCOL_41</a>  这个能力标志的话，服务端就返回 <strong>ColumnDefinition320</strong> 这个版本的列数据包。<br>现在一般都使用 <strong>ColumnDefinition41</strong> 这个数据包，这个数据包描述如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&lt;lenenc&gt;      catalog目录 (固定为 <span class="string">&quot;def&quot;</span>)</span><br><span class="line">string&lt;lenenc&gt;      schema数据库</span><br><span class="line">string&lt;lenenc&gt;      table虚拟表</span><br><span class="line">string&lt;lenenc&gt;      org_table源表</span><br><span class="line">string&lt;lenenc&gt;      name虚拟名称</span><br><span class="line">string&lt;lenenc&gt;      org_name源名称</span><br><span class="line">string&lt;lenenc&gt;      length of fixed-length fields [<span class="number">0</span>c]</span><br><span class="line"><span class="number">2</span>              character set字符集</span><br><span class="line"><span class="number">4</span>              column length字段的最大长度</span><br><span class="line"><span class="number">1</span>              type列类型</span><br><span class="line"><span class="number">2</span>              flags标志</span><br><span class="line"><span class="number">1</span>              decimals显示的小数位数</span><br><span class="line"><span class="number">2</span>              filler [<span class="number">00</span>] [<span class="number">00</span>]两个空占位符</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> command was COM_FIELD_LIST &#123;</span><br><span class="line">    <span class="type">int</span>&lt;lenenc&gt;     length of <span class="keyword">default</span>-values</span><br><span class="line">    string[$len]   <span class="keyword">default</span> values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行数据包格式"><a href="#行数据包格式" class="headerlink" title="行数据包格式"></a>行数据包格式</h3>行数据包里面包含了所有列的字段数据，每个列的字段的数据可以通过 string&lt;lenenc&gt; 数据类型的计算的方式获得，其中要注意的是，如果字段长度描述字节的数据等于 0xfe 时，代表这行中这列的数据为 NULL。<br>下图是行数据包的表现形式：</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee42af3f32e41739eb78d61b027987d~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>通过以上的介绍，现在我们可以用代码来实现不用第三方驱动的情况下手动连接 MySQL 服务器，然后发送一条查询 databses 的命令。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2022/03/28/Untitled-2022-02-10-1029.png" alt="Untitled-2022-02-10-1029"></p><p>下面的是代码片段，完整代码连接：<a href="https://gist.github.com/greycodee/22f98464fece7792a83433a1fba58e2a">https://gist.github.com/greycodee/22f98464fece7792a83433a1fba58e2a</a></p><h3 id="连接-MySQL-服务器"><a href="#连接-MySQL-服务器" class="headerlink" title="连接 MySQL 服务器"></a>连接 MySQL 服务器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLClient <span class="keyword">struct</span> &#123;</span><br><span class="line">conn net.Conn</span><br><span class="line">addr <span class="type">string</span></span><br><span class="line">username <span class="type">string</span></span><br><span class="line">password<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLClient)</span></span> init()  &#123;</span><br><span class="line"><span class="comment">// 连接阶段</span></span><br><span class="line">handshake := m.startConn()</span><br><span class="line">m.sendHandshakeResponse41(handshake)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">连接 MySQL 服务器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLClient)</span></span> startConn() *HandshakeV10 &#123;</span><br><span class="line">m.conn, _ = net.Dial(<span class="string">&quot;tcp&quot;</span>,m.addr)</span><br><span class="line">initResp := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">1024</span>)</span><br><span class="line">readLen, _ := m.conn.Read(initResp)</span><br><span class="line"><span class="keyword">return</span> ReadHandShakeV10(initResp[:readLen])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析初始握手数据包"><a href="#解析初始握手数据包" class="headerlink" title="解析初始握手数据包"></a>解析初始握手数据包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析初始握手包 HandShakeV10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadHandShakeV10</span><span class="params">(data []<span class="type">byte</span>)</span></span> *HandshakeV10 &#123;</span><br><span class="line">index := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> h = &amp;HandshakeV10&#123;&#125;</span><br><span class="line">index+=<span class="number">4</span></span><br><span class="line">h.ProtocolVersion= <span class="type">int32</span>(data[index])</span><br><span class="line">index++</span><br><span class="line"><span class="keyword">var</span> serverVersion []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> data[index]!=<span class="number">0</span> &#123;</span><br><span class="line">serverVersion = <span class="built_in">append</span>(serverVersion,data[index])</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line">h.ServerVersion = <span class="type">string</span>(serverVersion)</span><br><span class="line">index++</span><br><span class="line">connectByte := data[index:index+<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i :=<span class="keyword">range</span> connectByte&#123;</span><br><span class="line">h.ConnectionId+=<span class="type">int32</span>(connectByte[i])</span><br><span class="line">&#125;</span><br><span class="line">index+=<span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> apdp1 []<span class="type">byte</span></span><br><span class="line">apdp1Byte := data[index:index+<span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> apdp1Byte &#123;</span><br><span class="line">apdp1 = <span class="built_in">append</span>(apdp1, apdp1Byte[i])</span><br><span class="line">&#125;</span><br><span class="line">h.AuthPluginDataPart_1 = <span class="type">string</span>(apdp1)</span><br><span class="line">index+=<span class="number">9</span></span><br><span class="line"><span class="comment">// 能力低2位</span></span><br><span class="line">c_flag_low_1 := strings.Split(fmt.Sprintf(<span class="string">&quot;%b\n&quot;</span>,data[index+<span class="number">1</span>]),<span class="string">&quot;&quot;</span>)</span><br><span class="line">c_flag_low_2 := strings.Split(fmt.Sprintf(<span class="string">&quot;%b\n&quot;</span>,data[index]),<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">index+=<span class="number">2</span></span><br><span class="line"><span class="comment">// 编码获取</span></span><br><span class="line">h.CharacterSet = <span class="type">int32</span>(data[index])</span><br><span class="line">index++</span><br><span class="line"><span class="comment">// 服务器状态</span></span><br><span class="line">index+=<span class="number">2</span></span><br><span class="line"><span class="comment">// 能力高2位</span></span><br><span class="line">c_flag_up_1 := strings.Split(fmt.Sprintf(<span class="string">&quot;%b\n&quot;</span>,data[index+<span class="number">1</span>]),<span class="string">&quot;&quot;</span>)</span><br><span class="line">c_flag_up_2 := strings.Split(fmt.Sprintf(<span class="string">&quot;%b\n&quot;</span>,data[index]),<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> capabilityFlags []<span class="type">string</span></span><br><span class="line">capabilityFlags = <span class="built_in">append</span>(capabilityFlags,c_flag_up_1...)</span><br><span class="line">capabilityFlags = <span class="built_in">append</span>(capabilityFlags,c_flag_up_2...)</span><br><span class="line">capabilityFlags = <span class="built_in">append</span>(capabilityFlags,c_flag_low_1...)</span><br><span class="line">capabilityFlags = <span class="built_in">append</span>(capabilityFlags,c_flag_low_2...)</span><br><span class="line">index+=<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> strings.EqualFold(<span class="string">&quot;1&quot;</span>,capabilityFlags[<span class="number">19</span>])&#123;</span><br><span class="line">h.AuthPluginDataLen= <span class="type">int32</span>(data[index])</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">index+=<span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> strings.EqualFold(<span class="string">&quot;1&quot;</span>,capabilityFlags[<span class="number">15</span>])&#123;</span><br><span class="line">p2Len := <span class="number">13</span></span><br><span class="line">p2len1 := <span class="type">int</span>(h.AuthPluginDataLen<span class="number">-8</span>)</span><br><span class="line"><span class="keyword">if</span> p2Len &lt; p2len1 &#123;</span><br><span class="line">p2Len = p2len1</span><br><span class="line">&#125;</span><br><span class="line">h.AuthPluginDataPart_2 = <span class="type">string</span>(data[index:index+p2Len])</span><br><span class="line">index+=p2Len</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> strings.EqualFold(<span class="string">&quot;1&quot;</span>,capabilityFlags[<span class="number">19</span>]) &#123;</span><br><span class="line"><span class="keyword">var</span> authPlugName []<span class="type">byte</span></span><br><span class="line"><span class="keyword">for</span> data[index] != <span class="number">0</span> &#123;</span><br><span class="line">authPlugName = <span class="built_in">append</span>(authPlugName,data[index])</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line">h.AuthPluginName = <span class="type">string</span>(authPlugName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> HandshakeV10 <span class="keyword">struct</span> &#123;</span><br><span class="line">ProtocolVersion      <span class="type">int32</span>  <span class="string">`protobuf:&quot;varint,1,opt,name=protocol_version,json=protocolVersion,proto3&quot; json:&quot;protocol_version,omitempty&quot;`</span></span><br><span class="line">ServerVersion        <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,2,opt,name=server_version,json=serverVersion,proto3&quot; json:&quot;server_version,omitempty&quot;`</span></span><br><span class="line">ConnectionId         <span class="type">int32</span>  <span class="string">`protobuf:&quot;varint,3,opt,name=connection_id,json=connectionId,proto3&quot; json:&quot;connection_id,omitempty&quot;`</span></span><br><span class="line">AuthPluginDataPart_1 <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,4,opt,name=auth_plugin_data_part_1,json=authPluginDataPart1,proto3&quot; json:&quot;auth_plugin_data_part_1,omitempty&quot;`</span></span><br><span class="line">CharacterSet         <span class="type">int32</span>  <span class="string">`protobuf:&quot;varint,6,opt,name=character_set,json=characterSet,proto3&quot; json:&quot;character_set,omitempty&quot;`</span></span><br><span class="line">StatusFlags          <span class="type">int32</span>  <span class="string">`protobuf:&quot;varint,7,opt,name=status_flags,json=statusFlags,proto3&quot; json:&quot;status_flags,omitempty&quot;`</span></span><br><span class="line">AuthPluginDataLen    <span class="type">int32</span>  <span class="string">`protobuf:&quot;varint,8,opt,name=auth_plugin_data_len,json=authPluginDataLen,proto3&quot; json:&quot;auth_plugin_data_len,omitempty&quot;`</span></span><br><span class="line">AuthPluginDataPart_2 <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,9,opt,name=auth_plugin_data_part_2,json=authPluginDataPart2,proto3&quot; json:&quot;auth_plugin_data_part_2,omitempty&quot;`</span></span><br><span class="line">AuthPluginName       <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,10,opt,name=auth_plugin_name,json=authPluginName,proto3&quot; json:&quot;auth_plugin_name,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送初始响应数据包"><a href="#发送初始响应数据包" class="headerlink" title="发送初始响应数据包"></a>发送初始响应数据包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送初始响应数据包 HandshakeResponse41，包含登陆信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLClient)</span></span> sendHandshakeResponse41(serverResp *HandshakeV10) &#123;</span><br><span class="line">resp := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, Int32ToBytesOfLittle(<span class="number">19833351</span>)...)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, Int32ToBytesOfLittle(<span class="number">16777215</span>)...)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, <span class="number">33</span>)</span><br><span class="line">reserved := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">23</span>)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, reserved...)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, []<span class="type">byte</span>(m.username)...)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, <span class="number">0</span>)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, <span class="number">20</span>)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, CalcPassword([]<span class="type">byte</span>(serverResp.AuthPluginDataPart_1+serverResp.AuthPluginDataPart_2)[:<span class="number">20</span>],[]<span class="type">byte</span>(m.password))...)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, []<span class="type">byte</span>(<span class="string">&quot;mysql_native_password&quot;</span>)...)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">_, _ = m.conn.Write(Pack(resp,<span class="number">1</span>))</span><br><span class="line">flag := m.handleResponse()</span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">0xff</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;连接失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断连接结果"><a href="#判断连接结果" class="headerlink" title="判断连接结果"></a>判断连接结果</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析通用响应数据包 OK_Packet、ERR_Packet、数据集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLClient)</span></span> handleResponse() <span class="type">uint8</span> &#123;</span><br><span class="line">resp := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">1024</span>)</span><br><span class="line">readLen, _ := m.conn.Read(resp)</span><br><span class="line">data := resp[:readLen]</span><br><span class="line">data = data[<span class="number">4</span>:]</span><br><span class="line"><span class="keyword">switch</span> data[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0x00</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0xff</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xff</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">parseResultSet(data)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xfe</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送命令-1"><a href="#发送命令-1" class="headerlink" title="发送命令"></a>发送命令</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CommandQuery</span></span><br><span class="line"><span class="comment">发送 COM_QUERY 命令，并读取数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLClient)</span></span> CommandQuery(sql <span class="type">string</span>) &#123;</span><br><span class="line">resp := <span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, <span class="number">3</span>)</span><br><span class="line">resp = <span class="built_in">append</span>(resp, []<span class="type">byte</span>(sql)...)</span><br><span class="line">_, _ = m.conn.Write(Pack(resp,<span class="number">0</span>))</span><br><span class="line">m.handleResponse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析结果集"><a href="#解析结果集" class="headerlink" title="解析结果集"></a>解析结果集</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseResultSet</span><span class="params">(resp []<span class="type">byte</span>)</span></span>  &#123;</span><br><span class="line">index := <span class="number">0</span></span><br><span class="line">fieldLen := resp[<span class="number">0</span>]</span><br><span class="line">index+=<span class="number">1</span></span><br><span class="line">headRows := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">headIndex := <span class="number">1</span></span><br><span class="line"><span class="comment">// 读取列数据</span></span><br><span class="line"><span class="keyword">for</span> headIndex &lt;= <span class="type">int</span>(fieldLen)&#123;</span><br><span class="line">n,l := readColumn(resp,index)</span><br><span class="line">index+=l</span><br><span class="line">headRows = <span class="built_in">append</span>(headRows, n)</span><br><span class="line">headIndex++</span><br><span class="line">&#125;</span><br><span class="line">table, err := gotable.Create(headRows...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Create table failed: &quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取行内容</span></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"><span class="comment">// 判断是否是 EOF 数据包</span></span><br><span class="line"><span class="keyword">if</span> resp[index+<span class="number">4</span>] == <span class="number">0xfe</span>&#123;</span><br><span class="line">packLen := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _,v :=<span class="keyword">range</span> resp[index:index+<span class="number">3</span>]&#123;</span><br><span class="line">packLen+=<span class="type">int</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> packLen&lt;<span class="number">9</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rows,ll := readRow(resp,index, <span class="type">int</span>(fieldLen))</span><br><span class="line">table.AddRow(rows)</span><br><span class="line">index+=ll</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">fmt.Println(table)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readColumn</span><span class="params">(data []<span class="type">byte</span>, startIndex <span class="type">int</span>)</span></span> (name <span class="type">string</span>,length <span class="type">int</span>) &#123;</span><br><span class="line">packLen := data[startIndex:startIndex+<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i :=<span class="keyword">range</span> packLen&#123;</span><br><span class="line">length+=<span class="type">int</span>(packLen[i])</span><br><span class="line">&#125;</span><br><span class="line">length += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">startIndex+=<span class="number">4</span></span><br><span class="line">startIndex+=<span class="type">int</span>(data[startIndex]+<span class="number">1</span>)</span><br><span class="line">startIndex+=<span class="type">int</span>(data[startIndex]+<span class="number">1</span>)</span><br><span class="line">startIndex+=<span class="type">int</span>(data[startIndex]+<span class="number">1</span>)</span><br><span class="line">startIndex+=<span class="type">int</span>(data[startIndex]+<span class="number">1</span>)</span><br><span class="line">nameLen := <span class="type">int</span>(data[startIndex])</span><br><span class="line">name = <span class="type">string</span>(data[startIndex+<span class="number">1</span>:startIndex+nameLen+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readRow</span><span class="params">(data []<span class="type">byte</span>, startIndex <span class="type">int</span>, fieldNum <span class="type">int</span>)</span></span> (name []<span class="type">string</span>,length <span class="type">int</span>) &#123;</span><br><span class="line">packLen := data[startIndex:startIndex+<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i :=<span class="keyword">range</span> packLen&#123;</span><br><span class="line">length+=<span class="type">int</span>(packLen[i])</span><br><span class="line">&#125;</span><br><span class="line">length += <span class="number">4</span></span><br><span class="line">startIndex+=<span class="number">4</span></span><br><span class="line">f:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> f &lt; fieldNum&#123;</span><br><span class="line">dataLen := <span class="number">0</span></span><br><span class="line"><span class="comment">// 计算字节数据长度</span></span><br><span class="line"><span class="keyword">if</span> data[startIndex] &lt; <span class="number">0xfb</span> &#123;</span><br><span class="line"><span class="comment">// NULL</span></span><br><span class="line">dataLen = <span class="type">int</span>(data[startIndex])</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> data[startIndex] == <span class="number">0xfc</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> data[startIndex+<span class="number">1</span>:startIndex+<span class="number">3</span>]&#123;</span><br><span class="line">dataLen+=<span class="type">int</span>(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> data[startIndex] == <span class="number">0xfd</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _,v :=<span class="keyword">range</span> data[startIndex+<span class="number">1</span>:startIndex+<span class="number">5</span>]&#123;</span><br><span class="line">dataLen+=<span class="type">int</span>(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> data[startIndex] == <span class="number">0xfe</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _,v :=<span class="keyword">range</span> data[startIndex+<span class="number">1</span>:startIndex+<span class="number">9</span>]&#123;</span><br><span class="line">dataLen+=<span class="type">int</span>(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">name = <span class="built_in">append</span>(name, <span class="type">string</span>(data[startIndex+<span class="number">1</span>:startIndex+dataLen+<span class="number">1</span>]))</span><br><span class="line">startIndex += dataLen+<span class="number">1</span></span><br><span class="line">f++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="控制台结果输出"><a href="#控制台结果输出" class="headerlink" title="控制台结果输出"></a>控制台结果输出</h3><p>执行上面的代码后，控制台就会输出所有的数据库名字</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|      Database      |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">|      greycode      |</span><br><span class="line">|       mysql        |</span><br><span class="line">| performance_schema |</span><br><span class="line">|        sys         |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html">https://dev.mysql.com/doc/internals/en/client-server-protocol.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们平常使用数据库的场景一般是程序里面代码直接连接使用，然后进行 CRUD 操作。或者使用有 GUI 界面的数据库软件来手动操作数据库， 这</summary>
      
    
    
    
    <category term="协议" scheme="https://greycode.top/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="协议" scheme="https://greycode.top/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="MySQL" scheme="https://greycode.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>什么是P2P网络</title>
    <link href="https://greycode.top/archive/FA21243A47644D98B4380AE439D2A69F/"/>
    <id>https://greycode.top/archive/FA21243A47644D98B4380AE439D2A69F/</id>
    <published>2022-02-22T15:08:04.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NAT-类型"><a href="#NAT-类型" class="headerlink" title="NAT 类型"></a>NAT 类型</h2><h3 id="Full-Cone-NAT"><a href="#Full-Cone-NAT" class="headerlink" title="Full Cone NAT"></a>Full Cone NAT</h3><p>全锥形 NAT 是将来自相同内部 IP 地址和端口的所有请求映射到相同的外部 IP 地址和端口。此外，任何外部主机都可以通过向映射的外部地址发送数据包来向内部主机发送数据包。</p><h3 id="Restricted-Cone-NAT"><a href="#Restricted-Cone-NAT" class="headerlink" title="Restricted Cone NAT"></a>Restricted Cone NAT</h3><p>受限锥形 NAT 是将来自相同内部 IP 地址和端口的所有请求映射到相同的外部 IP 地址和端口。与完整的锥形 NAT 不同，外部主机（IP 地址为 X）只有在内部主机先前已向 IP 地址 X 发送数据包时才能向内部主机发送数据包。</p><h3 id="Port-Restricted-Cone-NAT"><a href="#Port-Restricted-Cone-NAT" class="headerlink" title="Port Restricted Cone NAT"></a>Port Restricted Cone NAT</h3><p>端口受限锥形 NAT 类似于受限锥形 NAT，但限制包括端口号。具体来说，只有当内部主机之前已经向 IP 地址 X 和端口 P 发送了数据包时，外部主机才能向内部主机发送源 IP 地址为 X 和源端口 P 的数据包</p><h3 id="Symmetric-NAT"><a href="#Symmetric-NAT" class="headerlink" title="Symmetric NAT"></a>Symmetric NAT</h3><p>对称 NAT 是一种从相同内部 IP 地址和端口到特定目标 IP 地址和端口的所有请求都映射到相同外部 IP 地址和端口的一种。如果同一主机发送具有相同源地址和端口的数据包，但发送到不同的目的地，则使用不同的映射。此外，只有收到数据包的外部主机才能将 UDP 数据包发送回内部主机。</p><h2 id="Hole-Punching"><a href="#Hole-Punching" class="headerlink" title="Hole Punching"></a>Hole Punching</h2><p>使用先前建立的关联来允许任意外部地址&#x2F;端口向内部地址&#x2F;端口发送数据称为打孔。使用普通（全锥）、受限和端口受限 NAT 可以进行打孔，这些 NAT 将相同的内部地址&#x2F;端口一致地映射到外部地址&#x2F;端口。</p><p><strong>注意：</strong> 纯对称 NAT 无法进行打孔，因为它们的目标特定端口映射行为不一致。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2022/02/22/NAT_types-20220222151007798.png" alt="NAT_types"></p><h2 id="STUN-和-TURN"><a href="#STUN-和-TURN" class="headerlink" title="STUN 和 TURN"></a>STUN 和 TURN</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dh2i.com/wp-content/uploads/NAT_types.png">https://dh2i.com/wp-content/uploads/NAT_types.png</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NAT-类型&quot;&gt;&lt;a href=&quot;#NAT-类型&quot; class=&quot;headerlink&quot; title=&quot;NAT 类型&quot;&gt;&lt;/a&gt;NAT 类型&lt;/h2&gt;&lt;h3 id=&quot;Full-Cone-NAT&quot;&gt;&lt;a href=&quot;#Full-Cone-NAT&quot; class=&quot;he</summary>
      
    
    
    
    <category term="网络" scheme="https://greycode.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="P2P" scheme="https://greycode.top/tags/P2P/"/>
    
    <category term="网络" scheme="https://greycode.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>centos 多网卡配置优先级</title>
    <link href="https://greycode.top/linux/0A5A3927BAEA4155849C174E4C613913/"/>
    <id>https://greycode.top/linux/0A5A3927BAEA4155849C174E4C613913/</id>
    <published>2021-09-01T15:47:14.000Z</published>
    <updated>2022-04-16T02:52:58.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li><p><strong>查看网卡配置</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 34:17:eb:f0:18:8f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.84/24 brd 192.168.0.255 scope global noprefixroute em1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 240e:390:c6a:c3a0:3617:ebff:fef0:188f/64 scope global noprefixroute dynamic</span><br><span class="line">       valid_lft 259182sec preferred_lft 172782sec</span><br><span class="line">    inet6 fe80::3617:ebff:fef0:188f/64 scope <span class="built_in">link</span> noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: em2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 34:17:eb:f0:18:90 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.169.0.10/23 brd 192.169.1.255 scope global noprefixroute em2</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::3617:ebff:fef0:1890/64 scope <span class="built_in">link</span> noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:b1:66:84:26 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:b1ff:fe66:8426/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">12: veth4ffa8ca@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether ca:d7:f0:2f:42:f0 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::c8d7:f0ff:fe2f:42f0/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">14: veth9c158d5@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 76:ab:49:a9:e4:a6 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::74ab:49ff:fea9:e4a6/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这里有 <code>em1</code> 和 <code>em2</code> 两张网卡</p></li><li><p><strong>查看网卡路由</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ip route show</span></span><br><span class="line">default via 192.168.0.1 dev em1 proto static metric 100</span><br><span class="line">default via 192.169.0.1 dev em2 proto static metric 101</span><br><span class="line">172.17.0.0/16 dev docker0 proto kernel scope <span class="built_in">link</span> src 172.17.0.1</span><br><span class="line">192.168.0.0/24 dev em1 proto kernel scope <span class="built_in">link</span> src 192.168.0.84 metric 100</span><br><span class="line">192.169.0.0/23 dev em2 proto kernel scope <span class="built_in">link</span> src 192.169.0.10 metric 101</span><br></pre></td></tr></table></figure><p>可以看到，<code>em1</code> 的 <code>metric</code> 大于 <code>em2</code> ， <code>metric</code>  值越低，优先级越高。</p><blockquote><p><strong>Metric</strong> 为路由指定所需跃点数的整数值（范围是 1 ~ 9999），它用来在路由表里的多个路由中选择与转发包中的目标地址最为匹配的路由。所选的路由具有最少的跃点数。跃点数能够反映跃点的数量、路径的速度、路径可靠性、路径吞吐量以及管理属性。<strong>Metric</strong> 的值越小，优先级越高，如果两块网卡的Metric的值相同，就会出现抢占优先级继而网卡冲突，将会有一块网卡无法连接。</p></blockquote></li><li><p><strong>更改优先级</strong></p><p>现在要设置 <code>em2</code> 的优先级比 <code>em1</code> 的高，只需要更改 <code>em2</code> 网卡配置的 <code>metric</code> 值比 <code>em1</code> 的低就可以了</p><p><strong>修改 em2 网卡配置：</strong></p><p>配置文件地址：<code>vim /etc/sysconfig/network-scripts/ifcfg-em2</code></p><p>添加配置: <code>IPV4_ROUTE_METRIC=90</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">PEERDNS=<span class="built_in">yes</span></span><br><span class="line">PEERROUTES=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV4_ROUTE_METRIC=90</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_PEERDNS=<span class="built_in">yes</span></span><br><span class="line">IPV6_PEERROUTES=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=em2</span><br><span class="line">UUID=23420496-e9ed-466c-a8fc-e99b091f3a00</span><br><span class="line">DEVICE=em2</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line">IPADDR=192.169.0.10</span><br><span class="line">NETMASK=255.255.254.0</span><br><span class="line">GATEWAY=192.169.0.1</span><br><span class="line">DNS1=114.114.114.114</span><br></pre></td></tr></table></figure></li><li><p><strong>重启网卡</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 刷新配置文件</span></span><br><span class="line"><span class="built_in">source</span> /etc/sysconfig/network-scripts/ifcfg-em2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 em2 网卡</span></span><br><span class="line">ifdown em2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启 em2 网卡</span></span><br><span class="line">ifup em2</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看网卡配置&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="Linux" scheme="https://greycode.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://greycode.top/tags/Linux/"/>
    
    <category term="Centos" scheme="https://greycode.top/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>用 Json-Schema 来验证你的请求参数</title>
    <link href="https://greycode.top/tool/775FF9A0CE4940EBBB45FED3FAD7AB5B/"/>
    <id>https://greycode.top/tool/775FF9A0CE4940EBBB45FED3FAD7AB5B/</id>
    <published>2021-08-19T16:40:05.000Z</published>
    <updated>2022-04-16T02:52:58.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Json-Schema 是一个用来验证、描述 Json 数据的一个标准，它可以用来验证你的请求数据是否和你定义的 Schema 是否一致。比如下面的 Json 数据中：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;greycode&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span><span class="string">&quot;coder&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果不预先告诉你字段的含义，你知道 <code>name</code> 是什么意思吗？它到底是指人名还是一个物品的名字还是其他？<code>desc</code> 又是什么意思呢？</p><p>这时候，就可以用 Json-Schema 来描述它了</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;$schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://json-schema.org/draft-07/schema&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;$id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://example.com/example.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这是一个Json数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;描述个人信息的数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;desc&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;人的姓名&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;个人简介&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上面我们用 Json-Schema 来描述了刚开始的 Json 数据，这样就可以清楚的知道 name 是人的姓名，desc 是个人简介，在也不用自己去猜了。</p><h2 id="Json-Schema-字段说明"><a href="#Json-Schema-字段说明" class="headerlink" title="Json Schema 字段说明"></a>Json Schema 字段说明</h2><p>在上面的 Json-Schema 数据中，每个字段都有其的含义</p><ul><li><code>$schema</code> ：主要用于版本控制</li><li><code>$id</code> ：定义字段在 schema 中的地址</li><li><code>title</code> 和 <code>description</code> ：用于描述和说明 Schema 的作用</li><li><code>type</code> ：定义字段的数据类型</li><li><code>required</code> ：Json 数据中包含的字段</li><li>……</li></ul><p>由于 Json-Schema 有许多草案，每个草案的字段都有一点区别，具体可以看一下的草案资料：</p><ol><li><a href="https://json-schema.org/draft/2020-12/release-notes.html">草案 2019-09 迁移 草案 2020-12</a></li><li><a href="https://json-schema.org/draft/2019-09/release-notes.html">草案-07 迁移 草案 2019-09</a></li><li><a href="https://json-schema.org/draft-07/json-schema-release-notes.html">草案-06 迁移 草案-07</a></li><li><a href="https://json-schema.org/draft-06/json-schema-release-notes.html">草案-04 迁移 草案-06 文档说明</a></li><li><a href="https://json-schema.org/specification-links.html">所有草案版本文档</a></li></ol><h2 id="使用-Json-Schema-验证-Json-数据"><a href="#使用-Json-Schema-验证-Json-数据" class="headerlink" title="使用 Json-Schema 验证 Json 数据"></a>使用 Json-Schema 验证 Json 数据</h2><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/hlpzY6image-20210820162428822.png" alt="image-20210820162428822"></p><p>Json-Schema 支持多种语言的验证器，一般都是第三方实现的，这里我们使用 Java 验证器来验证一个 Json 数据，Java 验证器这里选用了 <a href="https://github.com/everit-org/json-schema">everit-org&#x2F;json-schema</a> 验证器来使用，不过它最高支持到<strong>草案7</strong>，像最新的<strong>草案2020-12</strong>它是不支持的。</p><h3 id="Java-验证-Json-数据"><a href="#Java-验证-Json-数据" class="headerlink" title="Java 验证 Json 数据"></a>Java 验证 Json 数据</h3><p><strong>导入依赖：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.everit-org.json-schema<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.everit.json.schema<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>jitpack.io<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://jitpack.io<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入所需依赖，由于这个包没有上传到中央仓库，所以要设置仓库地址</p><p><strong>代码实现：</strong></p><p>导入依赖后就可以用代码来实现一个使用 Json-Schema 验证 Json 数据的功能了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">jsonSchema</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;$schema\&quot;: \&quot;http://json-schema.org/draft-07/schema\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;$id\&quot;: \&quot;http://example.com/example.json\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;type\&quot;: \&quot;object\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;title\&quot;: \&quot;这是一个Json数据\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;description\&quot;: \&quot;描述个人信息的数据\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;required\&quot;: [\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;name\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;desc\&quot;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    ],\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;name\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            \&quot;type\&quot;: \&quot;string\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            \&quot;description\&quot;: \&quot;人的姓名\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        &#125;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;desc\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            \&quot;type\&quot;: \&quot;string\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            \&quot;description\&quot;: \&quot;个人简介\&quot;,\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(<span class="keyword">new</span> <span class="title class_">JSONTokener</span>(jsonSchema));</span><br><span class="line">  <span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> SchemaLoader.load(jsonObject);</span><br><span class="line">  schema.validate(<span class="keyword">new</span> <span class="title class_">JSONObject</span>(<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;  \&quot;name\&quot;:\&quot;greycode\&quot;,\n&quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;  \&quot;desc\&quot;:\&quot;coder\&quot;\n&quot;</span> +</span><br><span class="line">                                 <span class="string">&quot;&#125;&quot;</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;验证异常：&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了上面的 Json 数据和 Json-Schema，当验证通过时，不会有任何输出，同时也没有任何异常。</p><p>当我们把 <code>desc</code> 的数据改为如下数据时：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;greycode&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时由于 <code>desc</code> 的数据类型变为了数字类型，所以我们就可以捕获到异常并输出：<code>验证异常：#/desc: expected type: String, found: Integer</code></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li>所有的第三方 Json-Schema 验证器：<a href="https://json-schema.org/implementations.html#validators">https://json-schema.org/implementations.html#validators</a></li><li>Jaon-Schema 生成器：<a href="https://json-schema.org/implementations.html#schema-generators">https://json-schema.org/implementations.html#schema-generators</a></li><li>通过 Json-Schema 生成代码、数据等：<a href="https://json-schema.org/implementations.html#generators-from-schemas">https://json-schema.org/implementations.html#generators-from-schemas</a></li><li>在线 Json 转换 Json-Schema ：<a href="https://www.jsonschema.net/home">https://www.jsonschema.net/home</a></li><li><a href="https://json-schema.org/">https://json-schema.org/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Json-Schema 是一个用来验证、描述 Json 数据的一个标准，它可以用来验证你的请求数据是否和你定义的 Schema 是否一致。比</summary>
      
    
    
    
    <category term="Tool" scheme="https://greycode.top/categories/Tool/"/>
    
    
    <category term="Java" scheme="https://greycode.top/tags/Java/"/>
    
    <category term="Json-Schema" scheme="https://greycode.top/tags/Json-Schema/"/>
    
    <category term="参数验证" scheme="https://greycode.top/tags/%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>AviatorScript轻量级高性能脚本语言</title>
    <link href="https://greycode.top/java/CA3AB1D58EA74B76A5FD69F79DD5EC79/"/>
    <id>https://greycode.top/java/CA3AB1D58EA74B76A5FD69F79DD5EC79/</id>
    <published>2021-08-17T16:10:53.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 <code>5.0</code> 版本以前，它的名字是叫 <strong>Aviator</strong> ，定位一直只是一个表达式引擎，不支持 if&#x2F;else 条件语句（仅有三元运算符支持 <code>?:</code> ），没有内置的 for&#x2F;while 循环支持（虽然你可以用 seq 库类似函数式的方式来处理集合），也没有赋值（后来在 4.0 引入），没有作用域的概念（也在 4.0 引入 lambda 函数后部分实现）等等一般语言常见的能力。在 <code>5.0</code> 版本后，它变成了一门脚本语言，叫：<strong>AviatorScript</strong> 。</p><p>在 <code>5.0</code> ，新加了如下新特性：</p><ul><li><p><code>大括号 &#123; ... &#125;</code> 括起来的词法作用域。</p></li><li><p><code>let</code> 语句用于定义局部变量。</p></li><li><p>条件语句 <code>if/elsif/else</code> 。</p></li><li><p>循环语句 <code>for</code> 和 <code>while</code> ，以及相应的 <code>break</code> 和 <code>continue</code> 语句支持。</p></li><li><p><code>return</code> 语句用于从脚本或者函数中返回值。</p></li><li><p><code>fn hello() &#123; println(&quot;hello&quot;); &#125;</code> 新的 fn 语法用于定义命名函数。</p></li><li><p><code>## 单行注释</code> 注释支持</p></li><li><p>模块系统</p></li><li><p><code>new</code> 语法用于<a href="https://www.yuque.com/boyan-avfmj/aviatorscript/hzm6lr">创建对象</a></p></li><li><p><a href="https://www.yuque.com/boyan-avfmj/aviatorscript/sikgal">异常处理</a></p></li><li><p><a href="https://www.yuque.com/boyan-avfmj/aviatorscript/ma3zs3">命令行工具 aviator</a></p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>AviatorScript</strong> 可以单纯的作为脚本语言使用，也可以和 Java 配合使用。</p><h2 id="单纯的作为脚本语言使用"><a href="#单纯的作为脚本语言使用" class="headerlink" title="单纯的作为脚本语言使用"></a>单纯的作为脚本语言使用</h2><p>作为脚本语言使用时，需要下载一个 <code>aviator</code>，然后用它去执行脚本文件。</p><p><strong>下载：</strong></p><p>执行下面命令下载，如果你电脑没有安装 <code>wget</code> 工具，你也可以直接打开 <a href="https://raw.githubusercontent.com/killme2008/aviator/master/bin/aviator%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8A%8A%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E4%B8%8B%E6%9D%A5%E4%BF%9D%E5%AD%98%E6%88%90%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E3%80%82**%E7%84%B6%E5%90%8E%E6%8A%8A%E5%AE%83%E6%94%BE%E5%9C%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%A8%E5%B1%80%E8%AE%BF%E9%97%AE%E5%88%B0%E5%AE%83">https://raw.githubusercontent.com/killme2008/aviator/master/bin/aviator，然后把里面的内容复制下来保存成一个可执行文件。**然后把它放在环境变量中，可以全局访问到它</a>**</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/killme2008/aviator/master/bin/aviator</span><br><span class="line">$ <span class="built_in">chmod</span> u+x aviator</span><br></pre></td></tr></table></figure><p><strong>初始化：</strong></p><p>下载完后，需要执行一下命令，它会自动在 <code>~/.aviatorscrip</code> 下载所需要的依赖。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╰─$ aviator</span><br><span class="line">Downloading AviatorScript now...</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   148  100   148    0     0    249      0 --:--:-- --:--:-- --:--:--   248</span><br><span class="line">100   159  100   159    0     0    158      0  0:00:01  0:00:01 --:--:--   158</span><br><span class="line">100  583k  100  583k    0     0  51321      0  0:00:11  0:00:11 --:--:-- 35877</span><br><span class="line">Usage: java com.googlecode.aviator.Main [file] [args]</span><br><span class="line">     : java com.googlecode.aviator.Main -e [script]</span><br><span class="line">     : java com.googlecode.aviator.Main -v</span><br></pre></td></tr></table></figure><p><strong>执行脚本文件：</strong></p><p>下载好相关的环境后，就可以编写一个脚本文件了，文件名一般以 <code>.av</code> 结尾，这个不是必须的，你想以其他结尾也可以</p><p><strong>test.av：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">println</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后执行该脚本文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╰─$ aviator test.av</span><br><span class="line">Hello World!</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>界面输出 <code>Hello World!</code>，最后一行的 <code>null</code> 表示是整个表达式的执行结果，就是返回值的意思，比如定义 <code>return</code> 时，这个 null 就会变成 return 的值，我们做如下更改：</p><p><strong>test.av：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">println</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们添加了一个 <code>return</code> 数据，然后执行这个脚本文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╰─$ aviator test.av</span><br><span class="line">Hello World!</span><br><span class="line">success</span><br></pre></td></tr></table></figure><p>执行结果就会变成我们定义的 return 数据。</p><p>具体的可参考文档 <a href="https://www.yuque.com/boyan-avfmj/aviatorscript/ma3zs3"><strong>aviator 命令行</strong></a></p><h2 id="配合-Java-使用"><a href="#配合-Java-使用" class="headerlink" title="配合 Java 使用"></a>配合 Java 使用</h2><p>配合 Java 使用时，需要导入 Aviator 的依赖，可以在 [search.maven.org](<a href="https://search.maven.org/search?q=g:com.googlecode.aviator">https://search.maven.org/search?q=g:com.googlecode.aviator</a> AND a:aviator&amp;core&#x3D;gav) 查看可用的版本。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.googlecode.aviator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aviator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入依赖后，我们先来演示执行一个 <code>1+1</code> 操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) AviatorEvaluator.execute(<span class="string">&quot;return 1+1;&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>上面代码中，我们直接返回 <code>1+1</code> 的结果，然后输出，但是当我们执行的时候，就回报如下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.Integer</span><br><span class="line">at top.mjava.demo.AviatorDemo.demo5(AviatorDemo.java:19)</span><br><span class="line">at top.mjava.demo.AviatorDemo.main(AviatorDemo.java:15)</span><br></pre></td></tr></table></figure><p>这是因为<strong>在 Aviator 中任何整数都将被转换为 Long 类型</strong>，而 Long 类型是不能转换为 Integer 类型的，所以会报上面的错误。所以我们要将 int 改为 long 即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">long</span>) AviatorEvaluator.execute(<span class="string">&quot;return 1+1;&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="挂载-Java-方法"><a href="#挂载-Java-方法" class="headerlink" title="挂载 Java 方法"></a>挂载 Java 方法</h3><p>在 Aviator 中，除了可以使用它提供的法来创建函数外，还可以挂载 Java 的自定义方法，然后在 Aviator 脚本中使用。</p><p>定义自定义的 Java 方法时，需要继承 <code>AbstractFunction</code> 抽象类，然后重写 <code>call</code> 和 <code>getName</code> 这两个方法：</p><ul><li>call : 方法具体逻辑代码</li><li>getName : 在 Aviator 中使用时的函数名</li></ul><p><strong>定义自定义函数：</strong></p><p>这边自定义了一个加法运算的方法，传入两个参数然后计算它们的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddFunction</span> <span class="keyword">extends</span> <span class="title class_">AbstractFunction</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AviatorObject <span class="title function_">call</span><span class="params">(Map&lt;String, Object&gt; env, AviatorObject arg1, AviatorObject arg2)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">p1</span> <span class="operator">=</span> (<span class="type">long</span>) arg1.getValue(env);</span><br><span class="line">        <span class="type">long</span> <span class="variable">p2</span> <span class="operator">=</span> (<span class="type">long</span>) arg2.getValue(env);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> p1+p2;</span><br><span class="line">        <span class="keyword">return</span> AviatorLong.valueOf(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;add&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用自定义函数：</strong></p><p>如果要在 Aviator 脚本中使用这个自定义的函数时，需要先注册这个 Java 类，然后在 Aviator 脚本中使用 <code>getName()</code> 返回的方法名作为函数名来调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册自定义函数</span></span><br><span class="line">AviatorEvaluator.addFunction(<span class="keyword">new</span> <span class="title class_">AddFunction</span>());</span><br><span class="line"><span class="comment">// 使用自定义函数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">long</span>) AviatorEvaluator.execute(<span class="string">&quot;return add(2,1);&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.yuque.com/boyan-avfmj/aviatorscript/cpow90">https://www.yuque.com/boyan-avfmj/aviatorscript/cpow90</a></li><li><a href="https://code.google.com/archive/p/aviator/wikis/User_Guide_zh.wiki">https://code.google.com/archive/p/aviator/wikis/User_Guide_zh.wiki</a></li><li><a href="https://github.com/killme2008/aviatorscript">https://github.com/killme2008/aviatorscript</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;5.0&lt;/code&gt; 版本以前，它的名字是叫 &lt;strong&gt;Aviator&lt;/strong&gt; ，定位一直只是一个表达式引擎</summary>
      
    
    
    
    <category term="Java" scheme="https://greycode.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://greycode.top/tags/Java/"/>
    
    <category term="表达式引擎" scheme="https://greycode.top/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Aviator" scheme="https://greycode.top/tags/Aviator/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper单机伪集群搭建</title>
    <link href="https://greycode.top/archive/zookeeper/2B9475B258994C18BCC5FCFA4B6D81D2/"/>
    <id>https://greycode.top/archive/zookeeper/2B9475B258994C18BCC5FCFA4B6D81D2/</id>
    <published>2021-08-11T15:59:52.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<p>Error contacting service. It is probably not running.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Error contacting service. It is probably not running.&lt;/p&gt;
</summary>
      
    
    
    
    <category term="ZooKeeper" scheme="https://greycode.top/categories/ZooKeeper/"/>
    
    
    <category term="集群" scheme="https://greycode.top/tags/%E9%9B%86%E7%BE%A4/"/>
    
    <category term="分布式" scheme="https://greycode.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="ZooKeeper" scheme="https://greycode.top/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper客户端详解及可视化客户端</title>
    <link href="https://greycode.top/archive/zookeeper/8B8235DEF437432C99C81E97D68D0644/"/>
    <id>https://greycode.top/archive/zookeeper/8B8235DEF437432C99C81E97D68D0644/</id>
    <published>2021-08-09T14:54:39.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>我们可以去 <a href="http://zookeeper.apache.org/releases.html">ZooKeeper 官网</a> 下载，这里我下载了 <a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz">ZooKeeper 3.7.0</a> 版本</p><p>下载解压后，进入 <code>apache-zookeeper-3.7.0-bin/bin</code> 目录，这里有<strong>客户端</strong>、<strong>服务端</strong>和一些工具。在 Windows 中可以执行<code>.cmd</code> 结尾的执行文件，在 Mac 或 Linux 中可以执行 <code>.sh</code> 结尾的可执行文件。名为 <code>zkCli</code> 的文件就是 ZooKeeper 的客户端了，我们可以用这个客户端来连接到 ZooKeeper 注册中心，来对节点进行查看或增删操作。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>我是在 <strong>Mac 环境下演示使用的</strong></p></blockquote><p>接下来就说下这个客户端怎么使用。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>第一步就是要连接到 ZooKeeper 服务，当你执行 <code>zkCli.sh</code> 不带任何参数时，它默认是连接到本地的 <code>localhost:2181</code> 地址。如果你要连接到指定地址，可以使用 <code>-server</code> 配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./zkCli.sh -server localhost:2181</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以加上连接超时时间（单位：毫秒）</span></span><br><span class="line">./zkCli.sh -<span class="built_in">timeout</span> 3000 -server localhost:2181</span><br></pre></td></tr></table></figure><p>连接上后，终端就会变成这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] </span><br></pre></td></tr></table></figure><p>然后你可以输入 <code>help</code> 来查看执行的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZooKeeper -server host:port -client-configuration properties-file cmd args</span><br><span class="line">addWatch [-m mode] path <span class="comment"># optional mode is one of [PERSISTENT, PERSISTENT_RECURSIVE] - default is PERSISTENT_RECURSIVE</span></span><br><span class="line">addauth scheme auth</span><br><span class="line">close</span><br><span class="line">config [-c] [-w] [-s]</span><br><span class="line">connect host:port</span><br><span class="line">create [-s] [-e] [-c] [-t ttl] path [data] [acl]</span><br><span class="line">delete [-v version] path</span><br><span class="line">deleteall path [-b batch size]</span><br><span class="line">delquota [-n|-b|-N|-B] path</span><br><span class="line">get [-s] [-w] path</span><br><span class="line">getAcl [-s] path</span><br><span class="line">getAllChildrenNumber path</span><br><span class="line">getEphemerals path</span><br><span class="line"><span class="built_in">history</span></span><br><span class="line">listquota path</span><br><span class="line"><span class="built_in">ls</span> [-s] [-w] [-R] path</span><br><span class="line">printwatches on|off</span><br><span class="line">quit</span><br><span class="line">reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]</span><br><span class="line">redo cmdno</span><br><span class="line">removewatches path [-c|-d|-a] [-l]</span><br><span class="line"><span class="built_in">set</span> [-s] [-v version] path data</span><br><span class="line">setAcl [-s] [-v version] [-R] path acl</span><br><span class="line">setquota -n|-b|-N|-B val path</span><br><span class="line"><span class="built_in">stat</span> [-w] path</span><br><span class="line"><span class="built_in">sync</span> path</span><br><span class="line">version</span><br><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p>在客户端里面，也可以使用命令 <code>connect</code> 来切换连接的 ZooKeeper 的服务地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] connect localhost:2181</span><br></pre></td></tr></table></figure><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><h3 id="永久节点"><a href="#永久节点" class="headerlink" title="永久节点"></a>永久节点</h3><p>可以使用 <code>create</code> 命令来创建一个永久节点：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 18] create /node</span><br><span class="line">Created /node</span><br></pre></td></tr></table></figure><h3 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h3><p>临时节点当客户端断开后，这个节点就会被删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 19] create -e /tmp_node</span><br><span class="line">Created /tmp_node</span><br></pre></td></tr></table></figure><p>临时节点不能够有子节点，当要创建它的子节点时就会报错 <code>Ephemerals cannot have children</code> :</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] create -e /tmp_node/t1</span><br><span class="line">Ephemerals cannot have children: /tmp_node/t1</span><br></pre></td></tr></table></figure><h3 id="顺序节点"><a href="#顺序节点" class="headerlink" title="顺序节点"></a>顺序节点</h3><p>ZooKeeper 可以为我们自定创建递增的顺序节点</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 23] create -s /seq_node</span><br><span class="line">Created /seq_node0000000017</span><br><span class="line">[zk: localhost:2181(CONNECTED) 24] create -s /seq_node</span><br><span class="line">Created /seq_node0000000018</span><br><span class="line">[zk: localhost:2181(CONNECTED) 25] create -s /seq_node</span><br><span class="line">Created /seq_node0000000019</span><br></pre></td></tr></table></figure><h3 id="容器节点"><a href="#容器节点" class="headerlink" title="容器节点"></a>容器节点</h3><p>容器节点当其子<strong>所有节点</strong>都被删除时，它自己也会被删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建容器节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 39] create -c /container</span><br><span class="line">Created /container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建容器节点的子节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 43] create /container/c1</span><br><span class="line">Created /container/c1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 44] create /container/c2</span><br><span class="line">Created /container/c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器节点的子节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 46] delete /container/c1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 47] delete /container/c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过了一会后，容器节点被删除了</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 56] get /container</span><br><span class="line">org.apache.zookeeper.KeeperException<span class="variable">$NoNodeException</span>: KeeperErrorCode = NoNode <span class="keyword">for</span> /container</span><br></pre></td></tr></table></figure><h3 id="ttl-节点"><a href="#ttl-节点" class="headerlink" title="ttl 节点"></a>ttl 节点</h3><p>ZooKeeper 也可以为节点设置有效期，单位是毫秒。要创建这个节点时，需要 ZooKeeper 服务端在启动时设置 <code>zookeeper.extendedTypesEnabled=true</code> ，否则在创建时就会失败：<code>KeeperErrorCode = Unimplemented</code></p><p>创建时设置的过期时间单位时毫秒：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 57] create -t 3000 /ttl_node</span><br><span class="line">Created /ttl_node</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>在 <code>zkCli</code> 中可以用 <code>delete</code> 命令来删除节点，在删除一个节点时，必须保证该节点下面没有子节点</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] create /node1</span><br><span class="line">Created /node1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] delete /node1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有子节点的话，删除时会报错</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] create /node1</span><br><span class="line">Created /node1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] create /node1/n1</span><br><span class="line">Created /node1/n1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] delete /node1</span><br><span class="line">Node not empty: /node1</span><br></pre></td></tr></table></figure><p>如果你想一次性删除节点包括其所有子节点时，可以使用 <code>deleteall</code> 命令来进行删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 14] deleteall /node1</span><br></pre></td></tr></table></figure><h2 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h2><h3 id="查看所有子节点"><a href="#查看所有子节点" class="headerlink" title="查看所有子节点"></a>查看所有子节点</h3><p>我们可以用 <code>ls</code> 命令来查看某个节点的所有子节点，比如我们查看根目录下的所有节点时，就可以这样用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] <span class="built_in">ls</span> /</span><br><span class="line">[quota, zookeeper]</span><br></pre></td></tr></table></figure><p>查看 zookeeper 节点的子节点</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 21] <span class="built_in">ls</span> /zookeeper</span><br><span class="line">[config, quota]</span><br></pre></td></tr></table></figure><h3 id="查看节点的状态"><a href="#查看节点的状态" class="headerlink" title="查看节点的状态"></a>查看节点的状态</h3><p>可以用 <code>stat</code> 来查看一个节点的状态，比如我们查看根节点的状态时：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 22] <span class="built_in">stat</span> /</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0xe</span><br><span class="line">cversion = 4</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 2</span><br></pre></td></tr></table></figure><p><strong>字段说明：</strong></p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>czxid</td><td>创建znode的zxid</td></tr><tr><td>mzxid</td><td>最近一次修改znode的zxid(创建、删除、set直系子节点、set自身节点都会计数)</td></tr><tr><td>pzxid</td><td>最近一次修改子节点的zxid(创建、删除直系子节点都会计数，set子节点不会计数)</td></tr><tr><td>ctime</td><td>创建znode的时间，单位毫秒</td></tr><tr><td>mtime</td><td>最近一次修改znode的时间，单位毫秒</td></tr><tr><td>dataVersion</td><td>修改znode数据的次数</td></tr><tr><td>cversion</td><td>修改子节点的次数(创建、删除直系子节点都会计数，set子节点不会计数)</td></tr><tr><td>aclVersion</td><td>该znode的ACL修改次数</td></tr><tr><td>ephemeralOwner</td><td>临时znode节点的session id，如果不是临时节点，值为0</td></tr><tr><td>dataLength</td><td>znode携带的数据长度，单位字节</td></tr><tr><td>numChildren</td><td>直系子节点的数量(不会递归计算孙节点)</td></tr></tbody></table><h3 id="查看节点的数据"><a href="#查看节点的数据" class="headerlink" title="查看节点的数据"></a>查看节点的数据</h3><p>可以使用 <code>set</code> 命令来设置节点的数据，当要获取这个设置的数据时，就可以使用 <code>get</code> 命令来获取节点的数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 27] create /node</span><br><span class="line">Created /node</span><br><span class="line">[zk: localhost:2181(CONNECTED) 28] <span class="built_in">set</span> /node 我的数据</span><br><span class="line">[zk: localhost:2181(CONNECTED) 29] get /node</span><br><span class="line">我的数据</span><br></pre></td></tr></table></figure><h2 id="终端可视化客户端"><a href="#终端可视化客户端" class="headerlink" title="终端可视化客户端"></a>终端可视化客户端</h2><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/PP6ACH0.gif" alt="screen1"></p><p>下载地址：<a href="https://github.com/greycodee/zk-cli/releases">https://github.com/greycodee/zk-cli/releases</a></p><p>Github：<a href="https://github.com/greycodee/zk-cli">https://github.com/greycodee/zk-cli</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;我们可以去 &lt;a href=&quot;http://zookeeper.apache.org/releases.html&quot;&gt;ZooKeeper 官网</summary>
      
    
    
    
    <category term="ZooKeeper" scheme="https://greycode.top/categories/ZooKeeper/"/>
    
    
    <category term="分布式" scheme="https://greycode.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="ZooKeeper" scheme="https://greycode.top/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>小白学前端之TypeScript使用Vuex 4.0</title>
    <link href="https://greycode.top/vue/2CA7C67D02E74713A030F09651A5F164/"/>
    <id>https://greycode.top/vue/2CA7C67D02E74713A030F09651A5F164/</id>
    <published>2021-07-29T16:45:15.000Z</published>
    <updated>2022-04-16T02:52:58.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官方介绍：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>简单来说，Vuex 就像是前端的数据库或缓存，不管什么页面，只要 Vuex 里面有的数据，都可以去拿。</p><p>Vuex 分为 5 个部分：</p><ul><li>State：是数据源，存放数据</li><li>Getters：可以取得 State 的数据，然后自定义组装返回新的数据</li><li>Mutations：可以改变 State 的数据，建议方法执行是同步的</li><li>Actions：可以异步执行 Mutations 里的方法</li><li>Modules：每个 Module 都有各自的 State、Getters、Mutations、Actions</li></ul><p>这 5 个部分相辅相成。</p><h2 id="TypeScript-使用"><a href="#TypeScript-使用" class="headerlink" title="TypeScript 使用"></a>TypeScript 使用</h2><p>在 vue 项目根目录执行命令来进行 vuex 模块的安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vuex@next --save</span><br></pre></td></tr></table></figure><p>安装好后我们新建文件 <code>/src/store/store.ts</code> ,然后在里面定义 <code>InjectionKey</code> 和 <code>Store</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">InjectionKey</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, useStore <span class="keyword">as</span> baseUseStore, <span class="title class_">Store</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 State 数据类型的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型传递</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">key</span>: <span class="title class_">InjectionKey</span>&lt;<span class="title class_">Store</span>&lt;<span class="title class_">IState</span>&gt;&gt; = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">IState</span>&gt; (&#123; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于组合式API setup() 里，省的每次都传入 key </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useStore</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">baseUseStore</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>main.ts</code> 文件里使用上面定义的 vuex</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; store,key &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">.<span class="title function_">use</span>(store,key)</span><br><span class="line">.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>State 是存储数据源的地方，所以我们可以在这里存储我们的数据，比如我这边定义一个 <code>name</code> 字段，需要在接口 <code>IState</code> 添加定义数据类型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>createStore</code> 里添加数据</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">IState</span>&gt; (&#123; </span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ooooooh灰灰&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>数据我们已经定义好了，接下来就是要在页面访问这个数据了，下面提供了两种方式来访问 vuex 里的数据</p><h3 id="组合式-API-访问"><a href="#组合式-API-访问" class="headerlink" title="组合式 API 访问"></a>组合式 API 访问</h3><p>在组合式 API 中，我们可以直接导入刚才在 <code>/src/store/store.ts</code>  里定义的 <code>useStore()</code> 方法来访问 vuex 里的数据</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="comment">// 访问 state 里的 name 数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">state</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行代码的话就会在控制台打印 <strong>ooooooh灰灰</strong></p><h3 id="…toRefs-访问所有字段"><a href="#…toRefs-访问所有字段" class="headerlink" title="…toRefs() 访问所有字段"></a>…toRefs() 访问所有字段</h3><p>如果要在页面访问的话，可以利用 <code>...toRefs()</code> 来直接展开 store.state 里的<strong>所有字段</strong>，然后在页面直接访问 vuex 的 state 里的字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; name &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123; defineComponent, toRefs&#125; from &#x27;vue&#x27;;</span><br><span class="line">  import &#123; useStore &#125; from &#x27;./store/store&#x27;</span><br><span class="line"></span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    </span><br><span class="line">    setup()&#123;</span><br><span class="line">      let store = useStore()</span><br><span class="line">    </span><br><span class="line">      return &#123;</span><br><span class="line">        // 展开 state 所有的字段</span><br><span class="line">        ...toRefs(store.state)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="reactive-聚合单个字段"><a href="#reactive-聚合单个字段" class="headerlink" title="reactive 聚合单个字段"></a>reactive 聚合单个字段</h3><p>如果你想<strong>单个数据导入</strong>的话，可以直接和页面数据一起放在 <code>reactive</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, toRefs&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">  <span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="comment">// 把 vuex 的 state 的数据放进 reactive 里</span></span><br><span class="line">      <span class="keyword">let</span> params = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: store.<span class="property">state</span>.<span class="property">name</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...<span class="title function_">toRefs</span>(params),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="computed-访问单个字段"><a href="#computed-访问单个字段" class="headerlink" title="computed 访问单个字段"></a>computed 访问单个字段</h3><p>也可以使用 <code>computed</code> 模块来访问数据，要先导入 vue 里的 <code>computed</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; name &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123; defineComponent, computed&#125; from &#x27;vue&#x27;;</span><br><span class="line">  import &#123; useStore &#125; from &#x27;./store/store&#x27;</span><br><span class="line"></span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    </span><br><span class="line">    setup()&#123;</span><br><span class="line">      let store = useStore()</span><br><span class="line">      </span><br><span class="line">      return &#123;</span><br><span class="line">        name: computed(()=&gt;store.state.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>getters 里的方法在 <code>vuex/types/index.d.ts</code> 中是这样定义的</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Getter</span>&lt;S, R&gt; = <span class="function">(<span class="params">state: S, getters: <span class="built_in">any</span>, rootState: R, rootGetters: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p><strong>他有 4 个参数，分别是 state、getters、rootState、rootGetters</strong></p><p>其中，<strong>state</strong> 可以取得同级中 state 里的数据，<strong>getters</strong> 可以取得同级中 getters 其他的方法返回的数据</p><p>而 <strong>rootState</strong> 和 <strong>rootGetters</strong> 是在当当前 <strong>Getters</strong> 处于 <strong>module</strong> 中时，可以取得根部的 state 和 gatters 里的数据</p><p>比如我们可以将 state 里的变量封装成一句话然后返回：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">IState</span>&gt; (&#123; </span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ooooooh灰灰&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getters</span>:&#123;</span><br><span class="line">        <span class="title function_">newName</span>(state):<span class="built_in">string</span>&#123;</span><br><span class="line">          <span class="comment">// 通过 state 访问 name 字段</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;大家好！我是：&#x27;</span>+state.<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们要访问其他 getter 时，我们可以这样：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">IState</span>&gt; (&#123; </span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ooooooh灰灰&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getters</span>:&#123;</span><br><span class="line">        <span class="title function_">hello</span>(state,getters):<span class="built_in">string</span>&#123;</span><br><span class="line">          <span class="comment">// 通过 getters 访问其他 getter</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;大家好！我是：&#x27;</span>+state.<span class="property">name</span>+<span class="string">&#x27;,&#x27;</span>+getters.<span class="property">ageInfo</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">ageInfo</span>(state):<span class="built_in">string</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;年龄：&#x27;</span>+state.<span class="property">age</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组合式-API-访问-1"><a href="#组合式-API-访问-1" class="headerlink" title="组合式 API 访问"></a>组合式 API 访问</h3><p>我们可以在组合式 API 里像访问 state 的里数据一样访问 gatters 里的方法：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="comment">// 访问 getters 里的 hello 方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">getters</span>.<span class="property">hello</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此外，getters 也可以使用 <code>...toRefs()</code>、<code>computed</code> 这些方法来访问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; hello &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123; defineComponent, computed, toRefs &#125; from &#x27;vue&#x27;;</span><br><span class="line">  import &#123; useStore &#125; from &#x27;./store/store&#x27;</span><br><span class="line"></span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">      let store = useStore()</span><br><span class="line">      return &#123;</span><br><span class="line">        // 通过 computed 访问 getters 里的 hello </span><br><span class="line">        hello: computed(()=&gt;store.getters.hello),</span><br><span class="line">        </span><br><span class="line">        // 通过 ...toRefs() 访问</span><br><span class="line">        // ...toRefs(store.getters),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h2><p>如果你要改变 state 里的数据时，就要用到 Mutations 了，它可以提供改变 state 里数据的方法，它在 <code>vuex/types/index.d.ts</code> 中是这样定义的：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Mutation</span>&lt;S&gt; = <span class="function">(<span class="params">state: S, payload?: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>其中 state 可以拿到 state 里的数据，payload 是自定义传入的参数，后面有个问号，代表这是可选项</p><p>所以当我们要改变 state 的字段的值时，我们可以在 store.ts 中这样写代码 ：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">IState</span>&gt; (&#123; </span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ooooooh灰灰&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>:&#123;</span><br><span class="line">        <span class="title function_">changeName</span>(<span class="params">state</span>)&#123;</span><br><span class="line">            <span class="comment">// 改变 state 中 name 的值</span></span><br><span class="line">            state.<span class="property">name</span> = <span class="string">&#x27;greycode&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果要自定义传入参数的话，就可以这样写：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">IState</span>&gt; (&#123; </span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ooooooh灰灰&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>:&#123;</span><br><span class="line">        <span class="title function_">changeName</span>(<span class="params">state,newName:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">            <span class="comment">// 传入自定义字段并设置</span></span><br><span class="line">            state.<span class="property">name</span> = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组合式-API-访问-2"><a href="#组合式-API-访问-2" class="headerlink" title="组合式 API 访问"></a>组合式 API 访问</h3><p>在组合式 API 中，我们可以用 <code>commit</code> 来提交执行这个方法：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 提交执行 mutations 中 changeName 方法</span></span><br><span class="line">      <span class="comment">// store.commit(&#x27;changeName&#x27;)</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提交执行 mutations 中 changeName 方法,并传入自定义参数</span></span><br><span class="line">      store.<span class="title function_">commit</span>(<span class="string">&#x27;changeName&#x27;</span>,<span class="string">&#x27;自定义的&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      change</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="…mapMutations"><a href="#…mapMutations" class="headerlink" title="…mapMutations"></a>…mapMutations</h3><p>我们可以直接在组合式 API 中使用 <code>...mapMutations</code> 来获得 mutations 中的方法，然后直接在页面中调用这个方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 使用 ...mapMutations 来获得 mutations 中的方法</span></span><br><span class="line">      ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;changeName&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后直接在页面中使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; @click=&quot;changeName&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 也可以传入函数自定义参数 --&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; @click=&quot;changeName(’自定义名字‘)&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>当要异步改变 state 中的数据时，就要用到 Action 了，但是它不是直接改变 state 中的数据，而是通过异步执行 mutations 中的方法来间接改变 state 中的数据的 </p><p>它在 <code>vuex/types/index.d.ts</code> 中是这样定义的：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Action</span>&lt;S, R&gt; = <span class="title class_">ActionHandler</span>&lt;S, R&gt; | <span class="title class_">ActionObject</span>&lt;S, R&gt;;</span><br></pre></td></tr></table></figure><p>它支持两种类型的数据，一个是 ActionHandler&lt;S, R&gt; ，另一个是 ActionObject&lt;S, R&gt;。其中 ActionObject 一般用于 Module 中的命名空间，它们的定义如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ActionHandler</span>&lt;S, R&gt; = <span class="function">(<span class="params"><span class="variable language_">this</span>: Store&lt;R&gt;, injectee: ActionContext&lt;S, R&gt;, payload?: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ActionObject</span>&lt;S, R&gt; &#123;</span><br><span class="line">  root?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">handler</span>: <span class="title class_">ActionHandler</span>&lt;S, R&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只讲下 ActionHandler ，另外一个等到 Module 模块中再讲。</p><p>在 ActionHandler  中，它有 3 个参数，分别是 this、injectee、payload，其中 this 代表的是整个 Store 对象，injectee 是当前 Action 所在的上下文，payload 是可以自定义的传入参数</p><p>所以我们可以这样使用它：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore&lt;<span class="title class_">IState</span>&gt; (&#123; </span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;ooooooh灰灰&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">mutations</span>:&#123;</span><br><span class="line">        <span class="title function_">changeName</span>(<span class="params">state</span>)&#123;</span><br><span class="line">            state.<span class="property">name</span> = <span class="string">&#x27;异步改名&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>:&#123;</span><br><span class="line">        <span class="title function_">asyncChange</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">          <span class="comment">// 两秒后更改名字</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">            ctx.<span class="title function_">commit</span>(<span class="string">&#x27;changeName&#x27;</span>)</span><br><span class="line">          &#125;,<span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组合式-API-访问-3"><a href="#组合式-API-访问-3" class="headerlink" title="组合式 API 访问"></a>组合式 API 访问</h3><p>定义好 actions 后，我们可以在组合式 API 中用 <code>dispatch</code> 来分发 action：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">syncChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 执行 actions 中的 asyncChange 方法</span></span><br><span class="line">      store.<span class="title function_">dispatch</span>(<span class="string">&#x27;asyncChange&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      syncChange</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="…mapActions"><a href="#…mapActions" class="headerlink" title="…mapActions"></a>…mapActions</h3><p>也可以用 <code>...mapActions</code> 来直接获得 actions 中的方法：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...<span class="title function_">mapActions</span>([<span class="string">&#x27;asyncChange&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>页面使用的话和 mutation 差不多，直接访问 actions 中的方法名就可以了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; @click=&quot;asyncChange&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>除此之外还有一个 Module 模块，不过一般小项目用不到而且内容也比较多，下次再学吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;官方介绍：Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。它采用集中式存储管理应用的所有组</summary>
      
    
    
    
    <category term="Vue" scheme="https://greycode.top/categories/Vue/"/>
    
    
    <category term="Vuex" scheme="https://greycode.top/tags/Vuex/"/>
    
    <category term="Vue" scheme="https://greycode.top/tags/Vue/"/>
    
    <category term="TypeScript" scheme="https://greycode.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>利用腾讯位置API进行的阿里云DDNS工具</title>
    <link href="https://greycode.top/tool/9ACF61395A77470CA029D24AEC2CA42F/"/>
    <id>https://greycode.top/tool/9ACF61395A77470CA029D24AEC2CA42F/</id>
    <published>2021-07-26T16:08:12.000Z</published>
    <updated>2022-04-16T02:52:58.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/greycodee/aliyun-ddns"><img src="https://github-readme-stats.vercel.app/api/pin/?username=greycodee&repo=aliyun-ddns" alt="aliyun-ddns"></a></p><p>本应用是基于阿里云SDK进行开发的，可以动态更新阿里云域名的DNS解析，运行环境是 <code>Python 3</code></p><p>利用<a href="https://lbs.qq.com/">腾讯位置</a>提供的 API 进行公网 IP 的获取，可以查看<a href="doc/tencent_lbs.md">如何获取腾讯位置的 API 密钥</a></p><p>由于腾讯位置的 API 免费配额为每日 10000 次，请合理使用</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>程序从环境变量中获取配置，运行前<strong>先设置环境变量</strong></p><table><thead><tr><th>环境变量</th><th>说明</th></tr></thead><tbody><tr><td>ALI_ACCESS_KEY_ID</td><td>阿里云 ACCESS_KEY_ID（必填）</td></tr><tr><td>ALI_ACCESS_KEY_SECRET</td><td>阿里云 ACCESS_KEY_SECRET（必填）</td></tr><tr><td>ALI_REGION_ID</td><td>阿里云区域 ID（默认：cn-hangzhou）</td></tr><tr><td>DNS_TYPE</td><td>解析类型（默认：A）</td></tr><tr><td>DNS_DOMAIN</td><td>域名（必填）</td></tr><tr><td>DNS_SUB_DOMAIN</td><td>二级域名（默认：@）</td></tr><tr><td>TENCENT_LBS_KEY</td><td>腾讯位置应用 KEY</td></tr><tr><td>TENCENT_LBS_SK</td><td>腾讯位置应用签名加密 SK</td></tr></tbody></table><h3 id="环境字段说明"><a href="#环境字段说明" class="headerlink" title="环境字段说明"></a>环境字段说明</h3><p><strong>DNS_TYPE</strong> 支持的解析类型：</p><blockquote><p>点击查看<a href="https://help.aliyun.com/document_detail/29805.html?spm=a2c4g.11186623.2.8.4d3316267Ov7hF">官方详细说明</a></p></blockquote><ul><li>A：将域名指向一个IPV4地址</li><li>CNAME：将域名指向另外一个域名</li><li>AAAA：将域名指向一个IPV6地址</li></ul><p><strong>DNS_SUB_DOMAIN</strong> 域名前缀，常见用法有：</p><ul><li><p>www：解析后的域名为<a href="http://www.aliyun.com./">www.aliyun.com。</a></p></li><li><p>@：直接解析主域名 aliyun.com。</p></li><li><p>*：泛解析，匹配其他所有域名 *.aliyun.com。</p></li><li><p>mail：将域名解析为mail.aliyun.com，通常用于解析邮箱服务器。</p></li><li><p>二级域名：如：abc.aliyun.com，填写abc。</p></li><li><p>手机网站：如：m.aliyun.com，填写m。</p></li><li><p>显性URL：不支持泛解析（泛解析：将所有子域名解析到同一地址）</p></li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>当设置好环境变量后，使用以下命令安装依赖</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requeirments.txt</span><br></pre></td></tr></table></figure><p>安装依赖后，直接运行 <code>main.py</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><h2 id="以-Docker-运行"><a href="#以-Docker-运行" class="headerlink" title="以 Docker 运行"></a>以 Docker 运行</h2><p>如果你本地没有 python 环境，可以直接使用 docker 来运行本程序</p><p>先拉取镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull greycodee/aliyun-ddns</span><br></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -e ALI_ACCESS_KEY_ID=&quot;阿里云AK&quot; \</span><br><span class="line">              -e ALI_ACCESS_KEY_SECRET=&quot;阿里云AKS&quot; \</span><br><span class="line">              -e DNS_DOMAIN=&quot;你的域名&quot; \</span><br><span class="line">              -e DNS_SUB_DOMAIN=&quot;二级域名名称&quot; \</span><br><span class="line">              -e TENCENT_LBS_KEY=&quot;腾讯位置应用KEY&quot; \</span><br><span class="line">              -e TENCENT_LBS_SK=&quot;腾讯位置应用签名SK&quot; \</span><br><span class="line">              greycodee/aliyun-ddns</span><br></pre></td></tr></table></figure><p>如果你想看日志的话，可以使用 <code>-v</code> 命令把 docker 容器里的 <code>/root/logs</code> 日志目录挂载出来，这里面存放着程序的运行日志</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>在本目录中的 <strong>Dockerfile</strong> 文件中，更改文件里的环境变量参数为你的数据，具体参数字段含义见上文介绍。<br>更改完参数后，可以在<strong>当前目录</strong>使用 <code>docker build</code> 构建命令来构建你自己来镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t 设置镜像标签  .</span><br></pre></td></tr></table></figure><p>构建完成后就可以使用命令来运行你刚才构建的镜像了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d 设置的镜像标签</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/greycodee/aliyun-ddns&quot;&gt;&lt;img src=&quot;https://g</summary>
      
    
    
    
    <category term="Tool" scheme="https://greycode.top/categories/Tool/"/>
    
    
    <category term="DDNS" scheme="https://greycode.top/tags/DDNS/"/>
    
  </entry>
  
  <entry>
    <title>UML箭头在Java中的含义</title>
    <link href="https://greycode.top/gof/234C81B9931C44CB9B88E0E53210BB48/"/>
    <id>https://greycode.top/gof/234C81B9931C44CB9B88E0E53210BB48/</id>
    <published>2021-07-18T20:17:38.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><blockquote><p>在 Java 中表示继承关系，空心箭头指向父类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/fi3SUYimage-20210717181253414-20211008162305145.png" alt="image-20210717181253414"></p><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/CWFFnaimage-20210718173428923-20211008162258404.png" alt="image-20210718173428923"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>表示实现接口，箭头指向接口类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/XoAFNsimage-20210717181304829-20211008162246523.png" alt="image-20210717181304829"></p><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/OlaaSSimage-20210718173938989-20211008162251101.png" alt="image-20210718173938989"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iter</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerImpl</span> <span class="keyword">implements</span> <span class="title class_">Iter</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><blockquote><p>表示依赖关系，某个类的方法必须依赖另一个类才可以执行，箭头指向被依赖的类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/9ULJU5image-20210718171936788.png" alt="image-20210718171936788"></p><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/YEh93vimage-20210718174817997.png" alt="image-20210718174817997"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是 A 类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        a.testA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><blockquote><p>表示关联关系，两个类的关系是平等的</p><p><strong>可以双向关联，A 可以关联 B，B 也可以关联 A</strong></p><p>箭头指向被关联的类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/effJpHimage-20210717181329532-20211008162235439.png" alt="image-20210717181329532"></p><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/p17PX4image-20210718201348840.png" alt="image-20210718201348840"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是 A 类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">        a.testA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><blockquote><p>表示聚合关系，<strong>聚合是关联的一种特例，在代码上两者没有什么区别</strong>。</p><p><strong>单向关联，A 能关联 B，B 不能关联 A</strong></p><p>尾部为空棱形，也可以是直线</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/fKgWIFimage-20210718195546287.png" alt="image-20210718195546287"></p><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/DvBzVKimage-20210718200435303-20211008162227330.png" alt="image-20210718200435303"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;A&gt; a;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>表示组合关系，也是<strong>关联关系的一种</strong></p><p>表示强关联关系，被关联的类的生命周期会随关联类的生命周期一起产生和消失</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/15FMoXimage-20210718195556115-20211008162219555.png" alt="image-20210718195556115"></p><p><strong>示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/1jOTPHimage-20210718201118928-20211008162213446.png" alt="image-20210718201118928"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>聚合和组合的区别：聚合是个体离开了整体，依然可以存在.<br>                                       组合是个体和整体不可以分开，个体不能离开整体单独存在。</p><p>依赖，关联 和聚合，组合的区别：依赖，关联 : 类之间的关系是在同一层次上.<br>                                                               聚合，组合: 类之间的关系表现为整体和部分。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/zhuyu714997369/article/details/51983871">https://blog.csdn.net/zhuyu714997369/article/details/51983871</a></li><li><a href="https://zhuanlan.zhihu.com/p/109655171">https://zhuanlan.zhihu.com/p/109655171</a></li><li><a href="https://blog.csdn.net/qq_31655965/article/details/54645220">https://blog.csdn.net/qq_31655965/article/details/54645220</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛化&quot;&gt;&lt;a href=&quot;#泛化&quot; class=&quot;headerlink&quot; title=&quot;泛化&quot;&gt;&lt;/a&gt;泛化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Java 中表示继承关系，空心箭头指向父类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;ht</summary>
      
    
    
    
    <category term="UML" scheme="https://greycode.top/categories/UML/"/>
    
    
    <category term="UML" scheme="https://greycode.top/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>记一次很久以前做的梦【加密】</title>
    <link href="https://greycode.top/archive/essay/8B40046C17644103BD2A256EB938884C/"/>
    <id>https://greycode.top/archive/essay/8B40046C17644103BD2A256EB938884C/</id>
    <published>2021-07-15T08:14:37.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间：2019-12-19-07-23"><a href="#时间：2019-12-19-07-23" class="headerlink" title="时间：2019-12-19 07:23"></a>时间：2019-12-19 07:23</h2><p>RGwc3OqLQr&#x2F;FK7bX9qFgbl1FD1WZLruNkeFBP4vHyDejXpJhzV309eABiP0e+YiX5wKAD0GaALo74u1B39tyIUFaMrQAVV5M60sGphzkL2hf0ad5&#x2F;0JAqGXgDy01ustT&#x2F;w+bAGA8As3jc+3CexZ8CfqJsrOp7vt0aE8zzqKV0IbSL3b5u4wpBfp4Rb7+4b7lES9sbZmD37mXP5bJ0X94Z6W38oSSUj6aiLpDI9kllGxSWavZK+hQk1eWuAThn833cjXVtaxq7Mruglvc+eo4ok2Fm56uCdnq2RiUi5nu9e0bkGXyv8ELwr3RcVjMQdHQB8CK&#x2F;OFuNXltCRWNKlH6G2fyrPO+D+Sg6zbolkLHl326Ja3co0fDuLm6MxbLLwubwjfci0&#x2F;ZXjGOCKodAfvEtrDmkd0l2HYaOTbH6nOu+3GwXr+3QwdoxhFrVPjpkvjWcs4VNieiqiynXeNBflPR66ZrscQtZRVX77DUXT3jZdQ5rV7a6ZyWDr9ZgET86YQlGFxcW62wsBnMBt9STCFCUhbhYdccrBOAMJuZXfccIDuBgqelngufQRinLHRJiv0ihN2QhNuJFKkkTxSgswrMjLWhMGgKs8fbfnK82myiWIgqRnF6geCydTX8UAS3dTR1f0XJKEJuUNzc87uzszP+EZIcZ+JnCLjLNnJXJG9XVlLKElLmiwXNi4zDnP6NHGa7ikvac7mHR2SsWGL3&#x2F;v4pZtSNiwoZW3pPaK6Id+eg+srKoB7GTQNKZIsDuJh8cMziJF7cr1KvH7LZRMpB4MpeyvLmgz8oo3soLiGFVhl5wMrcqbc8H4qtnC4mI9iT5Z1lPBtq13+bYyplOY+G0soMOvbtkei7nWxIz3fh17gqMZvlTikEGcMNHGTs+wwgtsbreqR54iWEVuOxfYD+eYArFujw+iJRCsUCYWepGeVGNpZwlsuKQ+EH0sIJ1c4srVN73BYyE9nHw34W9CHY1MkOhUmXflbaBxz7E+AWfiUiZEWpWwvXOfTtWRuJV0htuCPmA63XgHn6JAHadlf5OY4l1BNewOWXVDPYEChsONoPSmTFxjq&#x2F;Qop83AqoOtxoaPqfWLXM+s8AqMjfWDQkzDMuxUnMO9fxiEze7J+qMZw7y2W+37NgPQHZBcG3Q8Vd&#x2F;ArxjfMQaZO11cYsW+RQkhuXj6lvsbs31+j&#x2F;Od4mA0XPpJ2rKIVC&#x2F;ueVAP8BuTBAzMN8ndDHXkKctT17eCUXz7w+t9n4h4MZxQQPegz9d3ULLabcdCJ167fpJ+8&#x2F;iXQhcJXihJeNXefkPcVrkxF+Tfj&#x2F;r73rSbTgtK+LseIedY1u17&#x2F;8itWpPlPqlVDC6dzSECBofynwSHADsXl+CBFpkstT3JPiSRTnVmWcta4H9kHthp4yG8Hqc2O6fJnodDIjwa6uzS0N8o95wHz79dDtDHKSpGsjtjotT54qCeI9z3T9FMSwKrN2AJn&#x2F;1fQdRA56QjnGFLeE8EkYY5Ix6tsk9XFcqAeLC1UbWIoaEqUdILSo9e&#x2F;TAUizEf+01YBHrsec+o2lEGl8QjthfxhlEFDNgTD0Lt4Cb2ytqpMJZXxFrqqUYOOc2+Lq0&#x2F;xJPHCKHYf8vLZEfx7LzcLbwLk+BVnxm6JqQVXXWMM2BblrFCX2CAIuhd8m0lztKUrK5OVG0TyEeLrOpB6&#x2F;YfXm6MPIOttooJFzCBZAKpWt70Xwwfwxrr7r0qMZziWv8oTiFG4lSvGE0VvCwN9hZoLvFh6bMFpnz&#x2F;bv0L8HMSxBmOyanQm01HhX6KXcyNSbW9Ep2Qxkw+eC034r+HQzV2t+qFkbpNFMb0DatDetvdBZyvlTvlPNcxJCcxEqe&#x2F;gxb9DRzKNPyy8eM&#x2F;P4Wem+NW7GFZTfXZQ6uj712J&#x2F;vQddDF9ukf&#x2F;jXJkEShhLTs9+JFhR9zjnOljLfNhmB8UzIUBno1d+qqzlC+ZiHzkaRbMnATdOYqW0dBIf5f5wIq31M4GC5mkQzxBVQ8Zqxxu5LCLGRrm+2dro8O27&#x2F;B5D74h0s&#x2F;rUmbj8Qxxf32rNjj0+TAZIIFh&#x2F;3pQjdbwNiABQZUpLBtYWSiZSZ5ivKAgzK6H1uVAlrillqMWJDjLsU6yO1sGb6lMBgKiIuGD2MWHj6moa+JUygW+gWo9m7XVe0q6y6CveMERblK4nXsgurUqH4j91uqyu6c0kccGY8Oei6opdzG49&#x2F;53IJg8YQo6TnK+plLdg1ezfanf20QwHBV1IHNYFWiTUHVO88EJuvLSAPgDdiVCOzO0KjXxjqOiq7lDw+OFbYaYyUoE1nwywhgE1TbBJdR54em&#x2F;CC4lY+14GNDTTAaN9ATWLCSPJWQnsDR799HCBZcGumWHB303Zcti4&#x2F;hKKmUW1JH59XxL4dtLup7fER05tm7vtVJ5ZCd0r1+R7QOzPIszOqZ+B2OifcYLVAelM7OGtIZbOmIWQbU11K45P16Y6GVZicmSTPSKXrvAB6nhOD0&#x2F;we&#x2F;UbqpU6iNu5ZRTgcZcxyrgU2TzWaKgfcX5ynMjk0TAqvYKYHAXMhMIUE6tEMMithQ1WkasGcv0+r6Hu8jPrc9&#x2F;Gvlf4u+4fl9knAf7JCgONAi4ds&#x2F;p6rwGAGtZbvzcAvxF7p04RcX0MY6A53z0tsFIcE46Uu&#x2F;KuxhWVyufVwlrHfIek6k8hHTspNH8bztwUJLU6gBRP9SpRrZrZIhDPII19VXNFVWdujdwcu7dcNuuoXPofulrbbHSyYaSaxK&#x2F;RdHh7yjViodnoUp3WaTNDZtzRlICXyZm73kD7qqHyR6nyqnVFG43Zd+Xcic2HJzEhSMYG6Ddlyc6AzYSCJeoDCY9M6dpPFKplBpQRL8g4LjOLHwd7BMlXqqcvjAmJpfHSlByX5KEml7a3V4jVKoIhoq1B5EvoNELDwUah8nnJjh8CKJevnuNx2NRUr&#x2F;QNzIfHTRGKCYHua70wUQX7m+lcNMc&#x2F;EG3TLqr+qyXMFjXihPxRLL+Uc9LBDbCIMh1Zpirr&#x2F;0+6U4twTr&#x2F;ipWU5SmOxf0O+OFl2NjOH7u8MwkXT1yWTS09Nfu3tLHFA0EmqJxgceNea8uegh+KFo4Fnf4oTd1wwg6c3cE8RX7okJ5ZDMzWCifUEwzdturrhnaarzbZT&#x2F;aCIAn4Epu4&#x2F;G0wgJSZL5oos889CaEJcmGkkJ6XSTd87ArxLOu143GSoSxVj6dlMGYLfcnJIjX3NJ0kHJdSROY9f6Kd0Moh&#x2F;3fupqbLxtyP9bKQKPtpfw4pT2&#x2F;Kd2nmPeBhxMIqIap4b3zKL5PzBF&#x2F;t6faSIMANeUoU9+oD1LU5FVfkoz5Icd7aW73SNLnwFxvXXUkuR&#x2F;Dkcry3vJVOeKuxV6m6L6qqplQtCiyYzTc01Zllr4e34dYU0&#x2F;QOfId3TI4Ork17iAHGGu+JY8Kud55p2Ph3NZN9nLryFzyjAsgaRY5YJnrJ0&#x2F;vs+0yS3wLYvXWIy1rhJHytZRS7AzR+TjX+GRAFAajy5zkouA7owJbn1L8UFvzlbDTLFHzhxVMI+DsTddmNqU70wOP2Goh8c3HnOLf77Sn6l6qS+eL18+ZcTm8RhXN8+tT2&#x2F;id+GLg60kgFIQggJVgQV8qKOqfSnyE4v1szSmSnGxrlZHNSzBg18XppzmNxAbNHjPiauLVGw&#x2F;qPWvm4ZGvtYv23rLsA0cdLnjnmnlCg&#x2F;oh&#x2F;8juTf3GsX5VVS7sGIFZCJh&#x2F;RRzLmwvXq2LZgBhhdD607xq7AFhuazYpVXcP6axrAWl3ikqYYGzAtesSzc&#x2F;yK9hhhvPcO+UhhkfWrlLdubzSBP60ycIhCSMG+OhG2U5XZLaSpMZghnpf8tu2uFiH6xkiFHAunxseHecrBstXQZ4jzVL3aFv3TpyQG19dgKIlukZDpSFuLZLFW&#x2F;fe5So5mNfp&#x2F;zgezEXaZz&#x2F;TIkD&#x2F;HMpm18nov2oPuIOi2HFNwSZoExvORHzRCXcfci8&#x2F;+m8VH9aF31EwiapPfFmjBWTAtcUI6s+T5Xf55d245Mi0XYQtWkqxLhIXfN0uyJBekVBNCKS7A2J0qjR5weYpAz&#x2F;mnLX7xVfIGBanizxcag1GsOS70iPp4WuVTMrwVH9RvsCP+3n3wrMFkfrtQnjMx+GWJx3v3vl4fk1o5istwlrT3R3Z630OIgn6Wsdz43OWI4MIp8sJuKqQYntU7XkmSwxerSSOOr64+u9H3WKyUxzgQ8bEqH+i8xjRajjlrYQ8iZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM&#x2F;c5lGWNE+gMg7abztKO9CPnQscEvP0OhWvdMO2k9oBXJJ5MV&#x2F;g&#x3D;</p>]]></content>
    
    
    <summary type="html">本文采用AES-ECB模式 填充Pkcs7 加密，密文编码为base64。</summary>
    
    
    
    <category term="Essay" scheme="https://greycode.top/categories/Essay/"/>
    
    
    <category term="抒发情感" scheme="https://greycode.top/tags/%E6%8A%92%E5%8F%91%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Quarkus项目配置方式详解</title>
    <link href="https://greycode.top/archive/quarkus/3EC6E900CDCB4BCEBA3B0BE40C9AADBB/"/>
    <id>https://greycode.top/archive/quarkus/3EC6E900CDCB4BCEBA3B0BE40C9AADBB/</id>
    <published>2021-07-12T17:29:23.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置加载流程"><a href="#配置加载流程" class="headerlink" title="配置加载流程"></a>配置加载流程</h2><p>Quarkus 可以从多个地方获取项目的配置，它读取配置优先级入下图，在下面的优先级中，一旦读取到某个配置，就不会再继续读取后面配置中的这个配置了。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/XRTAgG7.png" alt="config-sources"></p><h2 id="0x1-System-Properties"><a href="#0x1-System-Properties" class="headerlink" title="0x1 System Properties"></a>0x1 System Properties</h2><p>系统属性可以在启动期间通过 <code>-D</code> 标志传递给应用程序。</p><p>比如要设置 http 服务的运行端口，各个运行方式传递系统参数的方式如下：</p><ul><li><strong>Quarkus dev</strong>模式：<code>mvn quarkus:dev -Dquarkus.http.port=8888</code></li><li>运行 <strong>jar</strong> 包：<code>java -Dquarkus.http.port=8888 -jar quarkus-run.jar</code></li><li>运行 <strong>native-image</strong>：<code>app-runner -Dquarkus.http.port=8888</code></li></ul><h2 id="0x2-Environment-variables"><a href="#0x2-Environment-variables" class="headerlink" title="0x2 Environment variables"></a>0x2 Environment variables</h2><blockquote><p>环境变量的名字遵循 <a href="https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources">MicroProfile Config</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Environment Variables Mapping Rules</span><br><span class="line">Some operating systems allow only alphabetic characters or an underscore, _, in environment variables. Other characters such as ., /, etc may be disallowed. In order to set a value for a config property that has a name containing such disallowed characters from an environment variable, the following rules are used.</span><br><span class="line"></span><br><span class="line">The ConfigSource for the environment variables searches three environment variables for a given property name (e.g. com.ACME.size):</span><br><span class="line"></span><br><span class="line">1. Exact match (i.e. com.ACME.size)</span><br><span class="line"></span><br><span class="line">2. Replace each character that is neither alphanumeric nor _ with _ (i.e. com_ACME_size)</span><br><span class="line"></span><br><span class="line">3. Replace each character that is neither alphanumeric nor _ with _; then convert the name to upper case (i.e. COM_ACME_SIZE)</span><br><span class="line"></span><br><span class="line">The first environment variable that is found is returned by this ConfigSource.</span><br></pre></td></tr></table></figure></blockquote><p>环境变量的话各个系统设置的方式不一样，具体可以查一下自己系统设置环境变量的方式，一般 <strong>Unix</strong> 类的系统设置环境变量一般分为<strong>命令行设置</strong>和<strong>环境变量文件配置</strong></p><ul><li>命令行配置：<code>export QUARKUS_HTTP_PORT:8888</code></li><li>配置文件配置：环境变量配置文件又分用户变量配置文件和系统变量配置文件，直接在对应的配置文件里加上这一样就可以了，但是一般不推荐这么用</li></ul><h2 id="0x3-env-文件"><a href="#0x3-env-文件" class="headerlink" title="0x3 .env 文件"></a>0x3 .env 文件</h2><blockquote><p><strong>注意：.env 文件中的环境变量无法像普通的环境变量通过 System.getenv(String) API 获得。</strong></p></blockquote><p><code>.env</code> 文件的作用和环境变量类似，但是作用域更小，<strong>它只作用于当前项目，不像环境变量可以作用于所有项目</strong>。</p><p>它的设置方式是在 <code>.env</code> 文件里配置键值对的方式来设置变量，键名称和设置环境变量一样遵守 <a href="https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources">MicroProfile Config</a> 规范</p><p>使用方式：</p><ul><li>对于 <strong>dev</strong> 模式：可以放在项目的根目录下来使用，<strong>但是不要把它和代码一起打包</strong></li><li>对于 <strong>jar</strong> 和 <strong>native-image</strong> 运行方式下：可以将 <code>.env</code> 文件放在和 jar 包或 native-image 同一目录下</li></ul><h2 id="0x4-Quarkus-Application配置文件"><a href="#0x4-Quarkus-Application配置文件" class="headerlink" title="0x4 Quarkus Application配置文件"></a>0x4 Quarkus Application配置文件</h2><p>Quarkus 和 Spring Boot 项目一样，支持 <code>application.properties</code> 配置文件。同时在 <strong>jar</strong> 包和 <strong>native-image</strong> 的运行模式下还支持当前 jar 文件和native-image 文件同目录下 <strong>config 文件夹</strong>里的 <code>application.properties</code> 配置文件，并且 <strong>config 文件夹</strong>里的配置文件优先级高于项目 <strong>resources 文件夹</strong>里的配置文件</p><blockquote><p>对于 dev 的运行模式下，项目也可以使用 config 文件里的配置文件，就是手动把 config 文件夹移到 <strong>target 文件夹</strong>里，但是在使用 <code>mvn clean</code> 命令时会把这个文件夹清理掉，到时候又要自己手动重新创建 config 文件夹和里面的配置文件，所以在 dev 模式下不推荐使用 <code>config/application.properties</code></p></blockquote><h2 id="0x5-MicroProfile-配置文件"><a href="#0x5-MicroProfile-配置文件" class="headerlink" title="0x5 MicroProfile 配置文件"></a>0x5 MicroProfile 配置文件</h2><p>它放在 <code>src/main/resources/META-INF/microprofile-config.properties</code> 里</p><p>它的工作原理和项目的 resources 文件夹下的 application.properties 完全相同，建议使用 resources 文件夹下的配置文件</p><h2 id="使用-yml-配置文件"><a href="#使用-yml-配置文件" class="headerlink" title="使用 yml 配置文件"></a>使用 yml 配置文件</h2><p>以上配置中，除了系统属性、环境变量、.env 文件外，配置文件都可以支持 yml 格式的配置，不过需要额外添加依赖</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ol><li>pom.xml 文件添加依赖</li></ol>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.quarkus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quarkus-config-yaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>或者可以直接用 maven 命令来添加拓展依赖</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mvnw quarkus:add-extension -Dextensions=&quot;io.quarkus:quarkus-config-yaml&quot;</span><br></pre></td></tr></table></figure><h3 id="添加yml文件"><a href="#添加yml文件" class="headerlink" title="添加yml文件"></a>添加yml文件</h3><p>移除<code>src/main/resources/application.properties</code> 文件，添加 <code>src/main/resources/application.yaml</code> 文件</p><p>如果两个文件都存在，Quarkus 会优先使用来自 <code>yml</code> 的配置，然后再使用 <code>properties</code> 的配置，所以为了不搞混淆，建议删除 <code>properties</code> 文件。</p><p>配置文件扩展名支持 <code>yml</code> 和 <code>yaml</code></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://quarkus.io/guides/config-yaml">https://quarkus.io/guides/config-yaml</a></li><li><a href="https://quarkus.pro/guides/config.html">https://quarkus.pro/guides/config.html</a></li><li><a href="https://quarkus.io/guides/config-reference">https://quarkus.io/guides/config-reference</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置加载流程&quot;&gt;&lt;a href=&quot;#配置加载流程&quot; class=&quot;headerlink&quot; title=&quot;配置加载流程&quot;&gt;&lt;/a&gt;配置加载流程&lt;/h2&gt;&lt;p&gt;Quarkus 可以从多个地方获取项目的配置，它读取配置优先级入下图，在下面的优先级中，一旦读取到某个配置，</summary>
      
    
    
    
    <category term="Quarkus" scheme="https://greycode.top/categories/Quarkus/"/>
    
    
    <category term="Quarkus" scheme="https://greycode.top/tags/Quarkus/"/>
    
  </entry>
  
  <entry>
    <title>Quarkus构建native-image遇到的问题及解决</title>
    <link href="https://greycode.top/archive/quarkus/5756337C1CEA4B599E678A3380DCFE00/"/>
    <id>https://greycode.top/archive/quarkus/5756337C1CEA4B599E678A3380DCFE00/</id>
    <published>2021-07-09T17:44:33.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本机构建-native-image"><a href="#本机构建-native-image" class="headerlink" title="本机构建 native-image"></a>本机构建 native-image</h2><p>如果你本地安装了 Graal VM 的话，可以在项目目录下直接执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package -Pnative</span><br></pre></td></tr></table></figure><p>构建的时间比较长，构建完成后就会在 <code>./target</code> 目录下生成一个二进制执行文件，一般名字是 <code>quarkus-demo-1.0-runner</code>，直接执行这个二进制文件就可以运行项目了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  target: ./quarkus-demo-1.0-runner </span><br><span class="line">__  ____  __  _____   ___  __ ____  ______ </span><br><span class="line"> --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ </span><br><span class="line"> -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \   </span><br><span class="line">--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   </span><br><span class="line">2021-07-09 16:54:10,812 INFO  [io.quarkus] (main) quarkus-demo 1.0 native (powered by Quarkus 2.0.1.Final) started in 0.121s. Listening on: http://0.0.0.0:8080</span><br><span class="line">2021-07-09 16:54:11,041 INFO  [io.quarkus] (main) Profile prod activated. </span><br><span class="line">2021-07-09 16:54:11,041 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, smallrye-context-propagation]</span><br><span class="line">^C2021-07-09 16:55:12,904 INFO  [io.quarkus] (Shutdown thread) quarkus-demo stopped in 0.008s</span><br></pre></td></tr></table></figure><h2 id="容器构建-native-image"><a href="#容器构建-native-image" class="headerlink" title="容器构建 native-image"></a>容器构建 native-image</h2><p>如果你本地没有安装 Graal VM 的话，Quarkus 官方还提供了一个构建的基础镜像：<code>quay.io/quarkus/ubi-quarkus-native-image</code>，我们可以直接执行以下命令进行构建：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package -Pnative -Dquarkus.native.container-build=true</span><br></pre></td></tr></table></figure><h3 id="容器构建遇到的问题"><a href="#容器构建遇到的问题" class="headerlink" title="容器构建遇到的问题"></a>容器构建遇到的问题</h3><h4 id="1-构建时内存不足"><a href="#1-构建时内存不足" class="headerlink" title="1. 构建时内存不足"></a>1. 构建时内存不足</h4><p>在使用容器构建 native-image 的时候，可以会报如下错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal io.quarkus:quarkus-maven-plugin:2.0.1.Final:build (default) on project quarkus-demo: Failed to build quarkus application: io.quarkus.builder.BuildException: Build failure: Build failed due to errors</span><br><span class="line">[ERROR]         [error]: Build step io.quarkus.deployment.pkg.steps.NativeImageBuildStep#build threw an exception: java.lang.RuntimeException: Failed to build native image</span><br><span class="line">[ERROR]         at io.quarkus.deployment.pkg.steps.NativeImageBuildStep.build(NativeImageBuildStep.java:223)</span><br><span class="line">[ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">[ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">[ERROR]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">[ERROR]         at java.base/java.lang.reflect.Method.invoke(Method.java:566)</span><br><span class="line">[ERROR]         at io.quarkus.deployment.ExtensionLoader$2.execute(ExtensionLoader.java:820)</span><br><span class="line">[ERROR]         at io.quarkus.builder.BuildContext.run(BuildContext.java:277)</span><br><span class="line">[ERROR]         at org.jboss.threads.ContextHandler$1.runWith(ContextHandler.java:18)</span><br><span class="line">[ERROR]         at org.jboss.threads.EnhancedQueueExecutor$Task.run(EnhancedQueueExecutor.java:2442)</span><br><span class="line">[ERROR]         at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1476)</span><br><span class="line">[ERROR]         at java.base/java.lang.Thread.run(Thread.java:829)</span><br><span class="line">[ERROR]         at org.jboss.threads.JBossThread.run(JBossThread.java:501)</span><br><span class="line">[ERROR] Caused by: java.lang.RuntimeException: Image generation failed. Exit code was 137 which indicates an out of memory error. Consider increasing the Xmx value for native image generation by setting the &quot;quarkus.native.native-image-xmx&quot; property</span><br><span class="line">[ERROR]         at io.quarkus.deployment.pkg.steps.NativeImageBuildStep.imageGenerationFailed(NativeImageBuildStep.java:360)</span><br><span class="line">[ERROR]         at io.quarkus.deployment.pkg.steps.NativeImageBuildStep.build(NativeImageBuildStep.java:200)</span><br><span class="line">[ERROR]         ... 11 more</span><br><span class="line">[ERROR] -&gt; [Help 1]</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException</span><br></pre></td></tr></table></figure><p>错误提示时内存不足，可以尝试设置 <code>quarkus.native.native-image-xmx</code> 参数，但是设置了这个参数还是报这个错。在查阅资料后，在一个 <a href="https://stackoverflow.com/questions/55157074/packaging-native-image-using-graalvm-and-quarkus-gave-an-error">stackoverflow</a> 的回答中看到了这样一句话：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pay attention it has to be less than the memory you set in your docker daemon.</span><br></pre></td></tr></table></figure><p>他说必须小于您在 docker 守护进程中设置的内存。</p><p>然后我查看 docker 的官方文档时发现，在 Mac 和 Windows 中默认的内存是 2GB。</p><p>所以只要调高这个值就可以了，推荐是 8GB，各系统设置方法：</p><p>Mac：<a href="https://docs.docker.com/docker-for-mac/#resources">https://docs.docker.com/docker-for-mac/#resources</a></p><p>Windows：<a href="https://docs.docker.com/docker-for-windows/#resources">https://docs.docker.com/docker-for-windows/#resources</a></p><h4 id="2-容器构建后的二进制文件无法运行"><a href="#2-容器构建后的二进制文件无法运行" class="headerlink" title="2. 容器构建后的二进制文件无法运行"></a>2. 容器构建后的二进制文件无法运行</h4><p>容器构建 native-image 完成后生成的二进制文件不能执行，提示 <code>zsh: exec format error: ./quarkus-demo-1.0-runner</code></p><p>这是因为我本机是 Mac 系统，但是 Quarkus 提供的构建镜像是 Linux 系统，但是 <strong>Graal VM 目前好像并不支持交叉编译</strong>，所以在 Linux 系统里构建的二进制文件只能在 Linux 系统里执行。</p><p>所以我们可以直接用容器来运行这个构建好的二进制文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本机构建-native-image&quot;&gt;&lt;a href=&quot;#本机构建-native-image&quot; class=&quot;headerlink&quot; title=&quot;本机构建 native-image&quot;&gt;&lt;/a&gt;本机构建 native-image&lt;/h2&gt;&lt;p&gt;如果你本地安装了 G</summary>
      
    
    
    
    <category term="Quarkus" scheme="https://greycode.top/categories/Quarkus/"/>
    
    
    <category term="Quarkus" scheme="https://greycode.top/tags/Quarkus/"/>
    
    <category term="Graal VM" scheme="https://greycode.top/tags/Graal-VM/"/>
    
  </entry>
  
  <entry>
    <title>使用Maven工具创建Quarkus项目</title>
    <link href="https://greycode.top/archive/quarkus/5870388109C640649633FA0BB2F5C9C1/"/>
    <id>https://greycode.top/archive/quarkus/5870388109C640649633FA0BB2F5C9C1/</id>
    <published>2021-07-09T15:22:39.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>我这边使用的是 <code>Maven 3.8.1</code>  版本，可以使用 Quarkus 官方提供的 <code>io.quarkus:quarkus-maven-plugin:2.0.1.Final</code>  插件来快速穿件 Quarkus 项目。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>使用以下 Maven 命令来创建一个新项目：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn io.quarkus:quarkus-maven-plugin:2.0.1.Final:create \</span><br><span class="line">    -DprojectGroupId=top.mjava \</span><br><span class="line">    -DprojectArtifactId=quarkus-demo \</span><br><span class="line">    -DprojectVersion=1.0 \</span><br><span class="line">    -DclassName=&quot;top.mjava.demo.Application&quot;</span><br></pre></td></tr></table></figure><p>在执行命令的当前目录下会为项目生成和 ArtifactId 同名的文件夹，如果已存在该同名文件夹，则项目会创建失败。</p><p>在 <code>src/main/docker</code> 目录下还生成了 native 和 jvm 模式的 Dockerfile，构建镜像和运行容器的指令写在这些 Dockerfile 中。</p><h3 id="命令描述"><a href="#命令描述" class="headerlink" title="命令描述"></a>命令描述</h3><table><thead><tr><th align="left">属性</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>projectGroupId</code></td><td align="left"><code>org.acme.sample</code></td><td align="left">项目的 GroupId</td></tr><tr><td align="left"><code>projectArtifactId</code></td><td align="left">没有默认值，但是必填</td><td align="left">项目的 ArtifactId</td></tr><tr><td align="left"><code>projectVersion</code></td><td align="left"><code>1.0.0-SNAPSHOT</code></td><td align="left">项目版本</td></tr><tr><td align="left"><code>platformGroupId</code></td><td align="left"><code>io.quarkus</code></td><td align="left">目标平台的组 ID。鉴于所有现有平台都来自 io.quarkus，实际上不会明确使用这一平台。但它仍然是一个选择。</td></tr><tr><td align="left"><code>platformArtifactId</code></td><td align="left"><code>quarkus-universe-bom</code></td><td align="left">目标平台 BOM 的工件 ID。为了使用本地构建的 Quarkus，它应该是 quarkus-bom。</td></tr><tr><td align="left"><code>platformVersion</code></td><td align="left">如果未指定，将解析最新的。</td><td align="left">您希望项目使用的平台版本。它还可以接受版本范围，在这种情况下，将使用指定范围中的最新版本。</td></tr><tr><td align="left"><code>className</code></td><td align="left"><em>如果省略则不创建</em></td><td align="left">生成的资源的完全限定名称</td></tr><tr><td align="left"><code>path</code></td><td align="left"><code>/hello</code></td><td align="left">资源路径，仅在设置了 className 时生效。</td></tr><tr><td align="left"><code>extensions</code></td><td align="left"><em>[]</em></td><td align="left">要添加到项目的扩展列表（逗号分隔）</td></tr></tbody></table><h2 id="管理扩展"><a href="#管理扩展" class="headerlink" title="管理扩展"></a>管理扩展</h2><p>创建项目后就可以进入到项目文件夹，可以使用简短的命令来操作项目了，例如：<code>mvn quarkus:[command]</code></p><h3 id="查看所有扩展"><a href="#查看所有扩展" class="headerlink" title="查看所有扩展"></a>查看所有扩展</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:list-extensions</span><br></pre></td></tr></table></figure><p>该命令可以查看当前项目所使用的的所有扩展。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo: mvn quarkus:list-extensions</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:list-extensions (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] Current Quarkus extensions available: </span><br><span class="line">[INFO] </span><br><span class="line">[INFO] Blaze-Persistence                                  blaze-persistence-integration-quarkus             </span><br><span class="line">[INFO] Camel ActiveMQ                                     camel-quarkus-activemq                            </span><br><span class="line">[INFO] Camel Async HTTP Client (AHC)                      camel-quarkus-ahc                                 </span><br><span class="line">[INFO] Camel Async HTTP Client (AHC) Websocket            camel-quarkus-ahc-ws                              </span><br><span class="line">[INFO] Camel AMQP                                         camel-quarkus-amqp           </span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="添加扩展"><a href="#添加扩展" class="headerlink" title="添加扩展"></a>添加扩展</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:add-extensions -Dextension=vertx</span><br></pre></td></tr></table></figure><p>该命令可以添加扩展，例如上面这条命令为项目添加了 <code>vertx</code> 扩展</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo: mvn quarkus:add-extensions -Dextension=vertx</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:add-extensions (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] [SUCCESS] ✅  Extension io.quarkus:quarkus-vertx has been installed</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.370 s</span><br><span class="line">[INFO] Finished at: 2021-07-09T15:06:50+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="删除扩展"><a href="#删除扩展" class="headerlink" title="删除扩展"></a>删除扩展</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:remove-extensions -Dextension=vertx</span><br></pre></td></tr></table></figure><p>该命令可以删除不用的扩展，比如删除刚刚添加的 <code>vertx</code> 扩展</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo: mvn quarkus:remove-extensions -Dextension=vertx</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:remove-extensions (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] [SUCCESS] ✅  Extension io.quarkus:quarkus-vertx has been uninstalled</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.112 s</span><br><span class="line">[INFO] Finished at: 2021-07-09T15:08:48+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:dev</span><br></pre></td></tr></table></figure><p>执行该命令时，项目会被运行，此时访问 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 就会得到 <code>Hello RESTEasy</code> 输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  quarkus-demo: mvn quarkus:dev                             </span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:dev (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] Invoking io.quarkus:quarkus-maven-plugin:2.0.1.Final:generate-code @ quarkus-demo</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-resources-plugin:2.6:resources @ quarkus-demo</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] Copying 2 resources</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-compiler-plugin:3.8.1:compile @ quarkus-demo</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-resources-plugin:2.6:testResources @ quarkus-demo</span><br><span class="line">[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/zheng/coding/study/quarkus-demo/src/test/resources</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-compiler-plugin:3.8.1:testCompile @ quarkus-demo</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">Listening for transport dt_socket at address: 5005</span><br><span class="line">__  ____  __  _____   ___  __ ____  ______ </span><br><span class="line"> --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ </span><br><span class="line"> -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \   </span><br><span class="line">--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   </span><br><span class="line">2021-07-09 15:16:47,146 INFO  [io.quarkus] (Quarkus Main Thread) quarkus-demo 1.0 on JVM (powered by Quarkus 2.0.1.Final) started in 3.412s. Listening on: http://localhost:8080</span><br><span class="line">2021-07-09 15:16:47,194 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.</span><br><span class="line">2021-07-09 15:16:47,199 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy, smallrye-context-propagation]</span><br></pre></td></tr></table></figure><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:build</span><br></pre></td></tr></table></figure><p>该命令会构建项目，并会在 <code>target/quarkus-app/</code> 目录下创建一个可运行的 <code>jar</code> 包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo mvn quarkus:build</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:build (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] [org.jboss.threads] JBoss Threads version 3.4.0.Final</span><br><span class="line">[INFO] [io.quarkus.deployment.QuarkusAugmentor] Quarkus augmentation completed in 1977ms</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  4.776 s</span><br><span class="line">[INFO] Finished at: 2021-07-09T15:13:54+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多命令可以执行下面的命令查看，本文只介绍了几种常用的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn io.quarkus:quarkus-maven-plugin:2.0.1.Final:help</span><br><span class="line"></span><br><span class="line">// 或者在项目目录下可使用简短命令</span><br><span class="line">mvn quarkus:help</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://quarkus.io/guides/maven-tooling">https://quarkus.io/guides/maven-tooling</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;我这边使用的是 &lt;code&gt;Maven 3.8.1&lt;/code&gt;  版本，可以使用 Quarkus 官方提供的 &lt;code&gt;io.quark</summary>
      
    
    
    
    <category term="Quarkus" scheme="https://greycode.top/categories/Quarkus/"/>
    
    
    <category term="Quarkus" scheme="https://greycode.top/tags/Quarkus/"/>
    
    <category term="Maven" scheme="https://greycode.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>开发SaaS应用的12条准则【转】</title>
    <link href="https://greycode.top/archive/code/FFC3580D7E244B5282E3FDD7F3EB8E95/"/>
    <id>https://greycode.top/archive/code/FFC3580D7E244B5282E3FDD7F3EB8E95/</id>
    <published>2021-07-07T17:33:40.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发SaaS应用的12条准则【转】"><a href="#开发SaaS应用的12条准则【转】" class="headerlink" title="开发SaaS应用的12条准则【转】"></a>开发SaaS应用的12条准则【转】</h1><blockquote><p>原文地址：<a href="https://12factor.net/">https://12factor.net/</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论：</p><ul><li>使用<strong>标准化</strong>流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。</li><li>和操作系统之间尽可能的<strong>划清界限</strong>，在各个系统中提供<strong>最大的可移植性</strong>。</li><li>适合<strong>部署</strong>在现代的<strong>云计算平台</strong>，从而在服务器和系统管理方面节省资源。</li><li>将开发环境和生产环境的<strong>差异降至最低</strong>，并使用<strong>持续交付</strong>实施敏捷开发。</li><li>可以在工具、架构和开发流程不发生明显变化的前提下实现<strong>扩展</strong>。</li></ul><p>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文的贡献者参与过数以百计的应用程序的开发和部署，并通过 <a href="http://www.heroku.com/">Heroku</a> 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。</p><p>本文综合了我们关于 SaaS 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 <a href="http://blog.heroku.com/archives/2011/6/28/the_new_heroku_4_erosion_resistance_explicit_contracts/">避免软件污染</a> 。</p><p>我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于 Martin Fowler 的书籍： <em><a href="http://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC">Patterns of Enterprise Application Architecture</a></em> ， <em><a href="http://books.google.com/books/about/Refactoring.html?id=1MsETFPD3I0C">Refactoring</a></em> 。</p><h2 id="读者应该是哪些人？"><a href="#读者应该是哪些人？" class="headerlink" title="读者应该是哪些人？"></a>读者应该是哪些人？</h2><p>任何 SaaS 应用的开发人员。部署和管理此类应用的运维工程师。</p><hr><h2 id="I-基准代码"><a href="#I-基准代码" class="headerlink" title="I. 基准代码"></a>I. 基准代码</h2><blockquote><p>一份基准代码（Codebase），多份部署（deploy）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/tvR5L1V.png" alt="https://12factor.net/images/codebase-deploys.png"></p><p>12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如<a href="http://git-scm.com/">Git</a>, <a href="https://www.mercurial-scm.org/">Mercurial</a>, <a href="http://subversion.apache.org/">Subversion</a>。一份用来跟踪代码所有修订版本的数据库被称作 <em>代码库</em>（code repository, code repo, repo）。</p><p>在类似 SVN 这样的集中式版本控制系统中，<em>基准代码</em> 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，<em>基准代码</em> 则是指最上游的那份代码库。</p><p>基准代码和应用之间总是保持一一对应的关系：</p><ul><li>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。</li><li>多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 <a href="https://12factor.net/zh_cn/dependencies">依赖管理</a> 策略去加载它们。</li></ul><p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 <em>部署</em> 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。</p><p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p><h2 id="II-依赖"><a href="#II-依赖" class="headerlink" title="II. 依赖"></a>II. 依赖</h2><blockquote><p>显式声明依赖关系（ dependency ）</p></blockquote><p>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 <a href="http://www.cpan.org/">CPAN</a> 或是 Ruby 的 <a href="http://rubygems.org/">Rubygems</a> 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。</p><p><strong>12-Factor规则下的应用程序不会隐式依赖系统级的类库。</strong> 它一定通过 <em>依赖清单</em> ，确切地声明所有依赖项。此外，在运行过程中通过 <em>依赖隔离</em> 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p><p>例如， Ruby 的 <a href="https://bundler.io/">Bundler</a> 使用 <code>Gemfile</code> 作为依赖项声明清单，使用 <code>bundle exec</code> 来进行依赖隔离。Python 中则可分别使用两种工具 – <a href="http://www.pip-installer.org/en/latest/">Pip</a> 用作依赖声明， <a href="http://www.virtualenv.org/en/latest/">Virtualenv</a> 用作依赖隔离。甚至 C 语言也有类似工具， <a href="http://www.gnu.org/s/autoconf/">Autoconf</a> 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。</p><p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 <em>构建命令</em> 来安装所有的依赖项，即可开始工作。例如，Ruby&#x2F;Bundler 下使用 <code>bundle install</code>，而 Clojure&#x2F;<a href="https://github.com/technomancy/leiningen#readme">Leiningen</a> 则是 <code>lein deps</code>。</p><p>12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是<code>curl</code>。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p><h2 id="III-配置"><a href="#III-配置" class="headerlink" title="III. 配置"></a>III. 配置</h2><blockquote><p>在环境中存储配置</p></blockquote><p>通常，应用的 <em>配置</em> 在不同 <a href="https://12factor.net/zh_cn/codebase">部署</a> (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p><ul><li>数据库，Memcached，以及其他 <a href="https://12factor.net/zh_cn/backing-services">后端服务</a> 的配置</li><li>第三方服务的证书，如 Amazon S3、Twitter 等</li><li>每份部署特有的配置，如域名等</li></ul><p>有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的<strong>代码和配置严格分离</strong>显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p><p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p><p>需要指出的是，这里定义的“配置”并<strong>不</strong>包括应用的内部配置，比如 Rails 的 <code>config/routes.rb</code>，或是使用 <a href="http://spring.io/">Spring</a> 时 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html">代码模块间的依赖注入关系</a> 。这类配置在不同部署间不存在差异，所以应该写入代码。</p><p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 <code>config/database.yml</code> 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p><p><strong>12-Factor推荐将应用的配置存储于 <em>环境变量</em> 中</strong>（ <em>env vars</em>, <em>env</em> ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。</p><p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 <code>development</code>,<code>test</code>, 和 <code>production</code> 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 <code>staging</code> 或 <code>qa</code> 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 <code>joes-staging</code> ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p><p>12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p><h2 id="IV-后端服务"><a href="#IV-后端服务" class="headerlink" title="IV. 后端服务"></a>IV. 后端服务</h2><blockquote><p>把后端服务(backing services)当作附加资源</p></blockquote><p><em>后端服务</em>是指程序运行所需要的通过网络调用的各种服务，如数据库（<a href="http://dev.mysql.com/">MySQL</a>，<a href="http://couchdb.apache.org/">CouchDB</a>），消息&#x2F;队列系统（<a href="http://www.rabbitmq.com/">RabbitMQ</a>，<a href="https://beanstalkd.github.io/">Beanstalkd</a>），SMTP 邮件发送服务（<a href="http://www.postfix.org/">Postfix</a>），以及缓存系统（<a href="http://memcached.org/">Memcached</a>）。</p><p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 <a href="http://postmarkapp.com/">Postmark</a>），数据收集服务（例如 <a href="http://newrelic.com/">New Relic</a> 或 <a href="http://www.loggly.com/">Loggly</a>），数据存储服务（如 <a href="http://http//aws.amazon.com/s3/">Amazon S3</a>），以及使用 API 访问的服务（例如 <a href="http://dev.twitter.com/">Twitter</a>, <a href="https://developers.google.com/maps/">Google Maps</a>, <a href="http://www.last.fm/api">Last.fm</a>）。</p><p><strong>12-Factor 应用不会区别对待本地或第三方服务。</strong> 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 <a href="https://12factor.net/zh_cn/config">配置</a> 中的服务定位&#x2F;服务证书来获取数据。12-Factor 应用的任意 <a href="https://12factor.net/zh_cn/codebase">部署</a> ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 <a href="http://aws.amazon.com/rds/">Amazon RDS</a>）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。</p><p>每个不同的后端服务是一份 <em>资源</em> 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 <em>附加资源</em> ，这些资源和它们附属的部署保持松耦合。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/XzCS6LB-20211008161426619.png" alt="https://12factor.net/images/attached-resources.png"></p><p>部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。</p><h2 id="V-构建，发布，运行"><a href="#V-构建，发布，运行" class="headerlink" title="V. 构建，发布，运行"></a>V. 构建，发布，运行</h2><blockquote><p>严格分离构建和运行</p></blockquote><p><a href="https://12factor.net/zh_cn/codebase">基准代码</a> 转化为一份部署(非开发环境)需要以下三个阶段：</p><ul><li><em>构建阶段</em> 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 <a href="https://12factor.net/zh_cn/dependencies">依赖项</a>，编译成二进制文件和资源文件。</li><li><em>发布阶段</em> 会将构建的结果和当前部署所需 <a href="https://12factor.net/zh_cn/config">配置</a> 相结合，并能够立刻在运行环境中投入使用。</li><li><em>运行阶段</em> （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 <a href="https://12factor.net/zh_cn/processes">进程</a>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/4fVsaeA.png" alt="https://12factor.net/images/release.png"></p><p><strong>12-factor 应用严格区分构建，发布，运行这三个步骤。</strong> 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p><p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， <a href="https://github.com/capistrano/capistrano/wiki">Capistrano</a> 将所有发布版本都存储在一个叫 <code>releases</code> 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 <code>rollback</code> 命令可以很容易地实现回退版本的功能。</p><p>每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（<code>2011-04-06-20:32:17</code>），亦或是一个增长的数字（<code>v100</code>）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p><p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p><h2 id="VI-进程"><a href="#VI-进程" class="headerlink" title="VI. 进程"></a>VI. 进程</h2><blockquote><p>以一个或多个无状态进程运行应用</p></blockquote><p>运行环境中，应用程序通常是以一个和多个 <em>进程</em> 运行的。</p><p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如<code>python my_script.py</code>）。另外一个极端情况是，复杂的应用可能会使用很多 <a href="https://12factor.net/zh_cn/concurrency">进程类型</a> ，也就是零个或多个进程实例。</p><p><strong>12-Factor 应用的进程必须无状态且 <a href="http://en.wikipedia.org/wiki/Shared_nothing_architecture">无共享</a> 。</strong> 任何需要持久化的数据都要存储在 <a href="https://12factor.net/zh_cn/backing-services">后端服务</a> 内，比如数据库。</p><p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p><p>源文件打包工具（<a href="http://documentcloud.github.com/jammit/">Jammit</a>, <a href="http://django-compressor.readthedocs.org/">django-compressor</a>） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 <a href="https://12factor.net/zh_cn/build-release-run">构建步骤</a> 做此动作——正如 <a href="http://guides.rubyonrails.org/asset_pipeline.html">Rails资源管道</a> ，而不是在运行阶段。</p><p>一些互联网系统依赖于 “<a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence">粘性 session</a>”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 <a href="http://memcached.org/">Memcached</a> 或 <a href="http://redis.io/">Redis</a> 这样的带有过期时间的缓存中。</p><h2 id="VII-端口绑定"><a href="#VII-端口绑定" class="headerlink" title="VII. 端口绑定"></a>VII. 端口绑定</h2><blockquote><p>通过端口绑定(Port binding)来提供服务</p></blockquote><p>互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 <a href="http://httpd.apache.org/">Apache HTTPD</a> 的一个模块来运行，正如 Java 运行于 <a href="http://tomcat.apache.org/">Tomcat</a> 。</p><p><strong>12-Factor 应用完全自我加载</strong> 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 <strong>通过端口绑定来提供服务</strong> ，并监听发送至该端口的请求。</p><p>本地环境中，开发人员通过类似<code>http://localhost:5000/</code>的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</p><p>通常的实现思路是，将网络服务器类库通过 <a href="https://12factor.net/zh_cn/dependencies">依赖声明</a> 载入应用。例如，Python 的 <a href="http://www.tornadoweb.org/">Tornado</a>, Ruby 的<a href="http://code.macournoyer.com/thin/">Thin</a> , Java 以及其他基于 JVM 语言的 <a href="http://www.eclipse.org/jetty/">Jetty</a>。完全由 <em>用户端</em> ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p><p>HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 <a href="http://xmpp.org/">XMPP</a> 的 <a href="http://www.ejabberd.im/">ejabberd</a> ， 以及使用 <a href="http://redis.io/topics/protocol">Redis 协议</a> 的 <a href="http://redis.io/">Redis</a> 。</p><p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 <a href="https://12factor.net/zh_cn/backing-services">后端服务</a> ，调用方将服务方提供的相应 URL 当作资源存入 <a href="https://12factor.net/zh_cn/config">配置</a> 以备将来调用。</p><h2 id="VIII-并发"><a href="#VIII-并发" class="headerlink" title="VIII. 并发"></a>VIII. 并发</h2><blockquote><p>通过进程模型进行扩展</p></blockquote><p>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。</p><p><img src="https://cdn.jsdelivr.net/gh/greycodee/images@main/images/2021/10/08/lGZVkoW.png" alt="https://12factor.net/images/process-types.png"></p><p><strong>在 12-factor 应用中，进程是一等公民。</strong>12-Factor 应用的进程主要借鉴于 <a href="https://adam.herokuapp.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/">unix 守护进程模型</a> 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 <em>进程类型</em> 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。</p><p>这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 <a href="https://github.com/eventmachine/eventmachine">EventMachine</a>, <a href="http://twistedmatrix.com/trac/">Twisted</a>, <a href="http://nodejs.org/">Node.js</a> 的异步&#x2F;事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。</p><p>上述进程模型会在系统急需扩展时大放异彩。 <a href="https://12factor.net/zh_cn/processes">12-Factor 应用的进程所具备的无共享，水平分区的特性</a> 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 <em>进程构成</em> 。</p><p>12-Factor 应用的进程 <a href="http://dustin.github.com/2010/02/28/running-processes.html">不需要守护进程</a> 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a> ，分布式的进程管理云平台，或是类似 <a href="http://blog.daviddollar.org/2011/05/06/introducing-foreman.html">Foreman</a> 的工具)，来管理 <a href="https://12factor.net/zh_cn/logs">输出流</a> ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p><h2 id="IX-易处理"><a href="#IX-易处理" class="headerlink" title="IX. 易处理"></a>IX. 易处理</h2><blockquote><p>快速启动和优雅终止可最大化健壮性</p></blockquote><p>*<em>12-Factor 应用的 <a href="https://12factor.net/zh_cn/processes">进程</a> 是 <em>易处理（disposable）</em>的，意思是说它们可以瞬间开启或停止。</em>* 这有利于快速、弹性的伸缩应用，迅速部署变化的 <a href="https://12factor.net/zh_cn/codebase">代码</a> 或 <a href="https://12factor.net/zh_cn/config">配置</a> ，稳健的部署应用。</p><p>进程应当追求 <strong>最小启动时间</strong> 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 <a href="https://12factor.net/zh_cn/build-release-run">发布</a> 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p><p>进程 <strong>一旦接收 <a href="http://en.wikipedia.org/wiki/SIGTERM">终止信号（<code>SIGTERM</code>）</a> 就会优雅的终止</strong> 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p><p>对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，<a href="http://www.rabbitmq.com/">RabbitMQ</a> 中，worker 可以发送一个<code>[NACK](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack)</code>信号。 <a href="https://beanstalkd.github.io/">Beanstalkd</a> 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 <a href="https://github.com/collectiveidea/delayed_job#readme">Delayed Job</a> 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 <a href="http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29">可重复执行</a> ， 这主要由将结果包装进事务或是使重复操作 <a href="http://en.wikipedia.org/wiki/Idempotence">幂等</a> 来实现。</p><p>进程还应当<strong>在面对突然死亡时保持健壮</strong>，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 <a href="https://beanstalkd.github.io/">Beanstalkd</a> ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。<a href="http://lwn.net/Articles/191059/">Crash-only design</a> 将这种概念转化为 <a href="http://couchdb.apache.org/docs/overview.html">合乎逻辑的理论</a>。</p><h2 id="X-开发环境与线上环境等价"><a href="#X-开发环境与线上环境等价" class="headerlink" title="X. 开发环境与线上环境等价"></a>X. 开发环境与线上环境等价</h2><blockquote><p>尽可能的保持开发，预发布，线上环境相同</p></blockquote><p>从以往经验来看，开发环境（即开发人员的本地 <a href="https://12factor.net/zh_cn/codebase">部署</a>）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p><ul><li><strong>时间差异：</strong> 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li><li><strong>人员差异：</strong> 开发人员编写代码，运维人员部署代码。</li><li><strong>工具差异：</strong> 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。</li></ul><p><strong>12-Factor 应用想要做到 <a href="http://avc.com/2011/02/continuous-deployment/">持续部署</a> 就必须缩小本地与线上差异。</strong> 再回头看上面所描述的三个差异:</p><ul><li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</li><li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li><li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</li></ul><p>将上述总结变为一个表格如下：</p><table><thead><tr><th></th><th>传统应用</th><th>12-Factor 应用</th></tr></thead><tbody><tr><td>每次部署间隔</td><td>数周</td><td>几小时</td></tr><tr><td>开发人员 vs 运维人员</td><td>不同的人</td><td>相同的人</td></tr><tr><td>开发环境 vs 线上环境</td><td>不同</td><td>尽量接近</td></tr></tbody></table><p><a href="https://12factor.net/zh_cn/backing-services">后端服务</a> 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 <em>适配器</em> 。下列表格提供了一些例子。</p><table><thead><tr><th>类型</th><th>语言</th><th>类库</th><th>适配器</th></tr></thead><tbody><tr><td>数据库</td><td>Ruby&#x2F;Rails</td><td>ActiveRecord</td><td>MySQL, PostgreSQL, SQLite</td></tr><tr><td>队列</td><td>Python&#x2F;Django</td><td>Celery</td><td>RabbitMQ, Beanstalkd, Redis</td></tr><tr><td>缓存</td><td>Ruby&#x2F;Rails</td><td>ActiveSupport::Cache</td><td>Memory, filesystem, Memcached</td></tr></tbody></table><p>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。</p><p><strong>12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务</strong> ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p><p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于<a href="http://mxcl.github.com/homebrew/">Homebrew</a>，<a href="https://help.ubuntu.com/community/AptGet/Howto">apt-get</a>等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 <a href="http://www.opscode.com/chef/">Chef</a> 和 <a href="http://docs.puppetlabs.com/">Puppet</a> 的声明式配置工具，结合像 <a href="http://vagrantup.com/">Vagrant</a> 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p><p>不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p><h2 id="XI-日志"><a href="#XI-日志" class="headerlink" title="XI. 日志"></a>XI. 日志</h2><blockquote><p>把日志当作事件流</p></blockquote><p><em>日志</em> 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p><p>日志应该是 <a href="https://adam.herokuapp.com/past/2011/4/1/logs_are_streams_not_files/">事件流</a> 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p><p><strong>12-factor应用本身从不考虑存储自己的输出流。</strong> 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（<code>stdout</code>）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p><p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 <a href="https://github.com/heroku/logplex">Logplex</a> 和 <a href="https://github.com/fluent/fluentd">Fluentd</a> 的开源工具可以达到这个目的。</p><p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 <a href="http://www.splunk.com/">Splunk</a> 这样的日志索引及分析系统，或 <a href="http://hive.apache.org/">Hadoop&#x2F;Hive</a> 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p><ul><li>找出过去一段时间特殊的事件。</li><li>图形化一个大规模的趋势，比如每分钟的请求量。</li><li>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</li></ul><h2 id="XII-管理进程"><a href="#XII-管理进程" class="headerlink" title="XII. 管理进程"></a>XII. 管理进程</h2><blockquote><p>后台管理任务当作一次性进程运行</p></blockquote><p><a href="https://12factor.net/zh_cn/concurrency">进程构成</a>（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p><ul><li>运行数据移植（Django 中的 <code>manage.py migrate</code>, Rails 中的 <code>rake db:migrate</code>）。</li><li>运行一个控制台（也被称为 <a href="http://en.wikipedia.org/wiki/Read-eval-print_loop">REPL</a> shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（<code>python</code> 或 <code>perl</code>） ，或是其他命令（Ruby 使用 <code>irb</code>, Rails 使用 <code>rails console</code>）。</li><li>运行一些提交到代码仓库的一次性脚本。</li></ul><p>一次性管理进程应该和正常的 <a href="https://12factor.net/zh_cn/processes">常驻进程</a> 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 <a href="https://12factor.net/zh_cn/codebase">代码</a> 和 <a href="https://12factor.net/zh_cn/config">配置</a> ，基于某个 <a href="https://12factor.net/zh_cn/build-release-run">发布版本</a> 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p><p>所有进程类型应该使用同样的 <a href="https://12factor.net/zh_cn/dependencies">依赖隔离</a> 技术。例如，如果Ruby的web进程使用了命令 <code>bundle exec thin start</code> ，那么数据库移植应使用 <code>bundle exec rake db:migrate</code> 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 <code>manage.py</code> 管理进程时引入 <code>bin/python</code> 。</p><p>12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发SaaS应用的12条准则【转】&quot;&gt;&lt;a href=&quot;#开发SaaS应用的12条准则【转】&quot; class=&quot;headerlink&quot; title=&quot;开发SaaS应用的12条准则【转】&quot;&gt;&lt;/a&gt;开发SaaS应用的12条准则【转】&lt;/h1&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    
    <category term="SaaS" scheme="https://greycode.top/tags/SaaS/"/>
    
  </entry>
  
  <entry>
    <title>vertx的web开发学习笔记</title>
    <link href="https://greycode.top/vertx/10EF2E95447C468CB55BD7BD0675C090/"/>
    <id>https://greycode.top/vertx/10EF2E95447C468CB55BD7BD0675C090/</id>
    <published>2021-07-05T15:31:02.000Z</published>
    <updated>2022-04-16T02:52:58.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个-Http-服务"><a href="#创建一个-Http-服务" class="headerlink" title="创建一个 Http 服务"></a>创建一个 Http 服务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line"><span class="type">Router</span> <span class="variable">router</span> <span class="operator">=</span> Router.router(vertx);</span><br><span class="line"><span class="comment">// 创建 Http 服务</span></span><br><span class="line">vertx.createHttpServer()</span><br><span class="line">  <span class="comment">// 绑定路由</span></span><br><span class="line">  .requestHandler(router)</span><br><span class="line">  <span class="comment">// 监听端口</span></span><br><span class="line">  .listen(<span class="number">8888</span>)</span><br><span class="line">  <span class="comment">// Http 服务启动成功后调用</span></span><br><span class="line">  .onSuccess(server -&gt;</span><br><span class="line">   System.out.println(<span class="string">&quot;HTTP server started on port &quot;</span> + server.actualPort())</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h2 id="Router-使用"><a href="#Router-使用" class="headerlink" title="Router 使用"></a>Router 使用</h2><blockquote><p>直接使用上面的路由实例</p></blockquote><h3 id="创建请求路由"><a href="#创建请求路由" class="headerlink" title="创建请求路由"></a>创建请求路由</h3><ul><li><p>创建 Get 请求路由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router</span><br><span class="line">  .get(<span class="string">&quot;/test&quot;</span>)</span><br><span class="line">  .respond(</span><br><span class="line">    <span class="comment">// 响应逻辑</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">router</span><br><span class="line">  .route(HttpMethod.GET, <span class="string">&quot;/test&quot;</span>)</span><br><span class="line">  .respond(</span><br><span class="line">    <span class="comment">// 响应逻辑</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li><li><p>创建 Post 请求路由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router</span><br><span class="line">  .post(<span class="string">&quot;/test&quot;</span>)</span><br><span class="line">  .respond(</span><br><span class="line"><span class="comment">// 响应逻辑</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">router</span><br><span class="line">  .post(HttpMethod.POST, <span class="string">&quot;/test&quot;</span>)</span><br><span class="line">  .respond(</span><br><span class="line"><span class="comment">// 响应逻辑</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><ul><li><p>获取 URL 参数</p><blockquote><p>请求地址示例：<a href="http://localhost:8080/get?param=greycode">http://localhost:8080/get?param=greycode</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/get&quot;</span>).handler(context-&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> context.request().getParam(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">System.out.println(param);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">greycode</span><br></pre></td></tr></table></figure></li><li><p>获取 REST 风格的地址参数</p><blockquote><p>请求地址示例：<a href="http://localhost:8080/get/greycode">http://localhost:8080/get/greycode</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/get/:param&quot;</span>).handler(context-&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> context.pathParam(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">System.out.println(param);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">greycode</span><br></pre></td></tr></table></figure></li><li><p>获取  Body 数据</p><blockquote><p>请求地址示例：<a href="http://localhost:8080/post">http://localhost:8080/post</a></p><p>请求数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;greycode&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在获取数据前，一定要执行这行代码</span></span><br><span class="line"><span class="comment">// 否则就会报：警告: BodyHandler in not enabled on this route: RoutingContext.getBodyAsJson() in always be NULL‘</span></span><br><span class="line">router.route().handler(BodyHandler.create());</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&quot;/post&quot;</span>).handler(context-&gt;&#123;</span><br><span class="line">  <span class="type">JsonObject</span> <span class="variable">body</span> <span class="operator">=</span> context.getBodyAsJson();</span><br><span class="line">  System.out.println(body.toString());</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;greycode&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/get&quot;</span>).handler(context-&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;模拟错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">.failureHandler(context-&gt; &#123;</span><br><span class="line">    <span class="comment">// 发生异常时执行的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建一个-Http-服务&quot;&gt;&lt;a href=&quot;#创建一个-Http-服务&quot; class=&quot;headerlink&quot; title=&quot;创建一个 Http 服务&quot;&gt;&lt;/a&gt;创建一个 Http 服务&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="Vert.x" scheme="https://greycode.top/categories/Vert-x/"/>
    
    
    <category term="Vert.x" scheme="https://greycode.top/tags/Vert-x/"/>
    
  </entry>
  
  <entry>
    <title>Java删除文件后电脑磁盘空间没有恢复</title>
    <link href="https://greycode.top/java/74CAAAFD610241A1B8ECDB5F3BB33EE4/"/>
    <id>https://greycode.top/java/74CAAAFD610241A1B8ECDB5F3BB33EE4/</id>
    <published>2021-07-03T17:12:41.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当用一下命令删除文件后，电脑磁盘内存没有恢复，还是原来的大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">folder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/file.mp4&quot;</span>)</span><br><span class="line">file.delete();</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原来是 <code>FileOutputStream</code> 文件流忘了关了，导致一直占用这个资源。所以使用完后一定记得关文件流，使用下面的代码关闭文件流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><p><strong>Linux 里的文件被删除后，空间没有被释放是因为在 Linux 系统中，通过 rm 或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的(有一个进程正在使用)，那么进程将仍然可以读取该文件，磁盘空间也一直被占用。</strong></p><p>可以使用 <code>lsof +L1 |grep delete</code> 命令来查看状态为 <code>deleted</code> 的文件，状态为 <code>deleted</code> 为标记被删除，其实该文件并没有从磁盘中删除，类似windows下的回收站状态。</p><p>所以当进程结束后，磁盘空间就会被释放。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cxyzjd.com/article/su4416160/78212934">http://www.cxyzjd.com/article/su4416160/78212934</a></li><li><a href="https://www.jianshu.com/p/fcb80c878d04">https://www.jianshu.com/p/fcb80c878d04</a></li></ul>]]></content>
    
    
    <summary type="html">当用一下命令删除文件后，电脑磁盘内存没有恢复，还是原来的大小</summary>
    
    
    
    <category term="Java" scheme="https://greycode.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://greycode.top/tags/Java/"/>
    
    <category term="Linux" scheme="https://greycode.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>程序员的酒后真言</title>
    <link href="https://greycode.top/archive/essay/A98D5EC3509F483E80919CA2E09BDA1B/"/>
    <id>https://greycode.top/archive/essay/A98D5EC3509F483E80919CA2E09BDA1B/</id>
    <published>2021-06-29T11:24:25.000Z</published>
    <updated>2022-04-16T02:52:58.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转至：<a href="http://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html">http://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html</a></p><p>出至：<a href="https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/">https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/</a></p></blockquote><p>(1) 职业发展的最好方法是换公司。</p><p>(2）技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。</p><p>(3）工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。</p><p>(4）我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。</p><p>(5）如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。</p><p>(6）好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。</p><p>(7）作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。</p><p>(8）网上的口水战，几乎都无关紧要，别去参与。</p><p>(9）如果我发现自己是公司里面最厉害的工程师，那就该离开了。</p><p>(10）我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。</p><p>(11）技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。</p><p>(12）如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。</p><p>(13）对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。</p><p>(14）测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。</p><p>(15） 政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你将被禁锢在深奥的专用工具里面，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄中位数在 50 岁以上是有原因的。</p><p>(16）再倒一杯酒。</p><p>(17）大多数头衔都无关紧要，随便什么公司都可以有首席工程师。</p><p>(18）手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。</p><p>(19）当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。</p><p>(20）有些技术太流行，我不得不用它。我心里就会很讨厌这种技术，但会把它推荐给客户，比如我恨 Jenkins，但把它推荐给新客户，我不觉得做错了。</p><p>(21）成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。</p><p>(22）发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。</p><p>(23）我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。</p><p>(24）算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。</p><p>(25）做自己喜欢的事情并不重要，不要让我做讨厌的事情更重要。</p><p>(26）越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。</p><p>(27）即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。</p><p>(28）人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。</p><p>(29）我挣的钱还不错，对此心存感激，但还是需要省钱。</p><p>(30）糟糕，我没酒了。</p><p>(完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转至：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html&quot;&gt;http://www.ruanyifeng.com/blog/2021/06/d</summary>
      
    
    
    
    <category term="Essay" scheme="https://greycode.top/categories/Essay/"/>
    
    
    <category term="闲谈" scheme="https://greycode.top/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
</feed>
