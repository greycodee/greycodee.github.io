<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>平衡二叉树 on Greycode&#39;s Blog</title>
    <link>http://localhost:1313/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
    <description>Recent content in 平衡二叉树 on Greycode&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Feb 2020 15:56:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【数据结构】手写平衡二叉树（AVL）</title>
      <link>http://localhost:1313/posts/algorithm-avltree-01/</link>
      <pubDate>Sat, 01 Feb 2020 15:56:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/algorithm-avltree-01/</guid>
      <description>【数据结构】手写平衡二叉树（AVL） 积千里跬步，汇万里江河。每天进步一点点，终有一天将成大佬
本文源代码：手写AVL树
什么是平衡二叉树？ 平衡二叉树，又称为AVL树，当树不是空树时，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。AVL树查找的时间复杂度为O(logN)。
平衡二叉树基本特点 左右子树深度差不能大于1 左边子树永远比根节点小 右边子树永远比根节点大 平衡二叉树基本结构及操作 左左结构——右旋 右右结构——左旋 左右结构——左子先左旋，然后整体右旋 右左结构——右子先右旋，然后整体左旋 代码实现 先创建一个内部类Node，来表示树的每个节点
public class AVLTree { private Node rootNode; //二叉树节点 private class Node{ public Node parent; //父 public Node left;	//左子树 public Node right;	//右子树 @NotNull public int data;	//存放的数据 private int depth;	//深度 private int balance;	//平衡因子 //有参构造方法 public Node(int data){ this.data=data; this.depth=1; this.balance=0; } } } 插入数据 暴露一个方法给外部调用
/**添加数据方法*/ public void add(int data){ if (this.</description>
    </item>
    
  </channel>
</rss>
