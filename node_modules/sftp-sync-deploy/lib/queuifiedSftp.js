"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const queue_1 = require("queue");
class QueuifiedSFTP {
    constructor(concurrency) {
        this.started = false;
        this.paused = false;
        this.queue = new queue_1.default({ concurrency });
        this.queue.on('end', err => {
            this.started = false;
        });
    }
    static init(client, concurrency = Infinity) {
        const instance = new QueuifiedSFTP(concurrency);
        return new Promise((resolve, reject) => {
            client.sftp((err, sftp) => {
                if (err)
                    return reject(err);
                instance.sftp = sftp;
                resolve(instance);
            });
        });
    }
    fastPut(localPath, remotePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('fastPut', [localPath, remotePath, options]);
        });
    }
    open(filename, mode, attributes) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('open', [filename, mode, attributes]);
        });
    }
    writeData(handle, buffer, offset, length, position) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('write', [handle, buffer, offset, length, position]);
        });
    }
    close(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('close', [handle]);
        });
    }
    mkdir(path, attributes) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('mkdir', [path, attributes]);
        });
    }
    rmdir(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('rmdir', [path]);
        });
    }
    readdir(location) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('readdir', [location]);
        });
    }
    unlink(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('unlink', [path]);
        });
    }
    lstat(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run('lstat', [path]);
        });
    }
    run(method, args) {
        return new Promise((resolve, reject) => {
            this.queue.push(cb => {
                this.sftp[method](...args, (err, result) => {
                    err ? reject(err) : resolve(result);
                    cb(null, result);
                });
            });
            if (!this.started) {
                this.queue.start();
                this.started = true;
            }
        });
    }
}
exports.QueuifiedSFTP = QueuifiedSFTP;
