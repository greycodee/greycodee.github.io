"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const minimatch = require("minimatch");
const chalk_1 = require("chalk");
const path = require("path");
class SyncTableEntry {
    constructor(table, name) {
        this.table = table;
        this.name = name;
        this.localStat = null;
        this.remoteStat = null;
        this.localTimestamp = null;
        this.remoteTimestamp = null;
        this.path = path.posix.join(table.relativePath || '.', name);
    }
    /**
     * Get a task for this entry
     */
    getTask() {
        if (this.task) {
            return this.task;
        }
        let task = { method: undefined, removeRemote: false, hasError: false, skip: false };
        let options = this.table.options;
        if (this.localStat === 'error' || this.remoteStat === 'error') {
            task.hasError = true;
        }
        if (this.remoteStat !== null && !task.hasError && this.localStat !== this.remoteStat) {
            task.removeRemote = true;
        }
        if (this.localStat === 'excluded' && options.excludeMode === 'ignore') {
            task.removeRemote = false;
        }
        if (this.localStat === 'excluded' || task.hasError) {
            task.method = 'noop';
        }
        else if (this.localStat === 'file') {
            if (!options.forceUpload && this.localTimestamp <= this.remoteTimestamp) {
                task.skip = true;
                task.method = 'noop';
            }
            else {
                task.method = 'upload';
            }
        }
        else if (this.localStat === 'dir') {
            task.method = 'sync';
        }
        else {
            task.method = 'noop';
        }
        return this.task = task;
    }
    /**
     * Output live run mode log
     */
    liveRunLog() {
        let task = this.getTask();
        let displayName = this.path;
        if (task.removeRemote) {
            if (this.remoteStat === 'dir') {
                console.log(chalk_1.default.red(' remote dir removed : ') + displayName);
            }
            else {
                console.log(chalk_1.default.red('remote file removed : ') + displayName);
            }
        }
        else if (task.hasError) {
            console.log(chalk_1.default.bgRed(`              error : ${displayName}`));
        }
        else if (task.skip) {
            console.log(chalk_1.default.gray('            skipped : ') + displayName);
        }
        else if (task.method === 'noop') {
            console.log(chalk_1.default.gray('            ignored : ') + displayName);
        }
        if (task.method === 'sync') {
            console.log(chalk_1.default.cyan('     sync completed : ') + displayName);
        }
        else if (task.method === 'upload') {
            console.log(chalk_1.default.yellow('      file uploaded : ') + displayName);
        }
    }
    /**
     * Output dry run mode log
     */
    dryRunLog() {
        let taskName = '';
        let task = this.getTask();
        function label(stat) {
            switch (stat) {
                case 'dir': return chalk_1.default.cyan('D');
                case 'file': return chalk_1.default.yellow('F');
                case 'excluded': return chalk_1.default.gray('X');
                case 'error': return chalk_1.default.red('!');
                default: return ' ';
            }
        }
        if (this.remoteStat === 'error') {
            taskName = 'denied';
        }
        else if (task.removeRemote) {
            taskName = 'remove remote';
            if (task.method !== 'noop') {
                taskName += ' and ' + task.method;
            }
        }
        else if (task.skip) {
            taskName = 'skip';
        }
        else if (task.method === 'noop') {
            taskName = 'ignore';
        }
        else {
            taskName = task.method;
        }
        console.log(`[ ${label(this.localStat)} | ${label(this.remoteStat)} ] ${this.path}`);
        console.log(chalk_1.default.magenta(`          -> ${taskName}`));
        console.log('');
    }
    /**
     * Check if the path matches the exclude patterns
     */
    detectExclusion() {
        let pathForMatch = this.path;
        let patterns = this.table.options.exclude;
        if (this.localStat === 'dir') {
            pathForMatch += path.posix.sep;
        }
        if (patterns.some(pattern => minimatch(pathForMatch, pattern))) {
            this.localStat = 'excluded';
        }
    }
}
exports.SyncTableEntry = SyncTableEntry;
class SyncTable {
    constructor(relativePath, options) {
        this.relativePath = relativePath;
        this.options = options;
        this.registry = [];
    }
    get(filename) {
        return this.registry.find(e => e.name === filename);
    }
    get all() {
        return this.registry;
    }
    set(filename, stats) {
        let entry = this.get(filename);
        let isNew = false;
        if (!entry) {
            entry = new SyncTableEntry(this, filename);
            isNew = true;
        }
        Object.assign(entry, stats);
        if (isNew) {
            this.registry.push(entry);
        }
        return entry;
    }
    has(filename) {
        return this.registry.some(e => e.name === filename);
    }
    forEach(fn) {
        this.registry.forEach(fn);
        return this;
    }
}
exports.SyncTable = SyncTable;
